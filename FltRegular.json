[{"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "Int.zero_ne_one",
   "Nontrivial",
   "Exists.intro",
   "Nontrivial.mk",
   "instOfNat",
   "Int"],
  "name": "Int.instNontrivial",
  "constType": "Nontrivial ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "MulOneClass.toMul",
   "Eq.refl",
   "Dvd.dvd",
   "semigroupDvd",
   "Exists.intro",
   "Exists.casesOn",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "mul_assoc",
   "Eq.ndrec",
   "HMul.hMul",
   "Eq.symm",
   "congrArg",
   "id"],
  "name": "mul_dvd_mul_left",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] {b c : α} (a : α), b ∣ c → a * b ∣ a * c",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Neg.neg",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_right",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "id"],
  "name": "add_sub_cancel_right",
  "constType": "∀ {G : Type u_3} [inst : AddGroup G] (a b : G), a + b - b = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Nat.casesAuxOn",
   "OfNat.ofNat",
   "HEq",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Nat.elimOffset",
   "Eq",
   "Iff.intro",
   "Nat.add",
   "Iff",
   "Eq.ndrec",
   "HEq.refl",
   "Nat.noConfusion",
   "instOfNatNat",
   "Eq.casesOn",
   "Nat",
   "Eq.symm",
   "Nat.succ"],
  "name": "Nat.pred_eq_succ_iff",
  "constType": "∀ {m n : ℕ}, n - 1 = m + 1 ↔ n = m + 2",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "propext",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Nat.cast_eq_zero",
   "Eq"],
  "name": "Mathlib.Algebra.CharZero.Defs._auxLemma.3",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, (↑n = 0) = (n = 0)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedCommMonoid", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommMonoidWithZero α] → LinearOrderedCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "RingHom",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "IsDomain",
   "Module.Finite",
   "Semiring.toMonoidWithZero",
   "FractionRing.field",
   "Ideal.span",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "Eq",
   "nonZeroDivisors",
   "Semiring.toNonAssocSemiring",
   "OreLocalization.oreSetComm",
   "FractionRing.liftAlgebra",
   "Algebra",
   "DFunLike.coe",
   "Set.image",
   "CommSemiring.toCommMonoidWithZero",
   "IsIntegrallyClosed",
   "Eq.symm",
   "Algebra.toSMul",
   "Semiring.toModule",
   "Algebra.intNorm",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "OreLocalization.instCommRing",
   "NoZeroSMulDivisors",
   "Ideal.map",
   "Algebra.toModule",
   "Function.comp",
   "OreLocalization.instRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MonoidHom",
   "RingHom.instFunLike",
   "OreLocalization.instAlgebra",
   "CommRing.toCommSemiring",
   "CommRing.toCommMonoid",
   "FractionRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "Ideal.map_spanIntNorm",
   "FractionRing.instNoZeroSMulDivisors",
   "MonoidHom.instFunLike",
   "Ideal.spanIntNorm",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.IsSeparable",
   "Ideal",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.11",
  "constType":
  "∀ (R : Type u_1) [inst : CommRing R] {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsIntegrallyClosed R] [inst_4 : IsDomain R] [inst_5 : IsDomain S] [inst_6 : NoZeroSMulDivisors R S]\n  [hRS : Module.Finite R S] [inst_7 : IsIntegrallyClosed S]\n  [inst_8 : Algebra.IsSeparable (FractionRing R) (FractionRing S)] (I : Ideal S) {T : Type u_3} [inst_9 : CommRing T]\n  (f : R →+* T), Ideal.span (⇑f ∘ ⇑(Algebra.intNorm R S) '' ↑I) = Ideal.map f (Ideal.spanIntNorm R I)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_5",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_10",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Set.instSingletonSet",
   "Ideal.prod_span_singleton",
   "Set",
   "CommSemiring",
   "Finset.prod",
   "Finset",
   "Submodule.instIdemCommSemiring",
   "Singleton.singleton",
   "CommSemiring.toCommMonoid",
   "Ideal.span",
   "Algebra.id",
   "Eq.symm",
   "Ideal",
   "IdemCommSemiring.toCommSemiring",
   "Eq"],
  "name": "FltRegular.CaseI.Statement._auxLemma.3",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] {ι : Type u_2} (s : Finset ι) (I : ι → R),\n  Ideal.span {∏ i ∈ s, I i} = ∏ i ∈ s, Ideal.span {I i}",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.instBot",
   "Bot.bot",
   "OfNat.ofNat",
   "Semiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "Ideal.span",
   "Submodule.span_singleton_eq_bot",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Set.instSingletonSet",
   "Iff",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Ideal",
   "Semiring.toModule"],
  "name": "Ideal.span_singleton_eq_bot",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] {x : α}, Ideal.span {x} = ⊥ ↔ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_5",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "instHAdd",
   "HAdd.hAdd",
   "add_right_injective",
   "Add",
   "Function.Injective.eq_iff",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "add_right_inj",
  "constType":
  "∀ {G : Type u_3} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, a + b = a + c ↔ b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "False.elim", "False", "propext", "Not", "absurd", "Eq"],
  "name": "eq_false",
  "constType": "∀ {p : Prop}, ¬p → p = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "DecidablePred",
   "And",
   "propext",
   "Finset",
   "Finset.mem_filter",
   "Finset.filter",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α} {a : α}, (a ∈ Finset.filter p s) = (a ∈ s ∧ p a)",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Finset.map.proof_1",
   "Finset",
   "Finset.val",
   "Function.Embedding",
   "DFunLike.coe",
   "Finset.mk",
   "Function.instFunLikeEmbedding"],
  "name": "Finset.map",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → (α ↪ β) → Finset α → Finset β",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_39",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_40._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "RingHom",
   "Polynomial.coeff_map",
   "Semiring",
   "RingHom.comp",
   "Polynomial.coeff",
   "implies_true",
   "RingHom.instFunLike",
   "Polynomial.map",
   "True",
   "Eq",
   "Polynomial",
   "Semiring.toNonAssocSemiring",
   "Polynomial.ext",
   "of_eq_true",
   "forall_congr",
   "congr",
   "Nat",
   "DFunLike.coe",
   "congrArg",
   "Eq.trans"],
  "name": "Polynomial.map_map",
  "constType":
  "∀ {R : Type u} {S : Type v} {T : Type w} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S) [inst_2 : Semiring T]\n  (g : S →+* T) (p : Polynomial R), Polynomial.map g (Polynomial.map f p) = Polynomial.map (g.comp f) p",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_12",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_34",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_35._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Classical.not_not", "propext", "Not", "Eq"],
  "name": "FltRegular.CaseI.AuxLemmas._auxLemma.8",
  "constType": "∀ {a : Prop}, (¬¬a) = a",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_44._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Group.toDivisionMonoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Iff.rfl",
   "SetLike.instMembership",
   "Eq",
   "Eq.mpr",
   "Iff",
   "QuotientGroup.mk",
   "Subgroup.Normal",
   "Subgroup",
   "QuotientGroup.Quotient.group",
   "Iff.trans",
   "Group",
   "QuotientGroup.eq",
   "HasQuotient.Quotient",
   "InvOneClass.toInv",
   "id",
   "Membership.mem",
   "Subgroup.inv_mem_iff",
   "QuotientGroup.instHasQuotientSubgroup",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "InvOneClass.toOne",
   "instHMul",
   "DivInvOneMonoid.toInvOneClass",
   "propext",
   "HMul.hMul",
   "mul_one",
   "Group.toDivInvMonoid",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "Subgroup.instSetLike",
   "Inv.inv"],
  "name": "QuotientGroup.eq_one_iff",
  "constType":
  "∀ {G : Type u} [inst : Group G] {N : Subgroup G} [nN : N.Normal] (x : G), ↑x = 1 ↔ x ∈ N",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "eq_true",
   "PNat.pos",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "True",
   "Eq",
   "PNat"],
  "name": "FltRegular.NumberTheory.KummersLemma.Field._auxLemma.1",
  "constType": "∀ (n : ℕ+), (0 < ↑n) = True",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "HAdd",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["And", "Iff", "iff_of_eq", "and_true", "True"],
  "name": "and_true_iff",
  "constType": "∀ (p : Prop), p ∧ True ↔ p",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "LinearOrderedAddCommMonoid.toLinearOrder",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "IsRightCancelMulZero.mk",
   "ExistsAddOfLE",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "strictMono_mul_left_of_pos",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "contravariant_swap_add_of_contravariant_add",
   "strictAnti_mul_left",
   "IsCancelMulZero.mk",
   "Ne.lt_or_lt",
   "Ne",
   "Or",
   "IsCancelAdd.toIsLeftCancelAdd",
   "StrictAnti.injective",
   "strictMono_mul_right_of_pos",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "NonUnitalNonAssocSemiring.toMul",
   "Or.casesOn",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "AddCancelMonoid.toIsCancelAdd",
   "IsLeftCancelMulZero.mk",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toNontrivial",
   "StrictOrderedSemiring.toOrderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "IsDomain.mk",
   "LT.lt",
   "LinearOrderedSemiring",
   "HMul.hMul",
   "LinearOrder.toPartialOrder",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "StrictMono.injective",
   "MonoidWithZero.toZero",
   "strictAnti_mul_right",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "LinearOrderedRing.isDomain",
  "constType":
  "∀ {α : Type u} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α], IsDomain α",
  "constCategory": "Definition"},
 {"references":
  ["MvPolynomial.commSemiring",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MvPolynomial",
   "CommSemiring",
   "LinearMap.instFunLike",
   "MvPolynomial.totalDegree",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MvPolynomial.homogeneousComponent",
   "DFunLike.coe",
   "RingHom.id",
   "LinearMap",
   "Semiring.toModule",
   "MvPolynomial.module"],
  "name": "MvPolynomial.leadingTerms",
  "constType":
  "{R : Type u_1} → {ι : Type u_2} → [inst : CommSemiring R] → MvPolynomial ι R → MvPolynomial ι R",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat", "Nat.pow.match_1", "Unit", "instOfNatNat", "Nat"],
  "name": "Nat.pred",
  "constType": "ℕ → ℕ",
  "constCategory": "Definition"},
 {"references": ["LE.mk", "Nat.le", "LE", "Nat"],
  "name": "instLENat",
  "constType": "LE ℕ",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "OfNat.ofNat",
   "pow_eq_zero_iff",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "MonoidWithZero.toMonoid",
   "propext",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "MonoidWithZero.toZero",
   "MonoidWithZero"],
  "name": "FltRegular.NumberTheory.KummersLemma.Field._auxLemma.2",
  "constType":
  "∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] {a : M₀} {n : ℕ} [inst_1 : NoZeroDivisors M₀],\n  n ≠ 0 → (a ^ n = 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "Subalgebra.toCommRing",
   "Subalgebra",
   "EuclideanDomain.toCommRing",
   "algebraInt",
   "integralClosure",
   "Subalgebra.instSetLike",
   "CommRing",
   "SetLike.instMembership",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "Field.toEuclideanDomain",
   "Field",
   "inferInstanceAs",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Int",
   "Subtype"],
  "name": "NumberField.RingOfIntegers.instCommRing",
  "constType":
  "(K : Type u_1) → [inst : Field K] → CommRing (NumberField.RingOfIntegers K)",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "decide_eq_false",
   "Bool.true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "ne_true_of_eq_false",
   "Not",
   "Bool",
   "absurd",
   "Eq"],
  "name": "of_decide_eq_true",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = true → p",
  "constCategory": "Theorem"},
 {"references": ["DivisionRing", "Ring"],
  "name": "DivisionRing.toRing",
  "constType": "{α : Type u_4} → [self : DivisionRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Mathlib.Meta.NormNum.isInt_add",
   "Semiring.toNatCast",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "Int.instRing",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "Int.instCharZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "instNatAtLeastTwo",
   "LinearOrder.toPartialOrder",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "Int.instAddGroup",
   "sub_nonpos_of_le",
   "Int.instSemiring",
   "GE.ge",
   "Semiring.toMonoidWithZero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Int.rawCast",
   "Eq.refl",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddMonoid.toAddZeroClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "Int.instAddMonoid",
   "AddMonoid.toAddSemigroup",
   "Int.instCovariantClassAddLE",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "zero_lt_one",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "covariant_swap_add_of_covariant_add",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.mul_add",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "LE.le",
   "Int.instLinearOrderedCommRing",
   "Mathlib.Tactic.Ring.zero_mul",
   "instNatCastInt",
   "Bool.false",
   "Mathlib.Tactic.Ring.add_mul",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.atom_pf",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.Ring.mul_congr",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "instLTNat",
   "Preorder.toLE",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "StrictOrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_neg_of_pos",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.rawCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "lt_of_not_ge",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instLTInt",
   "Int.instAddCommSemigroup",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "congrArg",
   "Int.instLEInt",
   "OrderedAddCommGroup.toAddCommGroup",
   "Int.ofNat",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Linarith.lt_irrefl",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Tactic.Zify._auxLemma.2",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "instLENat",
   "Preorder.toLT",
   "instHPow",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Linarith.mul_neg",
   "instOfNatNat",
   "NeZero.charZero_one",
   "CommSemiring.toCommMonoidWithZero",
   "add_lt_of_neg_of_le",
   "id",
   "instOfNatAtLeastTwo",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "OrderedCommSemiring.toOrderedSemiring",
   "Nat.instLinearOrder",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "Bool",
   "NegZeroClass.toZero",
   "Int.instCommSemiring"],
  "name": "FltRegular.CaseI.two_lt",
  "constType": "∀ {p : ℕ}, 5 ≤ p → 2 < p",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "Subtype.property",
   "OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "PNat"],
  "name": "PNat.pos",
  "constType": "∀ (n : ℕ+), 0 < ↑n",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Exists", "Finset", "Finset.instMembership"],
  "name": "Finset.Nonempty",
  "constType": "{α : Type u_1} → Finset α → Prop",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name"],
  "name": "Lean.Name.str",
  "constType": "Lean.Name → String → Lean.Name",
  "constCategory": "Other"},
 {"references": ["LE.mk", "LE", "Int.le", "Int"],
  "name": "Int.instLEInt",
  "constType": "LE ℤ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "instHMul",
   "Iff.mp",
   "Int.instSemiring",
   "Int.instMul",
   "HMul.hMul",
   "Odd",
   "And.left",
   "Int.odd_mul",
   "Int"],
  "name": "Int.Odd.of_mul_left",
  "constType": "∀ {m n : ℤ}, Odd (m * n) → Odd m",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalRing.mk",
   "NormedRing.toNorm",
   "AddCommMonoid.toAddMonoid",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_6",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_3",
   "NormedCommRing.mul_comm",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_12",
   "Ring.toNeg",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_4",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_8",
   "Ring.toSub",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_1",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_9",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_7",
   "NormedRing.toRing",
   "AddCommGroup.mk",
   "NonUnitalNormedCommRing.mk",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_10",
   "AddGroup.mk",
   "NormedCommRing.toNormedRing",
   "NormedRing.toMetricSpace",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_13",
   "NormedCommRing",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_2",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_11",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNormedCommRing",
   "NonUnitalNormedRing.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NormedCommRing.toNonUnitalNormedCommRing.proof_5"],
  "name": "NormedCommRing.toNonUnitalNormedCommRing",
  "constType":
  "{α : Type u_1} → [β : NormedCommRing α] → NonUnitalNormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["instENatCanonicallyOrderedCommSemiring",
   "Equiv",
   "PartENat.instLE",
   "PartialOrder.toPreorder",
   "PartENat.withTopEquiv_le",
   "PartENat",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "PartENat.withTopEquiv",
   "propext",
   "ENat",
   "OrderedCommSemiring.toOrderedSemiring",
   "Equiv.instFunLike",
   "DFunLike.coe",
   "Eq.symm",
   "OrderedSemiring.toPartialOrder"],
  "name": "FltRegular.CaseII.AuxLemmas._auxLemma.6",
  "constType":
  "∀ {x y : PartENat}, (x ≤ y) = (PartENat.withTopEquiv x ≤ PartENat.withTopEquiv y)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.instMembership",
   "SetLike.instMembership",
   "SetLike.coe"],
  "name": "SetLike.mem_coe",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, x ∈ ↑p ↔ x ∈ p",
  "constCategory": "Theorem"},
 {"references":
  ["Subgroup.mk",
   "MonoidHom.ker.proof_2",
   "MulOneClass",
   "Subgroup",
   "Submonoid",
   "Group",
   "MonoidHom.ker.proof_1",
   "MonoidHom.instFunLike",
   "Group.toDivInvMonoid",
   "MonoidHom",
   "DivInvMonoid.toMonoid",
   "MonoidHom.mker",
   "Monoid.toMulOneClass"],
  "name": "MonoidHom.ker",
  "constType":
  "{G : Type u_1} → [inst : Group G] → {M : Type u_7} → [inst_1 : MulOneClass M] → (G →* M) → Subgroup G",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "AddCommSemigroup",
   "Int.instAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "Int"],
  "name": "Int.instAddCommSemigroup",
  "constType": "AddCommSemigroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Iff",
   "Iff.mp",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toZero",
   "AddGroupWithOne",
   "instOfNatNat",
   "Int.cast_negSucc",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Nat.cast_eq_zero",
   "Int.casesOn",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.cast_natCast",
   "congr_arg",
   "neg_eq_zero",
   "instAddNat",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Int.cast_zero",
   "Iff.intro",
   "Eq.ndrec",
   "CharZero",
   "instNatCastInt",
   "propext",
   "Nat.noConfusion",
   "Int.negSucc",
   "Int.cast",
   "Eq.mp",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "congrArg",
   "Int"],
  "name": "Int.cast_eq_zero",
  "constType":
  "∀ {α : Type u_3} [inst : AddGroupWithOne α] [inst_1 : CharZero α] {n : ℤ}, ↑n = 0 ↔ n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card", "Finset.range", "Multiset.card_range", "Nat", "Eq"],
  "name": "Finset.card_range",
  "constType": "∀ (n : ℕ), (Finset.range n).card = n",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "SubtractionCommMonoid.toAddCommMonoid",
   "SubtractionCommMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans"],
  "name": "add_sub_right_comm",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionCommMonoid α] (a b c : α), a + b - c = a - c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Classical.propDecidable.proof_1", "Decidable", "Classical.choice"],
  "name": "Classical.propDecidable",
  "constType": "(a : Prop) → Decidable a",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Units",
   "Units.instMul.proof_2",
   "MulOneClass.toMul",
   "Monoid",
   "Units.val",
   "HMul.hMul",
   "Mul",
   "Units.instMul.proof_1",
   "Units.inv",
   "Monoid.toMulOneClass",
   "Units.mk",
   "Mul.mk"],
  "name": "Units.instMul",
  "constType": "{α : Type u} → [inst : Monoid α] → Mul αˣ",
  "constCategory": "Definition"},
 {"references":
  ["DivisionSemiring.toSemiring",
   "DivisionRing.toDivisionSemiring",
   "DivisionRing",
   "Module.Finite",
   "AddCommGroup.toAddCommMonoid",
   "Module",
   "AddCommGroup"],
  "name": "FiniteDimensional",
  "constType":
  "(K : Type u_1) → (V : Type u_2) → [inst : DivisionRing K] → [inst_1 : AddCommGroup V] → [inst : Module K V] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.SourceInfo.none",
   "Bool.false",
   "Bool.true",
   "Unit",
   "Lean.SourceInfo.fromRef.match_2",
   "Lean.Syntax.getTailPos?",
   "Lean.SourceInfo.fromRef.match_1",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.synthetic",
   "optParam",
   "Lean.Syntax",
   "Lean.Syntax.getPos?",
   "String.Pos",
   "Option"],
  "name": "Lean.SourceInfo.fromRef",
  "constType": "Lean.Syntax → optParam Bool false → Lean.SourceInfo",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "Finset.instInsert",
   "DecidableEq",
   "propext",
   "Finset",
   "Insert.insert",
   "Finset.mem_insert",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.CaseII.Statement._auxLemma.7",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, (a ∈ insert b s) = (a = b ∨ a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Associated",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Set.instSingletonSet",
   "MonoidWithZero.toMonoid",
   "propext",
   "Ideal.span_singleton_eq_span_singleton",
   "Set",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "Singleton.singleton",
   "Ideal.span",
   "Eq.symm",
   "Ideal",
   "CommRing",
   "Eq"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.14",
  "constType":
  "∀ {α : Type u} [inst : CommRing α] [inst_1 : IsDomain α] {x y : α}, Associated x y = (Ideal.span {x} = Ideal.span {y})",
  "constCategory": "Theorem"},
 {"references":
  ["Group.toDivisionMonoid",
   "Membership.mem",
   "InvOneClass.toOne",
   "OfNat.ofNat",
   "Bot.bot",
   "Subgroup.mem_bot",
   "DivInvOneMonoid.toInvOneClass",
   "propext",
   "Subgroup",
   "One.toOfNat1",
   "Group",
   "DivisionMonoid.toDivInvOneMonoid",
   "Subgroup.instSetLike",
   "Subgroup.instBot",
   "SetLike.instMembership",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert90._auxLemma.6",
  "constType": "∀ {G : Type u_1} [inst : Group G] {x : G}, (x ∈ ⊥) = (x = 1)",
  "constCategory": "Theorem"},
 {"references": ["Ring", "Neg"],
  "name": "Ring.toNeg",
  "constType": "{R : Type u} → [self : Ring R] → Neg R",
  "constCategory": "Definition"},
 {"references":
  ["PNat.val",
   "IsCyclotomicExtension",
   "CommRing.toCommMonoid",
   "CommSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "Set.instSingletonSet",
   "IsPrimitiveRoot",
   "Exists.choose",
   "Set",
   "Algebra",
   "Singleton.singleton",
   "IsCyclotomicExtension.zeta.proof_1",
   "CommRing",
   "PNat"],
  "name": "IsCyclotomicExtension.zeta",
  "constType":
  "(n : ℕ+) →\n  (A : Type w) →\n    (B : Type z) →\n      [inst : CommRing A] → [inst_1 : CommRing B] → [inst_2 : Algebra A B] → [inst : IsCyclotomicExtension {n} A B] → B",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "False",
   "instSubNat",
   "Nat.decLt",
   "HSub.hSub",
   "instDecidableAnd",
   "instLTNat",
   "LE.le",
   "Eq",
   "ite",
   "And",
   "Nat.div_rec_lemma.match_1",
   "instHMod",
   "Nat.mod_eq",
   "instLENat",
   "Nat.not_le_of_gt",
   "Eq.rec",
   "LT.lt",
   "letFun",
   "HMod.hMod",
   "Not",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "absurd",
   "Nat.instMod",
   "if_neg",
   "Nat.decLe"],
  "name": "Nat.mod_eq_of_lt",
  "constType": "∀ {a b : ℕ}, a < b → a % b = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Nonempty",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references": ["LE", "Preorder"],
  "name": "Preorder.toLE",
  "constType": "{α : Type u} → [self : Preorder α] → LE α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "eq_zero_of_add_right",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddUnits",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Iff.intro",
   "Zero.toOfNat0",
   "And",
   "Iff",
   "Eq.ndrec",
   "AddMonoid.toZero",
   "Subsingleton",
   "And.intro",
   "Eq.symm",
   "add_zero",
   "And.casesOn",
   "AddCommMonoid",
   "eq_zero_of_add_left"],
  "name": "add_eq_zero",
  "constType":
  "∀ {α : Type u} [inst : AddCommMonoid α] [inst_1 : Subsingleton (AddUnits α)] {a b : α}, a + b = 0 ↔ a = 0 ∧ b = 0",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Not", "rfl", "Eq"],
  "name": "ne_eq",
  "constType": "∀ {α : Sort u_1} (a b : α), (a ≠ b) = ¬a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat", "UInt8", "Bool.casesOn", "_obj", "Nat.decEq", "Int.sub"],
  "name": "FltRegular.CaseI.f0k₂._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["AddCommGroup", "LieRing"],
  "name": "LieRing.toAddCommGroup",
  "constType": "{L : Type v} → [self : LieRing L] → AddCommGroup L",
  "constCategory": "Definition"},
 {"references": ["MulOneClass", "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulOneClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulOneClass M₀",
  "constCategory": "Definition"},
 {"references":
  ["LE.mk",
   "Zero",
   "Finsupp.instFunLike",
   "Finsupp",
   "LE",
   "DFunLike.coe",
   "LE.le"],
  "name": "Finsupp.instLEFinsupp",
  "constType":
  "{ι : Type u_1} → {α : Type u_2} → [inst : Zero α] → [inst_1 : LE α] → LE (ι →₀ α)",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_26"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_30._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff", "iff_true_intro", "Subsingleton", "True", "Subsingleton.elim", "Eq"],
  "name": "eq_iff_true_of_subsingleton",
  "constType":
  "∀ {α : Sort u_1} [inst : Subsingleton α] (x y : α), x = y ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Units",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "MonoidWithZero.toMonoid",
   "Units.val",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Units.ne_zero",
   "Eq",
   "MonoidWithZero"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.18",
  "constType":
  "∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] [inst_1 : Nontrivial M₀] (u : M₀ˣ), (↑u = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "instHMul",
   "MulOneClass.toMul",
   "CommMonoid",
   "propext",
   "HMul.hMul",
   "IsUnit",
   "CommMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "IsUnit.mul_iff"],
  "name": "FltRegular.NumberTheory.KummersLemma.KummersLemma._auxLemma.5",
  "constType":
  "∀ {M : Type u_1} [inst : CommMonoid M] {x y : M}, IsUnit (x * y) = (IsUnit x ∧ IsUnit y)",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "Subtype.property",
   "Ne",
   "OfNat.ofNat",
   "LT.lt.ne'",
   "PartialOrder.toPreorder",
   "Subtype.val",
   "LT.lt",
   "Nat.instLinearOrder",
   "instOfNatNat",
   "LinearOrder.toPartialOrder",
   "Nat",
   "instLTNat",
   "PNat"],
  "name": "PNat.ne_zero",
  "constType": "∀ (n : ℕ+), ↑n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "MulHomClass",
   "FunLike",
   "map_mul",
   "HMul.hMul",
   "DFunLike.coe",
   "Mul",
   "Eq.symm",
   "Eq"],
  "name": "FltRegular.NumberTheory.QuotientTrace._auxLemma.3",
  "constType":
  "∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Mul M] [inst_1 : Mul N] [inst_2 : FunLike F M N]\n  [inst_3 : MulHomClass F M N] (f : F) (x y : M), f x * f y = f (x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "InvolutiveNeg",
   "Iff",
   "InvolutiveNeg.toNeg",
   "Eq.rec",
   "Neg.neg",
   "neg_neg",
   "Eq.symm",
   "Eq"],
  "name": "neg_eq_iff_eq_neg",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = b ↔ a = -b",
  "constCategory": "Theorem"},
 {"references":
  ["PartENat.instLE",
   "PartENat.orderedAddCommMonoid",
   "PartENat.partialOrder",
   "Nat.cast_le",
   "instLENat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Iff",
   "PartENat.instAddCommMonoidWithOne",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "PartENat",
   "PartENat.instCharZero",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "PartENat.instZeroLEOneClass"],
  "name": "PartENat.coe_le_coe",
  "constType": "∀ {x y : ℕ}, ↑x ≤ ↑y ↔ x ≤ y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommGroup.toDivisionAddCommMonoid",
   "add_comm",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddCommMagma.toAdd",
   "True",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "Ring",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "neg_add_rev"],
  "name": "Mathlib.Tactic.Ring.neg_add",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a₁ a₂ b₁ b₂ : R}, -a₁ = b₁ → -a₂ = b₂ → -(a₁ + a₂) = b₁ + b₂",
  "constCategory": "Theorem"},
 {"references": ["Exists", "instHAdd", "HAdd.hAdd", "Add", "Eq"],
  "name": "Even",
  "constType": "{α : Type u_2} → [inst : Add α] → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "List.Nodup",
   "Multiset.Nodup.proof_1",
   "List",
   "List.isSetoid",
   "Multiset"],
  "name": "Multiset.Nodup",
  "constType": "{α : Type u_1} → Multiset α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Or",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Fin.castSucc",
   "Or.casesOn",
   "instLTFin",
   "Eq",
   "Fin.succAbove_of_castSucc_lt",
   "Fin.ne_of_lt",
   "Eq.mpr",
   "LT.lt",
   "instOfNatNat",
   "Fin.succAbove_of_lt_succ",
   "Fin.ne_of_gt",
   "Nat",
   "congrArg",
   "Fin.succ",
   "Fin.castSucc_lt_or_lt_succ",
   "Nat.succ",
   "Fin",
   "Fin.succAbove",
   "id"],
  "name": "Fin.succAbove_ne",
  "constType": "∀ {n : ℕ} (p : Fin (n + 1)) (i : Fin n), p.succAbove i ≠ p",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "lt_of_lt_of_le.match_2",
   "Preorder",
   "lt_of_lt_of_le.match_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_lt_of_le",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a < b → b ≤ c → a < c",
  "constCategory": "Theorem"},
 {"references": ["False", "Not"],
  "name": "Not.intro",
  "constType": "∀ {a : Prop}, (a → False) → ¬a",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["DivisionCommMonoid.mk",
   "CommGroupWithZero.toGroupWithZero",
   "DivisionMonoid.inv_inv",
   "CommGroupWithZero",
   "CommGroupWithZero.toInv",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero.zpow_neg'",
   "GroupWithZero.toDivisionMonoid",
   "CommMonoidWithZero.toCommMonoid",
   "DivisionMonoid.mk",
   "DivisionMonoid.inv_eq_of_mul",
   "DivInvMonoid.mk",
   "CommGroupWithZero.toCommMonoidWithZero",
   "CommGroupWithZero.toDivisionCommMonoid.proof_1",
   "CommGroupWithZero.zpow_succ'",
   "DivisionMonoid",
   "CommGroupWithZero.div_eq_mul_inv",
   "DivisionMonoid.mul_inv_rev",
   "CommGroupWithZero.toDiv",
   "DivisionCommMonoid",
   "CommMonoid.toMonoid",
   "CommGroupWithZero.zpow_zero'"],
  "name": "CommGroupWithZero.toDivisionCommMonoid",
  "constType":
  "{G₀ : Type u_3} → [inst : CommGroupWithZero G₀] → DivisionCommMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["Submonoid.instSetLike.proof_1",
   "Subsemigroup.carrier",
   "SetLike",
   "MulOneClass.toMul",
   "SetLike.mk",
   "MulOneClass",
   "Submonoid.toSubsemigroup",
   "Submonoid"],
  "name": "Submonoid.instSetLike",
  "constType":
  "{M : Type u_1} → [inst : MulOneClass M] → SetLike (Submonoid M) M",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "Distrib.toAdd",
   "Semigroup.toMul",
   "NonUnitalRing.toNonUnitalSemiring",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "semigroupDvd",
   "AddMonoid.toAddZeroClass",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "SubNegMonoid.toSub",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "NonUnitalRing",
   "Dvd.dvd.add",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "instHSub",
   "instHAdd",
   "Mathlib.Algebra.Ring.Divisibility.Basic._auxLemma.6",
   "HSub.hSub",
   "Neg.neg",
   "Dvd.dvd",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "Distrib.leftDistribClass",
   "Dvd.dvd.neg_right",
   "SubNegMonoid.toAddMonoid",
   "Eq.mp",
   "NonUnitalSemiring.toSemigroupWithZero",
   "congrArg"],
  "name": "dvd_sub",
  "constType":
  "∀ {α : Type u_1} [inst : NonUnitalRing α] {a b c : α}, a ∣ b → a ∣ c → a ∣ b - c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "SetLike.instPartialOrder",
   "SetLike",
   "PartialOrder.toPreorder",
   "propext",
   "SetLike.le_def",
   "LE.le",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.8",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {S T : A}, (S ≤ T) = ∀ ⦃x : B⦄, x ∈ S → x ∈ T",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.ParserDescr",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommMonoid", "CanonicallyOrderedAddCommMonoid"],
  "name": "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u_1} → [self : CanonicallyOrderedAddCommMonoid α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset",
   "Finset.val",
   "Multiset.cons",
   "Finset.cons.proof_1",
   "Not",
   "Finset.mk",
   "Finset.instMembership"],
  "name": "Finset.cons",
  "constType": "{α : Type u_1} → (a : α) → (s : Finset α) → a ∉ s → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Eq.refl",
   "Eq",
   "PProd",
   "Eq.mpr",
   "FunLike",
   "instHPow",
   "PUnit",
   "MonoidHomClass.toOneHomClass",
   "map_mul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "DFunLike.coe",
   "Nat",
   "Nat.succ",
   "id",
   "HPow.hPow",
   "Nat.below",
   "Nat.brecOn",
   "Monoid",
   "instAddNat",
   "MonoidHomClass.toMulHomClass",
   "instHAdd",
   "Unit",
   "map_one",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "pow_zero",
   "MonoidHomClass",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "map_pow.match_1",
   "HMul.hMul",
   "pow_succ",
   "congrArg"],
  "name": "map_pow",
  "constType":
  "∀ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : FunLike F G H] [inst_1 : Monoid G] [inst_2 : Monoid H]\n  [inst_3 : MonoidHomClass F G H] (f : F) (a : G) (n : ℕ), f (a ^ n) = f a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["CompleteLattice.le_sInf",
   "Membership.mem",
   "CompleteLattice.le_sSup",
   "PartialOrder.toPreorder",
   "Set",
   "Set.Nonempty",
   "CompleteLattice.sInf_le",
   "Set.instMembership",
   "ConditionallyCompleteLattice",
   "BddAbove",
   "ConditionallyCompleteLattice.mk",
   "CompleteLattice.toLattice",
   "upperBounds",
   "CompleteLattice",
   "CompleteLattice.sSup_le",
   "CompleteLattice.toInfSet",
   "BddBelow",
   "lowerBounds",
   "Lattice.toSemilatticeSup",
   "CompleteLattice.toSupSet",
   "SemilatticeSup.toPartialOrder"],
  "name": "CompleteLattice.toConditionallyCompleteLattice",
  "constType":
  "{α : Type u_1} → [inst : CompleteLattice α] → ConditionallyCompleteLattice α",
  "constCategory": "Definition"},
 {"references": ["Not", "IsEmpty", "not_isEmpty_iff", "Iff.mpr", "Nonempty"],
  "name": "not_isEmpty_of_nonempty",
  "constType": "∀ (α : Sort u_1) [h : Nonempty α], ¬IsEmpty α",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.id.proof_1",
   "RingHom",
   "RingHom.id.proof_3",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "OneHom.mk",
   "MonoidHom.mk",
   "RingHom.id.proof_4",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.mk",
   "RingHom.id.proof_2",
   "NonAssocSemiring",
   "id"],
  "name": "RingHom.id",
  "constType": "(α : Type u_5) → [inst : NonAssocSemiring α] → α →+* α",
  "constCategory": "Definition"},
 {"references":
  ["cond.match_1",
   "Lean.Name.mkStr",
   "List.cons",
   "Lean.MacroScopesView",
   "Unit",
   "Lean.MacroScopesView.review",
   "Lean.Name.hasMacroScopes",
   "Lean.Name.instBEq",
   "Lean.MacroScopesView.mainModule",
   "Lean.MacroScopesView.name",
   "List.foldl",
   "Lean.MacroScope",
   "BEq.beq",
   "Lean.Name.mkNum",
   "Lean.MacroScopesView.mk",
   "List.nil",
   "Bool",
   "Lean.MacroScopesView.imported",
   "Lean.Name.appendCore",
   "Lean.Name",
   "Lean.extractMacroScopes",
   "Nat",
   "Lean.MacroScopesView.scopes"],
  "name": "Lean.addMacroScope",
  "constType": "Lean.Name → Lean.Name → Lean.MacroScope → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ideal.Quotient.commRing",
   "CommSemiring.toSemiring",
   "RingHom",
   "OfNat.ofNat",
   "Ideal.Quotient.eq_zero_iff_mem",
   "RingHom.instFunLike",
   "SetLike.instMembership",
   "CommRing",
   "Submodule.Quotient.instZeroQuotient",
   "Eq",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "CommRing.toRing",
   "Ring.toAddCommGroup",
   "Ideal.Quotient.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "HasQuotient.Quotient",
   "DFunLike.coe",
   "Ideal",
   "Ideal.instHasQuotient",
   "Submodule.setLike",
   "Semiring.toModule"],
  "name": "FltRegular.NumberTheory.QuotientTrace._auxLemma.1",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] {a : R} {I : Ideal R}, ((Ideal.Quotient.mk I) a = 0) = (a ∈ I)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_10",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_33"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_34._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_12",
   "_obj",
   "String.toSubstring'"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "Function.swap",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "add_ne_add_left",
   "IsRightCancelAdd",
   "CovariantClass",
   "Add",
   "CovariantClass.mk"],
  "name": "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsRightCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references": ["Subtype"],
  "name": "Subtype.val",
  "constType": "{α : Sort u} → {p : α → Prop} → Subtype p → α",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.str"],
  "name": "Lean.Name.mkStr",
  "constType": "Lean.Name → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "AddGroup",
   "Int.instAddCommGroup",
   "AddCommGroup.toAddGroup",
   "Int"],
  "name": "Int.instAddGroup",
  "constType": "AddGroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "MulAction.toSMul",
   "instHSMul",
   "Iff",
   "Iff.rfl",
   "HSMul.hSMul",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "MulAction.stabilizer",
   "DivInvMonoid.toMonoid",
   "MulAction",
   "Subgroup.instSetLike",
   "SetLike.instMembership",
   "Eq"],
  "name": "MulAction.mem_stabilizer_iff",
  "constType":
  "∀ {G : Type u_1} {α : Type u_2} [inst : Group G] [inst_1 : MulAction G α] {a : α} {g : G},\n  g ∈ MulAction.stabilizer G a ↔ g • a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set.instSingletonSet",
   "Submodule",
   "Semiring",
   "Set",
   "Submodule.IsPrincipal.mk",
   "Singleton.singleton",
   "Module",
   "Submodule.IsPrincipal.rec",
   "Submodule.span",
   "Submodule.IsPrincipal",
   "Eq",
   "AddCommMonoid"],
  "name": "Submodule.IsPrincipal.casesOn",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_4} →\n    [inst : Semiring R] →\n      [inst_1 : AddCommMonoid M] →\n        [inst_2 : Module R M] →\n          {S : Submodule R M} →\n            {motive : S.IsPrincipal → Sort u} →\n              (t : S.IsPrincipal) → ((principal' : ∃ a, S = Submodule.span R {a}) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references": ["Inv"],
  "name": "Inv.inv",
  "constType": "{α : Type u} → [self : Inv α] → α → α",
  "constCategory": "Definition"},
 {"references": ["Fintype.finite", "Fintype", "Finite"],
  "name": "Finite.of_fintype",
  "constType": "∀ (α : Type u_4) [inst : Fintype α], Finite α",
  "constCategory": "Definition"},
 {"references":
  ["DivisionMonoid",
   "DivInvOneMonoid",
   "DivInvOneMonoid.mk",
   "DivisionMonoid.toDivInvOneMonoid.proof_1",
   "DivisionMonoid.toDivInvMonoid",
   "DivInvMonoid"],
  "name": "DivisionMonoid.toDivInvOneMonoid",
  "constType": "{α : Type u_1} → [inst : DivisionMonoid α] → DivInvOneMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "SubNegMonoid.toNeg",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Semiring.toNatCast",
   "ite",
   "Finset.instMembership",
   "DecidablePred",
   "Finset.sum_range",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Fin.mk",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "MulOneClass.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "NormedCommRing.toNormedRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Finset.filter_filter",
   "SMulZeroClass.toSMul",
   "Finset.sum_neg_distrib",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "And",
   "Int.instCharZero",
   "False.elim",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "instNatAtLeastTwo",
   "congr",
   "MonoidWithZero.toZero",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "Int.instSemiring",
   "HEq",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "sub_nonpos_of_le",
   "Nat.decLt",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "zero_sub",
   "semigroupDvd",
   "NeZero.pnat",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "CyclotomicField.instField",
   "Int.instAddMonoid",
   "Int.instCommSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "zero_lt_one",
   "FltRegular.CaseI.aux_cong0k₁",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Mathlib.Tactic.Ring.mul_add",
   "Neg.neg",
   "NormedField.toNormedCommRing",
   "instDecidableAnd",
   "LE.le",
   "CommRing.toCommSemiring",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "instNatCastInt",
   "letFun",
   "NegZeroClass.toNeg",
   "Subtype.mk",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "SubtractionCommMonoid.toAddCommMonoid",
   "instHSMul",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "instSubsingletonForall",
   "AddGroup.toSubtractionMonoid",
   "Finset.sum_const_zero",
   "CanonicallyOrderedCommSemiring.toOne",
   "AddCommGroup.intModule",
   "SMulWithZero.toSMulZeroClass",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Ring.toIntCast",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "dvd_coeff_cycl_integer",
   "Eq.trans",
   "NormedRing.toRing",
   "ite_smul",
   "StrictOrderedRing.toPartialOrder",
   "Int.instDvd",
   "neg_neg_of_pos",
   "Finset.instSingleton",
   "Fin.fintype",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "pow_zero",
   "Int.instLTInt",
   "FltRegular.CaseI.f0k₁",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Nat.instOrderedSemiring",
   "SemigroupWithZero.toSemigroup",
   "Mathlib.Tactic.Ring.neg_mul",
   "Finset.univ",
   "MulActionWithZero.toSMulWithZero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "HEq.refl",
   "of_eq_true",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "mul_one",
   "Singleton.singleton",
   "instSubsingletonDecidable",
   "Finset.instEmptyCollection",
   "Int.ofNat",
   "StrictOrderedRing.toRing",
   "LinearOrderedRing.toStrictOrderedRing",
   "Linarith.lt_irrefl",
   "instSubNat",
   "CommRing.toNonUnitalCommRing",
   "Dvd.dvd.mul_right",
   "Mathlib.Tactic.Zify._auxLemma.2",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "instDecidableNot",
   "AddMonoid.toZero",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "AddCommGroup.toAddGroup",
   "ite_cond_eq_true",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "NeZero.charZero_one",
   "instOfNatAtLeastTwo",
   "id",
   "eq_self",
   "Nat.Prime.one_lt",
   "sub_eq_zero_of_eq",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "False",
   "instAddNat",
   "AddMonoidWithOne.toAddMonoid",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "Nat.pred_lt",
   "ite_congr",
   "CommSemigroup.toSemigroup",
   "Nat.sub_lt",
   "StrictOrderedSemiring.toPartialOrder",
   "OrderedCommSemiring.toOrderedSemiring",
   "Nat.instCanonicallyOrderedCommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Eq.casesOn",
   "Bool",
   "NumberField.RingOfIntegers",
   "OrderedSemiring.toPartialOrder",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Finset.range_filter_eq",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "EmptyCollection.emptyCollection",
   "AddCommGroup.toAddCommMonoid",
   "FltRegular.CaseI.auxf0k₁",
   "pow_one",
   "AddGroupWithOne.toAddGroup",
   "Mathlib.Meta.NormNum.isInt_add",
   "Nat.cast_zero",
   "instDecidableEqNat",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.Prime",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "Finset.range",
   "HSMul.hSMul",
   "LinearOrderedCommMonoidWithZero.toZero",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Int.instSub",
   "Linarith.lt_of_lt_of_eq",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "HPow.hPow",
   "zsmul_eq_mul",
   "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.2",
   "eq_of_heq",
   "Int.instRing",
   "Module.toMulActionWithZero",
   "CommMagma.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CyclotomicField",
   "Nat.cast_add",
   "ne_and_eq_iff_right",
   "CommRing.toCommMonoid",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "Nat.zero",
   "LT.lt",
   "Finset.sum_ite",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "Fin",
   "neg_smul",
   "Int.instAddGroup",
   "Nat.instStrictOrderedSemiring",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "AddMonoid.toAddZeroClass",
   "True",
   "Subsingleton.elim",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Int.instCovariantClassAddLE",
   "Eq.rec",
   "Finset",
   "Decidable",
   "Finset.filter",
   "NeZero.charZero",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "covariant_swap_add_of_covariant_add",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instMul",
   "Finset.sum",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "Ne.symm",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instLinearOrderedCommRing",
   "Bool.false",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Rat.instNormedField",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "CyclotomicField.instCharZero",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "AddGroup.intSMulWithZero",
   "sub_eq_add_neg",
   "instLTNat",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Ring.toNeg",
   "Mathlib.Tactic.Zify._auxLemma.1",
   "Nat.Prime.ne_zero",
   "Dvd.dvd.mul_left",
   "Finset.sum_singleton",
   "Nat",
   "Finset.sum_congr",
   "Ne",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.Prime.pos",
   "Fin.val",
   "Int.ModEq",
   "Nat.rawCast",
   "OrderedSemiring.zeroLEOneClass",
   "SubNegMonoid.SMulInt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instAddCommSemigroup",
   "instHMul",
   "NonAssocRing.toIntCast",
   "add_sub_cancel_left",
   "AddCancelMonoid.toIsCancelAdd",
   "Not",
   "add_zero",
   "congrArg",
   "Int.instLEInt",
   "OrderedAddCommGroup.toAddCommGroup",
   "zero_smul",
   "NonAssocRing.toAddCommGroupWithOne",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NumberField.RingOfIntegers.instCommRing",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing",
   "PNat.val",
   "Zero.toOfNat0",
   "instLENat",
   "Nat.pred",
   "Preorder.toLT",
   "instHPow",
   "Ring.toSub",
   "Linarith.mul_neg",
   "Int.instNegInt",
   "add_lt_of_neg_of_le",
   "Eq.symm",
   "NeZero.succ",
   "Rat.instField",
   "funext",
   "CyclotomicField.isCyclotomicExtension",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HSub.hSub",
   "Rat",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Rat.instCharZero",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "CommSemigroup.toCommMagma",
   "OrderedSemiring.toSemiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Int.instCommSemiring",
   "NegZeroClass.toZero",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.3",
   "Nat.pred_eq_succ_iff",
   "Dvd"],
  "name": "FltRegular.CaseI.aux0k₁",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p) {a b c : ℤ} {ζ : NumberField.RingOfIntegers (CyclotomicField ⟨p, ⋯⟩ ℚ)},\n  5 ≤ p →\n    IsPrimitiveRoot ζ p →\n      ¬↑p ∣ a * b * c →\n        ∀ {k₁ k₂ : Fin p}, ↑↑k₂ ≡ ↑↑k₁ - 1 [ZMOD ↑p] → ↑p ∣ ↑a + ↑b * ζ - ↑a * ζ ^ ↑k₁ - ↑b * ζ ^ ↑k₂ → 0 ≠ ↑k₁",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Exists.intro", "rfl", "Eq"],
  "name": "exists_apply_eq_apply",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} (f : α → β) (a' : α), ∃ a, f a = f a'",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_zero_add",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 + b = b",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "instHSub",
   "Finset.instHasSubset",
   "instAddNat",
   "instSubNat",
   "instHAdd",
   "Union.union",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "HasSubset.Subset",
   "Finset.sdiff_disjoint",
   "SDiff.sdiff",
   "Finset.card_union_of_disjoint",
   "Finset.instSDiff",
   "Eq",
   "Eq.mpr",
   "Finset.instUnion",
   "Finset.sdiff_union_of_subset",
   "DecidableEq",
   "Eq.mp",
   "Finset",
   "letFun",
   "Nat",
   "congrArg",
   "Nat.add_sub_cancel_right",
   "id"],
  "name": "Finset.card_sdiff",
  "constType":
  "∀ {α : Type u_1} {s t : Finset α} [inst : DecidableEq α], s ⊆ t → (t \\ s).card = t.card - s.card",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_5",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_4"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Singleton.singleton",
   "Insert.insert",
   "LawfulSingleton",
   "EmptyCollection",
   "Singleton",
   "Insert",
   "Eq"],
  "name": "LawfulSingleton.insert_emptyc_eq",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : EmptyCollection β] [inst_1 : Insert α β] [inst_2 : Singleton α β]\n  [self : LawfulSingleton α β] (x : α), insert x ∅ = {x}",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "DivisionRing.toRing",
   "Field",
   "Field.toDivisionRing",
   "Polynomial.SplittingField",
   "Polynomial.cyclotomic",
   "PNat"],
  "name": "CyclotomicField",
  "constType": "ℕ+ → (K : Type w) → [inst : Field K] → Type w",
  "constCategory": "Definition"},
 {"references": ["trivial", "Decidable", "Decidable.isTrue", "True"],
  "name": "instDecidableTrue",
  "constType": "Decidable True",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedCommSemiring", "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → StrictOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references": ["AddZeroClass"],
  "name": "DistribSMul",
  "constType":
  "Type u_10 → (A : Type u_11) → [inst : AddZeroClass A] → Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references": [],
  "name": "Semiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "Iff",
   "neg_zero",
   "InvolutiveNeg.toNeg",
   "Function.Injective.eq_iff'",
   "neg_injective",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toInvolutiveNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "neg_eq_zero",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, -a = 0 ↔ a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Ideal.map",
   "Submodule",
   "RingHomClass",
   "Submodule.idemSemiring",
   "Ideal.mapHom",
   "Eq.refl",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "Eq",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IdemSemiring.toSemiring",
   "Algebra.id",
   "DFunLike.coe",
   "MonoidWithZeroHom",
   "MonoidWithZeroHom.funLike",
   "Ideal",
   "Semiring.toModule"],
  "name": "Ideal.mapHom_apply",
  "constType":
  "∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : FunLike F R S]\n  [rc : RingHomClass F R S] (f : F) (I : Ideal R), (Ideal.mapHom f) I = Ideal.map f I",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HPow"],
  "name": "HPow.hPow",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HPow α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_16",
   "Lean.ParserDescr.node",
   "_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_14"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_17._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["MonoidWithZeroHom.funLike.proof_1",
   "MonoidWithZeroHom.toZeroHom",
   "FunLike",
   "ZeroHom.toFun",
   "MulZeroOneClass.toZero",
   "MonoidWithZeroHom",
   "DFunLike.mk",
   "MulZeroOneClass"],
  "name": "MonoidWithZeroHom.funLike",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → [inst : MulZeroOneClass α] → [inst_1 : MulZeroOneClass β] → FunLike (α →*₀ β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Option.getD",
   "Lean.Omega.tidyConstraint",
   "Lean.Omega.Coeffs",
   "Lean.Omega.normalize",
   "Eq.refl",
   "Lean.Omega.tidyCoeffs",
   "True",
   "Eq",
   "Lean.Omega.positivizeCoeffs",
   "_private.Init.Omega.Constraint.0.Lean.Omega.tidy?.match_1.splitter",
   "Lean.Omega.normalize_sat",
   "Option.none",
   "Lean.Omega.normalizeCoeffs",
   "Bool.true",
   "Lean.Omega.normalize?",
   "Option.some",
   "Lean.Omega.Constraint",
   "Eq.symm",
   "And.casesOn",
   "Eq.trans",
   "Lean.Omega.positivize?",
   "Option",
   "id",
   "eq_self",
   "Prod.snd",
   "Lean.Omega.positivize_sat",
   "Unit",
   "Lean.Omega.positivize?_eq_some",
   "Prod.fst",
   "Lean.Omega.normalize?_eq_some",
   "And",
   "Eq.ndrec",
   "of_eq_true",
   "Lean.Omega.tidy?.match_1",
   "Prod.mk",
   "Lean.Omega.normalizeConstraint",
   "Prod",
   "Bool",
   "Lean.Omega.Constraint.sat'",
   "congrArg",
   "Lean.Omega.positivizeConstraint"],
  "name": "Lean.Omega.tidy_sat",
  "constType":
  "∀ {s : Lean.Omega.Constraint} {x v : Lean.Omega.Coeffs},\n  s.sat' x v = true → (Lean.Omega.tidyConstraint s x).sat' (Lean.Omega.tidyCoeffs s x) v = true",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "EquivLike",
   "OfNat.ofNat",
   "propext",
   "AddEquivClass",
   "EquivLike.toFunLike",
   "AddEquivClass.map_eq_zero_iff",
   "DFunLike.coe",
   "AddZeroClass",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.11",
  "constType":
  "∀ {F : Type u_1} {M : Type u_12} {N : Type u_13} [inst : AddZeroClass M] [inst_1 : AddZeroClass N]\n  [inst_2 : EquivLike F M N] [inst_3 : AddEquivClass F M N] (h : F) {x : M}, (h x = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Nat",
   "Nat.gcd_assoc",
   "Int",
   "Int.gcd",
   "Eq",
   "Int.natAbs"],
  "name": "Int.gcd_assoc",
  "constType": "∀ (i j k : ℤ), (↑(i.gcd j)).gcd k = i.gcd ↑(j.gcd k)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HSMul"],
  "name": "HSMul.hSMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Name.num._override",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_19"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_20._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Sub"],
  "name": "SubNegMonoid.toSub",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Sub G",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "mul_pow.match_1",
   "HAdd.hAdd",
   "Eq.refl",
   "CommMonoid.toCommSemigroup",
   "Eq",
   "PProd",
   "Eq.mpr",
   "one_mul",
   "instHPow",
   "PUnit",
   "Monoid.toNatPow",
   "instOfNatNat",
   "CommMonoid.toMonoid",
   "Nat",
   "Nat.succ",
   "id",
   "HPow.hPow",
   "Nat.below",
   "Nat.brecOn",
   "instAddNat",
   "MulOneClass.toOne",
   "instHAdd",
   "Unit",
   "One.toOfNat1",
   "pow_succ'",
   "CommMagma.toMul",
   "Monoid.toMulOneClass",
   "pow_zero",
   "instHMul",
   "PProd.fst",
   "Nat.rec",
   "mul_mul_mul_comm",
   "CommMonoid",
   "CommSemigroup.toCommMagma",
   "HMul.hMul",
   "congrArg"],
  "name": "mul_pow",
  "constType":
  "∀ {M : Type u_4} [inst : CommMonoid M] (a b : M) (n : ℕ), (a * b) ^ n = a ^ n * b ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "Exists",
   "OfNat.ofNat",
   "two_mul",
   "HAdd.hAdd",
   "semigroupDvd",
   "True",
   "Eq",
   "iff_self",
   "Semiring.toNatCast",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "instOfNatAtLeastTwo",
   "funext",
   "instHAdd",
   "Semiring",
   "Even",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "instNatAtLeastTwo",
   "NonUnitalSemiring.toSemigroupWithZero",
   "congrArg"],
  "name": "even_iff_two_dvd",
  "constType": "∀ {α : Type u_2} [inst : Semiring α] {a : α}, Even a ↔ 2 ∣ a",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.11",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Finsupp.support_single_subset",
   "Finsupp.single",
   "PartialOrder.toPreorder",
   "Finsupp.instLEFinsupp",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Finsupp.le_iff'",
   "implies_congr",
   "Preorder.toLE",
   "True",
   "iff_self",
   "Finset.instMembership",
   "Eq",
   "Iff",
   "forall_congr",
   "AddMonoid.toZero",
   "Finset",
   "Iff.trans",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "DFunLike.coe",
   "Eq.trans",
   "OrderedAddCommMonoid.toPartialOrder",
   "Membership.mem",
   "Finsupp",
   "Finsupp.instFunLike",
   "Finset.instSingleton",
   "LE.le",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "of_eq_true",
   "CanonicallyOrderedAddCommMonoid",
   "Singleton.singleton",
   "congrArg",
   "Init.PropLemmas._auxLemma.14",
   "Finsupp.single_eq_same",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finsupp.single_le_iff",
  "constType":
  "∀ {ι : Type u_1} {α : Type u_2} [inst : CanonicallyOrderedAddCommMonoid α] {i : ι} {x : α} {f : ι →₀ α},\n  Finsupp.single i x ≤ f ↔ x ≤ f i",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "eq_true",
   "PNat.pos",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "True",
   "Eq",
   "PNat"],
  "name": "FltRegular.NumberTheory.KummersLemma.KummersLemma._auxLemma.4",
  "constType": "∀ (n : ℕ+), (0 < ↑n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Units", "Monoid", "propext", "Units.val", "Units.ext_iff", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.9",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] {a b : αˣ}, (a = b) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["Sub", "Lean.Omega.LinearCombo", "Lean.Omega.LinearCombo.sub", "Sub.mk"],
  "name": "Lean.Omega.LinearCombo.instSub",
  "constType": "Sub Lean.Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Name",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Fin.ext_iff", "Fin.val", "propext", "Nat", "Fin", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert90._auxLemma.1",
  "constType": "∀ {n : ℕ} {a b : Fin n}, (a = b) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CanonicallyLinearOrderedAddCommMonoid.toCanonicallyOrderedAddCommMonoid",
   "Nat.instCanonicallyOrderedCommSemiring.proof_1",
   "Nat.instCanonicallyOrderedCommSemiring.proof_9",
   "Nat.instCanonicallyOrderedCommSemiring.proof_7",
   "Nat.instCanonicallyOrderedCommSemiring.proof_13",
   "CanonicallyOrderedCommSemiring",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "Nat.instCanonicallyOrderedCommSemiring.proof_14",
   "Nat.instCanonicallyOrderedCommSemiring.proof_10",
   "Nat.instCanonicallyOrderedCommSemiring.proof_2",
   "Nat.instCanonicallyOrderedCommSemiring.proof_11",
   "Semiring.toNatCast",
   "Nat.eq_zero_of_mul_eq_zero",
   "Nat.instCanonicallyOrderedCommSemiring.proof_5",
   "Semiring.npow",
   "Nat.instCanonicallyLinearOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.mk",
   "Nat",
   "Nat.instCanonicallyOrderedCommSemiring.proof_3",
   "CanonicallyOrderedCommSemiring.mk",
   "Nat.le_add_right",
   "CanonicallyOrderedAddCommMonoid.toOrderBot",
   "OrderedAddCommMonoid.mk",
   "Nat.instCanonicallyOrderedCommSemiring.proof_12",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Nat.instCanonicallyOrderedCommSemiring.proof_8",
   "StrictOrderedSemiring.toSemiring",
   "LinearOrderedCommSemiring",
   "Semiring.toOne",
   "Nat.instLinearOrderedCommSemiring",
   "Nat.instCanonicallyOrderedCommSemiring.proof_6",
   "StrictOrderedSemiring.toPartialOrder",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.instCanonicallyOrderedCommSemiring.proof_4"],
  "name": "Nat.instCanonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "NoZeroDivisors",
   "instHMul",
   "mul_eq_zero",
   "Or",
   "OfNat.ofNat",
   "propext",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.17",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, (a * b = 0) = (a = 0 ∨ b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Eq.mpr",
   "Lean.Omega.Coeffs.dot",
   "Bool.true",
   "Lean.Omega.Constraint.combine_sat",
   "Lean.Omega.Constraint.combine",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.Coeffs",
   "And.intro",
   "Bool",
   "Lean.Omega.Constraint.sat'",
   "Lean.Omega.Constraint",
   "Eq"],
  "name": "Lean.Omega.Constraint.combine_sat'",
  "constType":
  "∀ {s t : Lean.Omega.Constraint} {x y : Lean.Omega.Coeffs},\n  s.sat' x y = true → t.sat' x y = true → (s.combine t).sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "MulOneClass",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "MonoidHom",
   "DivInvMonoid.toMonoid",
   "MonoidHom.mem_ker",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "MonoidHom.ker",
   "Eq",
   "propext",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "MonoidHom.instFunLike",
   "DFunLike.coe",
   "Subgroup.instSetLike"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.6",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] {M : Type u_7} [inst_1 : MulOneClass M] (f : G →* M) {x : G}, (x ∈ f.ker) = (f x = 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Nat.zero",
   "Nat.pred",
   "LT.lt",
   "Nat.le_refl",
   "instOfNatNat",
   "Nat.lt_succ_of_le",
   "Nat",
   "Nat.succ",
   "rfl",
   "absurd",
   "instLTNat",
   "Eq",
   "Nat.pred_lt.match_1"],
  "name": "Nat.pred_lt",
  "constType": "∀ {n : ℕ}, n ≠ 0 → n.pred < n",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "PartialOrder.toPreorder",
   "Int.instDecidableEq",
   "Finset.instInsert",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "Int.instNormedCommRing",
   "FltRegular.MayAssume.Lemmas._auxLemma.1",
   "MulZeroClass.mul_zero",
   "Exists.casesOn",
   "Insert.insert",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "Int.instAdd",
   "Eq",
   "Finset.instMembership",
   "Finset.image_id",
   "mul_pow",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Eq.mpr",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "Finset.gcd_eq_gcd_image",
   "true_or",
   "Int.instDiv",
   "HDiv.hDiv",
   "Nat",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Eq.trans",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "Ne",
   "Int.instDistrib",
   "instHDiv",
   "Or",
   "pow_eq_zero",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Int.instHPowNat",
   "Int.instDvd",
   "Finset.instSingleton",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "or_true",
   "Or.casesOn",
   "Finset.gcd_div_id_eq_one",
   "CommMagma.toMul",
   "mul_left_inj'",
   "MulZeroOneClass.toMulZeroClass",
   "Finset.image_singleton",
   "MonoidWithZero.toMulZeroOneClass",
   "And",
   "instHMul",
   "False.elim",
   "of_eq_true",
   "propext",
   "Eq.mp",
   "Int.instCommMonoid",
   "congr",
   "Singleton.singleton",
   "Not",
   "And.intro",
   "CancelMonoidWithZero.toMonoidWithZero",
   "congrArg",
   "Int",
   "Finset.gcd_eq_zero_iff",
   "LinearOrderedSemiring.noZeroDivisors",
   "CommMonoidWithZero.toZero",
   "Int.instAddGroup",
   "Int.instSemiring",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Mathlib.Data.Finset.Basic._auxLemma.64",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.zero_mul",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "Finset.gcd",
   "rfl",
   "True",
   "add_mul",
   "mul_comm",
   "Zero.toOfNat0",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "instHPow",
   "Finset.image",
   "Finset",
   "Monoid.toNatPow",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "MulZeroClass.toZero",
   "CommMonoid.toMonoid",
   "LinearOrderedRing.isDomain",
   "Eq.symm",
   "Int.eq_zero_of_ediv_eq_zero",
   "Int.instMulDivCancelClass",
   "CommMonoidWithZero.toMonoidWithZero",
   "id",
   "eq_self",
   "Membership.mem",
   "Int.mul_ediv_cancel_left",
   "funext",
   "False",
   "instHAdd",
   "Int.instMul",
   "Int.instNormalizedGCDMonoid",
   "IsDomain.toCancelMonoidWithZero",
   "AddGroup.existsAddOfLE",
   "Finset.image_insert",
   "One.toOfNat1",
   "Dvd.dvd",
   "Monoid.toMulOneClass",
   "Int.instCancelCommMonoidWithZero",
   "NormedCommRing.toSeminormedCommRing",
   "Int.instLinearOrderedCommRing",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "eq_false",
   "StrictOrderedSemiring.toPartialOrder",
   "letFun",
   "HMul.hMul",
   "Finset.gcd_dvd",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "not_true_eq_false"],
  "name": "FltRegular.MayAssume.coprime",
  "constType":
  "∀ {a b c : ℤ} {n : ℕ},\n  a ^ n + b ^ n = c ^ n →\n    a * b * c ≠ 0 →\n      let d := {a, b, c}.gcd id;\n      (a / d) ^ n + (b / d) ^ n = (c / d) ^ n ∧ {a / d, b / d, c / d}.gcd id = 1 ∧ a / d * (b / d) * (c / d) ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "algebraRat",
   "MulZeroClass.toMul",
   "Finset.instMembership",
   "Eq",
   "exists_ideal_pow_eq_c",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "Nat",
   "Subtype",
   "HPow.hPow",
   "instHSub",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Exists.choose_spec",
   "root_div_zeta_sub_one_dvd_gcd",
   "NumberField.to_charZero",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NumberField.RingOfIntegers.instIsDomain",
   "Field.toEuclideanDomain",
   "NumberField.inst_ringOfIntegersAlgebra",
   "NumberField",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Algebra.id",
   "Fact",
   "Field.toDivisionRing",
   "Ideal",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "div_zeta_sub_one_dvd_gcd",
   "Submodule.idemSemiring",
   "PNat.Prime",
   "Set",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "semigroupDvd",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instHPow",
   "Finset",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Eq.symm",
   "NeZero.succ",
   "Membership.mem",
   "instAddNat",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Dvd.dvd",
   "Ring.toSemiring",
   "Polynomial.nthRootsFinset",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "Exists.choose",
   "Units.val",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IdemSemiring.toSemiring",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "root_div_zeta_sub_one_dvd_gcd_spec",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [hpri : Fact p.Prime] [inst : Field K] [inst_1 : NumberField K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K] (hp : p ≠ 2) {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p)\n  {x y z : NumberField.RingOfIntegers K} {ε : (NumberField.RingOfIntegers K)ˣ} {m : ℕ}\n  (e : x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p) (hy : ¬↑hζ.unit' - 1 ∣ y)\n  (η : { x // x ∈ Polynomial.nthRootsFinset (↑p) (NumberField.RingOfIntegers K) }),\n  root_div_zeta_sub_one_dvd_gcd hp hζ e hy η ^ ↑p = div_zeta_sub_one_dvd_gcd hp hζ e hy η",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Nat.Prime.two_le",
   "instLTNat"],
  "name": "Nat.Prime.one_lt",
  "constType": "∀ {p : ℕ}, Nat.Prime p → 1 < p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "id",
  "constType": "{α : Sort u} → α → α",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_15",
   "Lean.ParserDescr.symbol"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_16._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulHomClass",
   "FunLike",
   "map_mul",
   "HMul.hMul",
   "DFunLike.coe",
   "Mul",
   "Eq.symm",
   "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.17",
  "constType":
  "∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Mul M] [inst_1 : Mul N] [inst_2 : FunLike F M N]\n  [inst_3 : MulHomClass F M N] (f : F) (x y : M), f x * f y = f (x * y)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Finset.instSingleton",
   "Singleton.singleton",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.CaseI.Statement._auxLemma.2",
  "constType": "∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "AlgEquiv",
   "Semiring",
   "AlgEquiv.map_mul'",
   "NonUnitalNonAssocSemiring.toMul",
   "MulEquivClass.mk",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "AlgEquivClass.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "AlgEquiv.map_add'",
   "RingEquivClass.mk",
   "AlgEquiv.commutes'",
   "AlgEquiv.instEquivLike",
   "AlgEquivClass"],
  "name": "AlgEquiv.instAlgEquivClass",
  "constType":
  "∀ {R : Type uR} {A₁ : Type uA₁} {A₂ : Type uA₂} [inst : CommSemiring R] [inst_1 : Semiring A₁] [inst_2 : Semiring A₂]\n  [inst_3 : Algebra R A₁] [inst_4 : Algebra R A₂], AlgEquivClass (A₁ ≃ₐ[R] A₂) R A₁ A₂",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Name.num._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_13"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Ne",
   "Fin.exists_succAbove_eq",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Fin.succAbove_ne",
   "Exists.casesOn",
   "Eq",
   "Iff.intro",
   "Eq.ndrec",
   "Iff",
   "instOfNatNat",
   "Nat",
   "Fin",
   "Fin.succAbove"],
  "name": "Fin.exists_succAbove_eq_iff",
  "constType":
  "∀ {n : ℕ} {x y : Fin (n + 1)}, (∃ z, x.succAbove z = y) ↔ y ≠ x",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_12",
   "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_6",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Or",
   "Finset.instInsert",
   "DecidableEq",
   "propext",
   "Finset",
   "Insert.insert",
   "Finset.mem_insert",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.CaseI.Statement._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, (a ∈ insert b s) = (a = b ∨ a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "PNat.ne_zero",
   "instOfNatNat",
   "Nat",
   "Eq",
   "PNat"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.13",
  "constType": "∀ (n : ℕ+), (↑n = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_8",
   "Lean.ParserDescr.node",
   "_obj",
   "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_10"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["True.intro", "forall_true_left", "propext", "True", "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.12",
  "constType": "∀ (p : True → Prop), (∀ (x : True), p x) = p True.intro",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "RingHom.comp.proof_4",
   "NonUnitalRingHom",
   "MulZeroOneClass.toMulOneClass",
   "RingHom.comp.proof_3",
   "MulOneClass.toOne",
   "Function.comp",
   "RingHom.comp.proof_1",
   "RingHom.toNonUnitalRingHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.mk",
   "RingHom.instFunLike",
   "NonAssocSemiring",
   "RingHom.comp.proof_2",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OneHom.mk",
   "MonoidHom.mk",
   "DFunLike.coe",
   "NonUnitalRingHom.comp"],
  "name": "RingHom.comp",
  "constType":
  "{α : Type u_2} →\n  {β : Type u_3} →\n    {γ : Type u_4} →\n      {x : NonAssocSemiring α} →\n        {x_1 : NonAssocSemiring β} → {x_2 : NonAssocSemiring γ} → (β →+* γ) → (α →+* β) → α →+* γ",
  "constCategory": "Definition"},
 {"references": ["Nat.sub", "Sub", "Nat", "Sub.mk"],
  "name": "instSubNat",
  "constType": "Sub ℕ",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_5",
   "Lean.Name.str._override",
   "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_2"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termR_1._closed_2",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termR_1._closed_1"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termR_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "sub_self",
   "HSub.hSub",
   "eq_of_sub_eq_zero",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Iff.intro",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "NegZeroClass.toZero",
   "congrArg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_eq_zero",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a - b = 0 ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.le_succ_of_le",
   "OfNat.ofNat",
   "instLENat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.le_refl",
   "Nat.leRec",
   "instOfNatNat",
   "Nat",
   "LE.le"],
  "name": "Nat.le_induction",
  "constType":
  "∀ {m : ℕ} {P : (n : ℕ) → m ≤ n → Prop},\n  P m ⋯ → (∀ (n : ℕ) (hmn : m ≤ n), P n hmn → P (n + 1) ⋯) → ∀ (n : ℕ) (hmn : m ≤ n), P n hmn",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "Eq.rec", "Eq.symm", "rfl", "Eq"],
  "name": "forall_eq",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a = a' → p a) ↔ p a'",
  "constCategory": "Theorem"},
 {"references": ["propext", "GE.ge", "ge_iff_le", "LE", "LE.le", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.2",
  "constType": "∀ {α : Type u} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "of_decide_eq_true",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "Nat.cast_add",
   "instDecidableEqNat",
   "Eq",
   "AddMonoidWithOne",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "Bool.true",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Nat.cast_one",
   "id",
   "instOfNatAtLeastTwo"],
  "name": "one_add_one_eq_two",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], 1 + 1 = 2",
  "constCategory": "Theorem"},
 {"references":
  ["List.mem_finRange",
   "Fintype",
   "Fintype.mk",
   "List.finRange",
   "List.nodup_finRange",
   "Multiset.ofList",
   "Finset.mk",
   "Nat",
   "Fin"],
  "name": "Fin.fintype",
  "constType": "(n : ℕ) → Fintype (Fin n)",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Nat.instCommSemiring",
   "Semiring",
   "Nat"],
  "name": "Nat.instSemiring",
  "constType": "Semiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Fintype",
   "Set.instSingletonSet",
   "Set.Elem",
   "Set",
   "Finset",
   "Finset.instSingleton",
   "Singleton.singleton",
   "Fintype.ofFinset",
   "Set.fintypeSingleton.proof_1"],
  "name": "Set.fintypeSingleton",
  "constType": "{α : Type u} → (a : α) → Fintype ↑{a}",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "OrderedAddCommGroup",
   "OfNat.ofNat",
   "IsCancelAdd.toIsLeftCancelAdd",
   "PartialOrder.toPreorder",
   "OrderedAddCommGroup.toPartialOrder",
   "neg_neg_iff_pos",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Iff.mpr",
   "Zero.toOfNat0",
   "AddCancelMonoid.toIsCancelAdd",
   "Preorder.toLT",
   "LT.lt",
   "AddGroup.toAddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "OrderedAddCommGroup.toAddCommGroup"],
  "name": "neg_neg_of_pos",
  "constType":
  "∀ {α : Type u} [inst : OrderedAddCommGroup α] {a : α}, 0 < a → -a < 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "Finsupp",
   "FunLike",
   "Finsupp.instFunLike.proof_1",
   "Finsupp.toFun",
   "DFunLike.mk"],
  "name": "Finsupp.instFunLike",
  "constType":
  "{α : Type u_1} → {M : Type u_5} → [inst : Zero M] → FunLike (α →₀ M) α M",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "Ne",
   "OfNat.ofNat",
   "Or",
   "Dvd.dvd",
   "semigroupDvd",
   "CommMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Zero.toOfNat0",
   "SemigroupWithZero.toSemigroup",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Prime",
   "And.right",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "HMul.hMul",
   "Not",
   "IsUnit",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "Prime.dvd_or_dvd",
  "constType":
  "∀ {α : Type u_1} [inst : CommMonoidWithZero α] {p : α}, Prime p → ∀ {a b : α}, p ∣ a * b → p ∣ a ∨ p ∣ b",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_43._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Units.instOne",
   "Nat.units_eq_one",
   "Eq.refl",
   "One.toOfNat1",
   "Exists.intro",
   "Exists.casesOn",
   "rfl",
   "Eq",
   "Iff.intro",
   "Units",
   "Iff",
   "Eq.ndrec",
   "Nat.instMonoid",
   "Units.val",
   "Eq.rec",
   "instOfNatNat",
   "IsUnit",
   "Nat",
   "Eq.symm"],
  "name": "Nat.isUnit_iff",
  "constType": "∀ {n : ℕ}, IsUnit n ↔ n = 1",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Exists",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "LE.le",
   "Iff.mpr",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "le_iff_exists_add",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Eq.symm",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "zero_le",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] (a : α), 0 ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Name.num._override",
   "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_7"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Part.Dom", "Part"],
  "name": "Part.get",
  "constType": "{α : Type u} → (self : Part α) → self.Dom → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "UInt8",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "IdemCommSemiring",
   "CommSemiring",
   "Submodule.instIdemCommSemiring",
   "Algebra.id",
   "Ideal"],
  "name": "Ideal.instIdemCommSemiring",
  "constType":
  "{R : Type u} → [inst : CommSemiring R] → IdemCommSemiring (Ideal R)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.not_prime_one",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "OfNat.ofNat",
   "Nat.Prime",
   "False.elim",
   "instLENat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.instCanonicallyOrderedCommSemiring",
   "le_add_self",
   "instOfNatNat",
   "Nat",
   "Nat.not_prime_zero",
   "LE.le",
   "Nat.Prime.two_le.match_1"],
  "name": "Nat.Prime.two_le",
  "constType": "∀ {p : ℕ}, Nat.Prime p → 2 ≤ p",
  "constCategory": "Theorem"},
 {"references":
  ["GCDMonoid", "NormalizedGCDMonoid", "CancelCommMonoidWithZero"],
  "name": "NormalizedGCDMonoid.toGCDMonoid",
  "constType":
  "{α : Type u_2} → [inst : CancelCommMonoidWithZero α] → [self : NormalizedGCDMonoid α] → GCDMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "eq_false",
   "Nat.AtLeastTwo",
   "False",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "CharZero",
   "OfNat.ofNat_ne_one",
   "One.toOfNat1",
   "Nat",
   "instOfNatAtLeastTwo",
   "Eq"],
  "name": "FltRegular.CaseI.AuxLemmas._auxLemma.2",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] (n : ℕ) [inst_2 : n.AtLeastTwo],\n  (OfNat.ofNat n = 1) = False",
  "constCategory": "Theorem"},
 {"references": ["CommSemiring", "Semifield"],
  "name": "Semifield.toCommSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMonoid.mk",
   "SubtractionCommMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "SubtractionCommMonoid.add_comm",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddCommMonoid"],
  "name": "SubtractionCommMonoid.toAddCommMonoid",
  "constType":
  "{G : Type u} → [self : SubtractionCommMonoid G] → AddCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Eq.refl",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.mul_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' * b' = c → a * b = c",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "Nat.prime_iff_prime_int",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Int.instDecidableEq",
   "Finset.instInsert",
   "HAdd.hAdd",
   "Int.instNormedCommRing",
   "NormalizedGCDMonoid.toNormalizationMonoid",
   "IsRegularPrime",
   "NonUnitalNormedRing.toNonUnitalRing",
   "NormalizedGCDMonoid.toGCDMonoid",
   "Exists.casesOn",
   "Insert.insert",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "MulZeroClass.toMul",
   "Int.instAdd",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Nat.Prime",
   "Iff.mp",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "isUnit_iff_dvd_one",
   "Nat.Prime.ne_zero",
   "FltRegular.not_exists_Int_solution",
   "MonoidWithZeroHom",
   "Nat",
   "And.casesOn",
   "MonoidWithZeroHom.funLike",
   "Eq.trans",
   "instOfNat",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "HPow.hPow",
   "instHSub",
   "Ne",
   "Int.instHPowNat",
   "Int.instDvd",
   "Mathlib.Algebra.Divisibility.Units._auxLemma.2",
   "Finset.instSingleton",
   "MulZeroOneClass.toMulZeroClass",
   "dvd_pow",
   "SemigroupWithZero.toSemigroup",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "And",
   "eq_true",
   "Prime",
   "of_eq_true",
   "propext",
   "NormedCommRing.toNonUnitalNormedCommRing",
   "Eq.mp",
   "NonUnitalNormedCommRing.toNonUnitalNormedRing",
   "congr",
   "Int.instCommMonoid",
   "Singleton.singleton",
   "Not",
   "Finset.gcd_singleton",
   "And.intro",
   "congrArg",
   "Fact",
   "Int",
   "AddZeroClass.toAdd",
   "Exists",
   "NonUnitalRing.toNonUnitalSemiring",
   "Mathlib.Algebra.Group.Units._auxLemma.29",
   "Int.instAddGroup",
   "Prime.dvd_of_dvd_pow",
   "FltRegular.CaseII.Statement._auxLemma.3",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Fact.out",
   "normalize",
   "Exists.intro",
   "semigroupDvd",
   "AddMonoid.toAddZeroClass",
   "Finset.gcd",
   "True",
   "GCDMonoid.gcd",
   "NormalizationMonoid.normUnit",
   "instHPow",
   "Finset",
   "Monoid.toNatPow",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "DFunLike.coe",
   "CommMonoid.toMonoid",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "dvd_sub",
   "id",
   "CommMonoidWithZero.toMonoidWithZero",
   "Monoid.toSemigroup",
   "False",
   "instHAdd",
   "Int.instNormalizedGCDMonoid",
   "HSub.hSub",
   "One.toOfNat1",
   "Dvd.dvd",
   "Int.instMonoid",
   "Monoid.toMulOneClass",
   "Int.instCancelCommMonoidWithZero",
   "AddGroup.toSubNegMonoid",
   "Prime.not_unit",
   "instNatCastInt",
   "Units.val",
   "Finset.gcd_insert",
   "SubNegMonoid.toAddMonoid",
   "letFun",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IsUnit",
   "Int.instCommSemiring",
   "and_self",
   "add_sub_cancel_right"],
  "name": "FltRegular.not_exists_Int_solution'",
  "constType":
  "∀ {p : ℕ} [hpri : Fact (Nat.Prime p)],\n  IsRegularPrime p → p ≠ 2 → ¬∃ x y z, {x, y, z}.gcd id = 1 ∧ ↑p ∣ z ∧ z ≠ 0 ∧ x ^ p + y ^ p = z ^ p",
  "constCategory": "Theorem"},
 {"references": ["Zero", "Finsupp", "Finset"],
  "name": "Finsupp.support",
  "constType":
  "{α : Type u_13} → {M : Type u_14} → [inst : Zero M] → (α →₀ M) → Finset α",
  "constCategory": "Definition"},
 {"references": ["propext", "GE.ge", "ge_iff_le", "LE", "LE.le", "Eq"],
  "name": "FltRegular.NumberTheory.KummersLemma.KummersLemma._auxLemma.1",
  "constType": "∀ {α : Type u} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["IdemCommSemiring", "CommSemiring"],
  "name": "IdemCommSemiring.toCommSemiring",
  "constType": "{α : Type u} → [self : IdemCommSemiring α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "dite",
   "ClassGroup.mk0",
   "ClassGroup",
   "SetLike.instMembership",
   "Eq",
   "nonZeroDivisors",
   "SubmonoidClass.mk_pow",
   "Nat.dvd_one",
   "Eq.mpr",
   "Fintype",
   "Nat.Prime",
   "Semiring.toNonAssocSemiring",
   "IsDomain.to_noZeroDivisors",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "Nat.instDvd",
   "orderOf_dvd_card",
   "Nat",
   "Subtype",
   "pow_mem",
   "HPow.hPow",
   "Classical.propDecidable",
   "MonoidHom",
   "IsDedekindDomain.toIsDomain",
   "IsDedekindDomain",
   "And",
   "ClassGroup.mk0_eq_one_iff",
   "MonoidWithZero.toMulZeroOneClass",
   "mem_nonZeroDivisors_of_ne_zero",
   "Submonoid.instSubmonoidClass",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "DivInvOneMonoid.toInvOneClass",
   "Eq.mp",
   "CommRing.toRing",
   "Nat.gcd",
   "Not",
   "And.intro",
   "MonoidHom.instFunLike",
   "Algebra.id",
   "SubmonoidClass.nPow",
   "Fact",
   "congrArg",
   "DivisionMonoid.toDivInvOneMonoid",
   "Ideal",
   "CommGroup.toDivisionCommMonoid",
   "Nat.dvd_gcd_iff",
   "Submodule.idemSemiring",
   "Semiring.toMonoidWithZero",
   "instCommGroupClassGroup",
   "Ideal.instNoZeroDivisors",
   "CommRing",
   "Zero.toOfNat0",
   "map_pow",
   "instHPow",
   "MonoidHom.instMonoidHomClass",
   "Monoid.toNatPow",
   "instOfNatNat",
   "orderOf",
   "DFunLike.coe",
   "Eq.symm",
   "orderOf_dvd_iff_pow_eq_one",
   "Submodule.IsPrincipal",
   "Submonoid.instSetLike",
   "Semiring.toModule",
   "Submonoid.toMonoid",
   "id",
   "Submonoid.toMulOneClass",
   "Membership.mem",
   "CommGroup.toGroup",
   "bot_isPrincipal",
   "Dvd.dvd",
   "Fintype.card",
   "One.toOfNat1",
   "Submodule.pointwiseZero",
   "DivInvMonoid.toMonoid",
   "orderOf_eq_one_iff",
   "Monoid.toMulOneClass",
   "pow_ne_zero",
   "CommRing.toCommSemiring",
   "InvOneClass.toOne",
   "Nat.Coprime",
   "Submonoid",
   "Ring.toAddCommGroup",
   "IdemSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Group.toDivInvMonoid",
   "Subtype.mk"],
  "name": "IsPrincipal_of_IsPrincipal_pow_of_Coprime",
  "constType":
  "∀ (A : Type u_1) [inst : CommRing A] [inst_1 : IsDedekindDomain A] [inst_2 : Fintype (ClassGroup A)] (p : ℕ)\n  [inst_3 : Fact (Nat.Prime p)],\n  p.Coprime (Fintype.card (ClassGroup A)) → ∀ (I : Ideal A), Submodule.IsPrincipal (I ^ p) → Submodule.IsPrincipal I",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "a_eta_zero_dvd_p_pow",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "Ideal.span",
   "algebraRat",
   "MulZeroClass.toMul",
   "Eq",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "Nat",
   "HPow.hPow",
   "instHSub",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Exists.choose_spec",
   "root_div_zeta_sub_one_dvd_gcd",
   "NumberField.to_charZero",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Field.toEuclideanDomain",
   "NumberField.inst_ringOfIntegersAlgebra",
   "NumberField",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Algebra.id",
   "Fact",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ideal",
   "Submodule.idemSemiring",
   "PNat.Prime",
   "Set",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "semigroupDvd",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instHPow",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "zeta_sub_one_dvd_root",
   "Eq.symm",
   "p_pow_dvd_a_eta_zero",
   "NeZero.succ",
   "instAddNat",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Dvd.dvd",
   "Ring.toSemiring",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "Exists.choose",
   "Units.val",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IdemSemiring.toSemiring",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "a_eta_zero_dvd_p_pow_spec",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [hpri : Fact p.Prime] [inst : Field K] [inst_1 : NumberField K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K] (hp : p ≠ 2) {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p)\n  {x y z : NumberField.RingOfIntegers K} {ε : (NumberField.RingOfIntegers K)ˣ} {m : ℕ}\n  (e : x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p) (hy : ¬↑hζ.unit' - 1 ∣ y),\n  Ideal.span {↑hζ.unit' - 1} ^ m * a_eta_zero_dvd_p_pow hp hζ e hy =\n    root_div_zeta_sub_one_dvd_gcd hp hζ e hy (zeta_sub_one_dvd_root hp hζ e hy)",
  "constCategory": "Theorem"},
 {"references": ["Sup"],
  "name": "Sup.sup",
  "constType": "{α : Type u_1} → [self : Sup α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Iff",
   "Preorder.toLT",
   "LT.lt",
   "Finset",
   "LocallyFiniteOrder",
   "Preorder",
   "Finset.Ioo",
   "Finset.instMembership",
   "LocallyFiniteOrder.finset_mem_Ioo"],
  "name": "Finset.mem_Ioo",
  "constType":
  "∀ {α : Type u_1} [inst : Preorder α] [inst_1 : LocallyFiniteOrder α] {a b x : α}, x ∈ Finset.Ioo a b ↔ a < x ∧ x < b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedCommMonoid.toOrderedCommMonoid",
   "PartialOrder.toPreorder",
   "propext",
   "LinearOrderedCommMonoidWithZero.toZero",
   "OrderedCommMonoid.toPartialOrder",
   "LinearOrderedCommMonoidWithZero",
   "le_zero_iff",
   "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedCommMonoidWithZero α] {a : α}, (a ≤ 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "Set",
   "Ideal.dvd_span_singleton",
   "Dvd.dvd",
   "semigroupDvd",
   "CommSemiring.toNonUnitalCommSemiring",
   "Ideal.span",
   "SetLike.instMembership",
   "CommRing",
   "Ideal.instIdemCommSemiring",
   "Eq",
   "IsDedekindDomain",
   "SemigroupWithZero.toSemigroup",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Set.instSingletonSet",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Ideal",
   "Semiring.toModule",
   "Submodule.setLike",
   "IdemCommSemiring.toCommSemiring"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.5",
  "constType":
  "∀ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDedekindDomain A] {I : Ideal A} {x : A}, (I ∣ Ideal.span {x}) = (x ∈ I)",
  "constCategory": "Theorem"},
 {"references":
  ["NormedRing.toNorm",
   "NormedCommRing.toSeminormedCommRing.proof_2",
   "NormedCommRing",
   "MetricSpace.toPseudoMetricSpace",
   "NormedCommRing.toNormedRing",
   "NormedRing.toMetricSpace",
   "SeminormedCommRing",
   "NormedCommRing.mul_comm",
   "NormedCommRing.toSeminormedCommRing.proof_1",
   "SeminormedRing.mk",
   "NormedRing.toRing",
   "SeminormedCommRing.mk"],
  "name": "NormedCommRing.toSeminormedCommRing",
  "constType": "{α : Type u_1} → [β : NormedCommRing α] → SeminormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "DecidableEq",
   "propext",
   "Multiset.count",
   "Multiset",
   "instOfNatNat",
   "Multiset.Nodup",
   "Nat",
   "Multiset.nodup_iff_count_eq_one",
   "Eq",
   "Multiset.instMembership"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.7",
  "constType":
  "∀ {α : Type u_1} {s : Multiset α} [inst : DecidableEq α], s.Nodup = ∀ a ∈ s, Multiset.count a s = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid",
   "Monoid.toOne",
   "MulOneClass",
   "Monoid.one_mul",
   "Monoid.mul_one",
   "MulOneClass.mk"],
  "name": "Monoid.toMulOneClass",
  "constType": "{M : Type u} → [self : Monoid M] → MulOneClass M",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "LE.le",
  "constType": "{α : Type u} → [self : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "Nat.prime_iff_prime_int",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "IsPrimitiveRoot",
   "instPNatDecidableEq",
   "Int.instNormedCommRing",
   "dite",
   "algebraRat",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Nat.Prime",
   "AddCommGroup.intModule",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Ring.toNeg",
   "Iff",
   "Nat.cast",
   "norm_Int_zeta_sub_one",
   "Set.Elem",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "Ring.toIntCast",
   "HasDistribNeg.toInvolutiveNeg",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "Module.IsNoetherian.finite",
   "NumberField.RingOfIntegers.instIsDedekindDomain",
   "instOfNatPNatOfNeZeroNat",
   "Set.fintypeSingleton",
   "Int.instDvd",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "prime_neg_iff",
   "NumberField.RingOfIntegers.instNontrivial",
   "MonoidHom",
   "EuclideanDomain.toCommRing",
   "NumberField.RingOfIntegers.instIsNoetherianInt",
   "SemigroupWithZero.toSemigroup",
   "CommRing.toCommMonoid",
   "Prime",
   "NumberField.RingOfIntegers.instFreeInt",
   "NumberField.RingOfIntegers.instIsDomain",
   "propext",
   "Field.toEuclideanDomain",
   "Int.cast",
   "CommRing.toRing",
   "Not",
   "Singleton.singleton",
   "MonoidHom.instFunLike",
   "congrArg",
   "Fact",
   "Field.toDivisionRing",
   "Finite.of_fintype",
   "Int",
   "Int.instSemigroup",
   "Int.instSemiring",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "IsCyclotomicExtension.numberField",
   "DivisionRing.toRing",
   "Iff.rfl",
   "CommRing.toNonUnitalCommRing",
   "PNat.Prime",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "Fact.out",
   "semigroupDvd",
   "algebraInt",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "Algebra.norm",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "InvolutiveNeg.toNeg",
   "Ideal.norm_dvd_iff",
   "Ring.toSub",
   "Int.instNegInt",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "DFunLike.coe",
   "Eq.symm",
   "Rat.numberField",
   "id",
   "NeZero.succ",
   "Rat.instField",
   "AddGroupWithOne.toAddMonoidWithOne",
   "neg_dvd",
   "Ring.toAddGroupWithOne",
   "Rat",
   "HSub.hSub",
   "Dvd.dvd",
   "One.toOfNat1",
   "Neg.neg",
   "norm_Int_zeta_sub_one'",
   "Ring.toSemiring",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "NormedCommRing.toSeminormedCommRing",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "CharZero",
   "instNatCastInt",
   "Units.val",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Ring.toAddCommGroup",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Int.instCommSemiring",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "zeta_sub_one_dvd_Int_iff",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [hpri : Fact p.Prime] [inst : Field K] [inst_1 : CharZero K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p) {n : ℤ}, ↑hζ.unit' - 1 ∣ ↑n ↔ ↑↑p ∣ n",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.toSet",
   "Set",
   "Finset",
   "Set.instMembership",
   "Finset.mem_coe",
   "Eq.symm",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.5",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ s) = (a ∈ ↑s)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "eq_false",
   "OfNat.ofNat",
   "NeZero",
   "False",
   "One",
   "one_ne_zero",
   "One.toOfNat1",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.25",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], (1 = 0) = False",
  "constCategory": "Theorem"},
 {"references": ["Top"],
  "name": "Top.top",
  "constType": "{α : Type u_1} → [self : Top α] → α",
  "constCategory": "Definition"},
 {"references":
  ["Int.cast_one",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "ite_cond_eq_false",
   "Fin.ext",
   "instLTNat",
   "ZMod.val_cast_of_lt",
   "ZMod.instField",
   "Semiring.toNatCast",
   "Eq",
   "ite",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.Prime",
   "NeZero.mk",
   "Nat.cast",
   "Ring.toNeg",
   "Int.cast_neg",
   "Ring.toIntCast",
   "ZMod.decidableEq",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat.Prime.ne_zero",
   "Nat",
   "instOfNat",
   "Eq.trans",
   "ZMod.nontrivial",
   "Fin.mk",
   "instHSub",
   "Fin.val",
   "Int.ModEq",
   "ZMod",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "Int.cast",
   "propext",
   "LT.lt",
   "Eq.mp",
   "CommRing.toRing",
   "congrArg",
   "Int",
   "Fin",
   "CommMonoidWithZero.toZero",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "instSubNat",
   "AddGroupWithOne.toIntCast",
   "NeZero.one",
   "Fin.is_lt",
   "ZMod.neg_val",
   "NonAssocSemiring.toMulZeroOneClass",
   "ZMod.val_natCast",
   "True",
   "Zero.toOfNat0",
   "AddMonoidWithOne.toNatCast",
   "Nat.pred",
   "ZMod.val",
   "Int.instNegInt",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "Fin.isLt",
   "id",
   "eq_self",
   "Nat.Prime.one_lt",
   "Int.cast_natCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "ZMod.val_one",
   "Ring.toAddGroupWithOne",
   "HSub.hSub",
   "Field.toSemifield",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "One.toOfNat1",
   "Nat.pred_eq_sub_one",
   "Nat.pred_lt",
   "Semiring.toOne",
   "Fin.val_mk",
   "DivisionSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "instHMod",
   "Fact.mk",
   "instNatCastInt",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "letFun",
   "HMod.hMod",
   "Semifield.toDivisionSemiring",
   "Nat.instMod",
   "ZMod.intCast_eq_intCast_iff",
   "ZMod.commRing"],
  "name": "FltRegular.CaseI.aux_cong0k₁",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p) {k : Fin p}, ↑↑k ≡ -1 [ZMOD ↑p] → k = ⟨p.pred, ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["HasQuotient.quotient'", "outParam", "HasQuotient"],
  "name": "HasQuotient.Quotient",
  "constType":
  "(A : outParam (Type u)) → {B : Type v} → [inst : HasQuotient A B] → B → Type (max u v)",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Lattice"],
  "name": "Lattice.toSemilatticeSup",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeSup α",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "instHDiv",
   "DivInvMonoid",
   "HMul.hMul",
   "mul_div_assoc",
   "HDiv.hDiv",
   "DivInvMonoid.toMonoid",
   "Eq.symm",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toDiv"],
  "name": "FltRegular.NumberTheory.KummersLemma.Field._auxLemma.5",
  "constType":
  "∀ {G : Type u_3} [inst : DivInvMonoid G] (a b c : G), a * (b / c) = a * b / c",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_26._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff",
   "Submodule",
   "Iff.rfl",
   "Submodule.Quotient.mk",
   "Submodule.hasQuotient",
   "Ring",
   "AddCommGroup.toAddCommMonoid",
   "HasQuotient.Quotient",
   "Module",
   "AddCommGroup",
   "Ring.toSemiring",
   "SModEq",
   "Eq"],
  "name": "SModEq.def",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {M : Type u_3} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  {x y : M}, x ≡ y [SMOD U] ↔ Submodule.Quotient.mk x = Submodule.Quotient.mk y",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_1",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_2"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "algebraMap",
   "CommSemiring",
   "Algebra",
   "DFunLike.coe",
   "Eq.symm",
   "Algebra.toSMul",
   "IsScalarTower",
   "RingHom.instFunLike",
   "IsScalarTower.algebraMap_apply",
   "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.18",
  "constType":
  "∀ (R : Type u) (S : Type v) (A : Type w) [inst : CommSemiring R] [inst_1 : CommSemiring S] [inst_2 : Semiring A]\n  [inst_3 : Algebra R S] [inst_4 : Algebra S A] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R S A] (x : R),\n  (algebraMap S A) ((algebraMap R S) x) = (algebraMap R A) x",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "IsDomain",
   "Module.Finite",
   "Semiring.toMonoidWithZero",
   "FractionRing.field",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "nonZeroDivisors",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "OreLocalization.oreSetComm",
   "FractionRing.liftAlgebra",
   "Algebra",
   "CommSemiring.toCommMonoidWithZero",
   "IsIntegrallyClosed",
   "DFunLike.coe",
   "Algebra.toSMul",
   "Algebra.intNorm",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "OreLocalization.instCommRing",
   "NoZeroSMulDivisors",
   "Algebra.toModule",
   "OreLocalization.instRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MonoidHom",
   "OreLocalization.instAlgebra",
   "CommRing.toCommSemiring",
   "CommRing.toCommMonoid",
   "FractionRing",
   "propext",
   "CommRing.toRing",
   "FractionRing.instNoZeroSMulDivisors",
   "Algebra.intNorm_eq_zero",
   "MonoidHom.instFunLike",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.IsSeparable"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.7",
  "constType":
  "∀ {A : Type u_1} {B : Type u_4} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] [inst_3 : IsDomain A]\n  [inst_4 : IsIntegrallyClosed A] [inst_5 : IsDomain B] [inst_6 : IsIntegrallyClosed B] [inst_7 : Module.Finite A B]\n  [inst_8 : NoZeroSMulDivisors A B] [inst_9 : Algebra.IsSeparable (FractionRing A) (FractionRing B)] {x : B},\n  ((Algebra.intNorm A B) x = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Iff", "Subtype.forall.match_1", "Subtype.mk", "Subtype"],
  "name": "Subtype.forall",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∀ (x : { a // p a }), q x) ↔ ∀ (a : α) (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "RingHom",
   "DivisionRing.toRing",
   "Semifield.toCommSemiring",
   "algebraMap",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "Field.toSemifield",
   "DivInvMonoid.Pow",
   "NumberField.Units.coe_zpow",
   "RingHom.instFunLike",
   "Eq",
   "Units",
   "CommRing.toCommSemiring",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Units.val",
   "Field",
   "Semifield.toDivisionSemiring",
   "Algebra.id",
   "DFunLike.coe",
   "Field.toDivisionRing",
   "NumberField.RingOfIntegers",
   "Eq.symm",
   "DivisionRing.toDivInvMonoid",
   "Int",
   "Units.instDivInvMonoid",
   "NumberField.RingOfIntegers.instAlgebra_1"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.27",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (x : (NumberField.RingOfIntegers K)ˣ) (n : ℤ),\n  (algebraMap (NumberField.RingOfIntegers K) K) ↑x ^ n = (algebraMap (NumberField.RingOfIntegers K) K) ↑(x ^ n)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "neg_eq_zero_sub",
   "Neg.neg",
   "Eq.symm",
   "Eq"],
  "name": "zero_sub",
  "constType": "∀ {G : Type u_3} [inst : SubNegMonoid G] (a : G), 0 - a = -a",
  "constCategory": "Theorem"},
 {"references": ["EquivLike", "outParam", "Add"],
  "name": "AddEquivClass",
  "constType":
  "(F : Type u_12) →\n  (A : outParam (Type u_13)) →\n    (B : outParam (Type u_14)) → [inst : Add A] → [inst : Add B] → [inst : EquivLike F A B] → Prop",
  "constCategory": "Other"},
 {"references": ["Semiring"],
  "name": "IsDomain",
  "constType": "(α : Type u) → [inst : Semiring α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_2",
   "Lean.Name.mkStr4",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_1",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_1",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_3"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocRing.left_distrib",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalRing",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalRing.mul_assoc",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalRing.toNonUnitalSemiring",
  "constType":
  "{α : Type u_1} → [self : NonUnitalRing α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references": ["Semiring", "CommSemiring", "Algebra"],
  "name": "AlgEquiv",
  "constType":
  "(R : Type u) →\n  (A : Type v) →\n    (B : Type w) →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A] → [inst_2 : Semiring B] → [inst_3 : Algebra R A] → [inst : Algebra R B] → Type (max v w)",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "mul_add",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b c : R} (x : R) (e : ℕ), a + b = c → x ^ e * a + x ^ e * b = x ^ e * c",
  "constCategory": "Theorem"},
 {"references": ["Zero", "MonoidWithZero"],
  "name": "MonoidWithZero.toZero",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.intro",
  "constType": "∀ {a b : Prop}, a → b → a ∧ b",
  "constCategory": "Other"},
 {"references": ["Nat.gcd._unary", "PSigma.mk", "Nat"],
  "name": "Nat.gcd",
  "constType": "ℕ → ℕ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["GCDMonoid.gcd",
   "Nat.cast",
   "instNatCastInt",
   "Int.instCancelCommMonoidWithZero",
   "rfl",
   "Int",
   "Int.instGCDMonoid",
   "Eq",
   "Int.gcd"],
  "name": "Int.coe_gcd",
  "constType": "∀ (i j : ℤ), ↑(i.gcd j) = gcd i j",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Set.instSingletonSet",
   "Submodule.prod_span_singleton",
   "Set",
   "CommSemiring",
   "Finset.prod",
   "Finset",
   "Submodule.instIdemCommSemiring",
   "Singleton.singleton",
   "CommSemiring.toCommMonoid",
   "Ideal.span",
   "Algebra.id",
   "Ideal",
   "IdemCommSemiring.toCommSemiring",
   "Eq"],
  "name": "Ideal.prod_span_singleton",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] {ι : Type u_2} (s : Finset ι) (I : ι → R),\n  ∏ i ∈ s, Ideal.span {I i} = Ideal.span {∏ i ∈ s, I i}",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "Subtype.val",
   "Subtype.coe_injective",
   "Function.Injective.eq_iff",
   "Subtype",
   "Eq"],
  "name": "Subtype.coe_inj",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, ↑a = ↑b ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.instCommRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "CharZero",
   "CommRing.toRing",
   "Int.ofNat.inj",
   "Nat",
   "CharZero.mk",
   "Int"],
  "name": "Int.instCharZero",
  "constType": "CharZero ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Polynomial.ofFinsupp",
   "Polynomial.toFinsupp",
   "SMul.mk",
   "instHSMul",
   "AddMonoidAlgebra.semiring",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "SMulZeroClass",
   "Nat.instAddMonoid",
   "Polynomial.smulZeroClass.proof_1",
   "AddMonoidAlgebra",
   "SMulZeroClass.toSMul",
   "AddMonoidAlgebra.smulZeroClass",
   "SMulZeroClass.mk",
   "Polynomial",
   "Polynomial.zero",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Nat"],
  "name": "Polynomial.smulZeroClass",
  "constType":
  "{R : Type u} → [inst : Semiring R] → {S : Type u_1} → [inst_1 : SMulZeroClass S R] → SMulZeroClass S (Polynomial R)",
  "constCategory": "Definition"},
 {"references":
  ["SubtractionCommMonoid.toAddCommMonoid",
   "SubtractionCommMonoid",
   "Finset.sum",
   "Multiset.sum_map_neg",
   "Finset",
   "Finset.val",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "Finset.sum_neg_distrib",
  "constType":
  "∀ {α : Type u_3} {β : Type u_4} {s : Finset α} {f : α → β} [inst : SubtractionCommMonoid β],\n  ∑ x ∈ s, -f x = -∑ x ∈ s, f x",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.coe_inj", "propext", "Subtype.val", "Eq.symm", "Subtype", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert90._auxLemma.2",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, (a = b) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "IsEmpty",
  "constType": "Sort u_4 → Prop",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "PartENat.coe_lt_coe",
   "Monoid.toSemigroup",
   "Monoid",
   "PartENat.partialOrder",
   "PartialOrder.toPreorder",
   "PartENat",
   "Dvd.dvd",
   "semigroupDvd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "instLTNat",
   "multiplicity.Finite",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instHPow",
   "propext",
   "PartENat.natCast_get",
   "PartENat.instAddCommMonoidWithOne",
   "Preorder.toLT",
   "LT.lt",
   "Part.get",
   "Eq.mp",
   "Monoid.toNatPow",
   "Not",
   "multiplicity",
   "multiplicity.is_greatest",
   "Nat",
   "Eq.symm",
   "congrArg",
   "DecidableRel"],
  "name": "multiplicity.is_greatest'",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] [inst_1 : DecidableRel fun x x_1 => x ∣ x_1] {a b : α} {m : ℕ}\n  (h : multiplicity.Finite a b), (multiplicity a b).get h < m → ¬a ^ m ∣ b",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_21",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_22._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["not_or", "And", "Or", "propext", "Not", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.5",
  "constType": "∀ {p q : Prop}, (¬(p ∨ q)) = (¬p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "Finset.instInsert",
   "Iff",
   "DecidableEq",
   "Finset",
   "Finset.val",
   "Insert.insert",
   "Multiset.mem_ndinsert",
   "Eq",
   "Finset.instMembership"],
  "name": "Finset.mem_insert",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, a ∈ insert b s ↔ a = b ∨ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_41"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_42._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_37",
   "List.nil",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_38._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "MulHomClass",
   "FunLike",
   "HMul.hMul",
   "MulHomClass.map_mul",
   "DFunLike.coe",
   "Mul",
   "Eq"],
  "name": "map_mul",
  "constType":
  "∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Mul M] [inst_1 : Mul N] [inst_2 : FunLike F M N]\n  [inst_3 : MulHomClass F M N] (f : F) (x y : M), f (x * y) = f x * f y",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "Set", "Set.instMembership", "Subtype"],
  "name": "Set.Elem",
  "constType": "{α : Type u} → Set α → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Submonoid.mk",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "setOf",
   "MulZeroOneClass.toMulOneClass",
   "nonZeroDivisors.proof_1",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "nonZeroDivisors.proof_2",
   "Subsemigroup.mk",
   "Submonoid",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "MonoidWithZero"],
  "name": "nonZeroDivisors",
  "constType": "(R : Type u_2) → [inst : MonoidWithZero R] → Submonoid R",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "Finset.instInsert",
   "GCDMonoid",
   "Finset.erase_subset",
   "IsDomain",
   "Finset.insert_erase",
   "Semiring.toMonoidWithZero",
   "IsCoprime",
   "Finset.prod_insert",
   "Insert.insert",
   "Eq",
   "Finset.instMembership",
   "Finset.not_mem_erase",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Finset",
   "Finset.erase",
   "Monoid.toNatPow",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "Nat",
   "Eq.symm",
   "IsCoprime.prod_right",
   "Membership.mem",
   "HPow.hPow",
   "Ne",
   "IsDomain.toCancelCommMonoidWithZero",
   "Classical.propDecidable",
   "Monoid.toMulOneClass",
   "Unique",
   "exists_eq_pow_of_mul_eq_pow_of_coprime",
   "Units",
   "instHMul",
   "Finset.prod",
   "Eq.mp",
   "HMul.hMul",
   "congrArg"],
  "name": "Finset.exists_eq_pow_of_mul_eq_pow_of_coprime",
  "constType":
  "∀ {ι : Type u_2} {R : Type u_3} [inst : CommSemiring R] [inst_1 : IsDomain R] [inst_2 : GCDMonoid R]\n  [inst_3 : Unique Rˣ] {n : ℕ} {c : R} {s : Finset ι} {f : ι → R},\n  (∀ i ∈ s, ∀ j ∈ s, i ≠ j → IsCoprime (f i) (f j)) → ∏ i ∈ s, f i = c ^ n → ∀ i ∈ s, ∃ d, f i = d ^ n",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.isNat_eq_false.match_1",
   "Eq",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "Mathlib.Meta.NormNum.IsNat",
   "Bool.false",
   "Nat.ne_of_beq_eq_false",
   "Not",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
   "Bool",
   "Nat.beq",
   "Nat",
   "congrArg",
   "id"],
  "name": "Mathlib.Meta.NormNum.isNat_eq_false",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : CharZero α] {a b : α} {a' b' : ℕ},\n  Mathlib.Meta.NormNum.IsNat a a' → Mathlib.Meta.NormNum.IsNat b b' → a'.beq b' = false → ¬a = b",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "OfNat.ofNat",
   "Polynomial.C",
   "dite",
   "map_sum",
   "instDecidableEqNat",
   "Eq",
   "Finset.instMembership",
   "ite",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "Nat",
   "Finset.sum_congr",
   "Eq.trans",
   "HPow.hPow",
   "Polynomial.coeff_C_mul_X_pow",
   "Semiring",
   "RingHom.map_zero",
   "MulZeroOneClass.toZero",
   "RingHom.instFunLike",
   "Polynomial.support",
   "instHMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Polynomial.eval₂",
   "congr",
   "Not",
   "MonoidWithZero.toZero",
   "congrArg",
   "Polynomial.semiring",
   "RingHom",
   "Polynomial.coeff_sum",
   "RingHom.comp",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Polynomial.map.eq_1",
   "NonAssocSemiring.toMulZeroOneClass",
   "Polynomial.sum.eq_1",
   "rfl",
   "True",
   "Zero.toOfNat0",
   "Polynomial",
   "RingHomClass.toAddMonoidHomClass",
   "instHPow",
   "Eq.rec",
   "Finset",
   "Monoid.toNatPow",
   "DFunLike.coe",
   "Eq.symm",
   "if_neg",
   "id",
   "Polynomial.sum_C_mul_X_pow_eq",
   "Membership.mem",
   "eq_self",
   "Polynomial.X",
   "Finset.sum",
   "Polynomial.coeff",
   "Polynomial.sum",
   "Polynomial.eval₂_def",
   "NonUnitalNonAssocSemiring.toMul",
   "Polynomial.map",
   "if_pos",
   "Polynomial.mul'",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid"],
  "name": "Polynomial.coeff_map",
  "constType":
  "∀ {R : Type u} {S : Type v} [inst : Semiring R] {p : Polynomial R} [inst_1 : Semiring S] (f : R →+* S) (n : ℕ),\n  (Polynomial.map f p).coeff n = f (p.coeff n)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Prod.exists.match_2",
   "Prod.mk",
   "Prod",
   "Exists.intro",
   "Prod.exists.match_1"],
  "name": "Prod.exists",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∃ x, p x) ↔ ∃ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "MonoidHomClass",
   "Monoid",
   "FunLike",
   "map_pow",
   "instHPow",
   "Monoid.toNatPow",
   "DFunLike.coe",
   "Nat",
   "Eq.symm",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.13",
  "constType":
  "∀ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : FunLike F G H] [inst_1 : Monoid G] [inst_2 : Monoid H]\n  [inst_3 : MonoidHomClass F G H] (f : F) (a : G) (n : ℕ), f a ^ n = f (a ^ n)",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name.num", "Nat", "Lean.Name"],
  "name": "Lean.Name.mkNum",
  "constType": "Lean.Name → ℕ → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Equiv",
   "Monoid",
   "MonoidHom.mrange",
   "Nat.instAddMonoid",
   "MonoidHom",
   "Submonoid.powers.proof_1",
   "AddMonoid.toAddZeroClass",
   "Monoid.toMulOneClass",
   "powersHom",
   "Set.range",
   "Submonoid.copy",
   "Multiplicative",
   "Submonoid.powers.proof_2",
   "instHPow",
   "Submonoid",
   "Monoid.toNatPow",
   "Equiv.instFunLike",
   "MonoidHom.instFunLike",
   "Nat",
   "DFunLike.coe",
   "Multiplicative.mulOneClass"],
  "name": "Submonoid.powers",
  "constType": "{M : Type u_1} → [inst : Monoid M] → M → Submonoid M",
  "constCategory": "Definition"},
 {"references": ["outParam", "HSub"],
  "name": "HSub.hSub",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HSub α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termR_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Unit",
   "Lean.MonadQuotation.mk",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Lean.Syntax",
   "MonadReader.read",
   "Lean.MacroScope",
   "EStateM.instMonad",
   "instMonadWithReaderOfReaderT",
   "ReaderT.instApplicativeOfMonad",
   "instMonadReaderOfReaderTOfMonad",
   "Lean.MonadRef.mk",
   "Lean.PrettyPrinter.UnexpandM",
   "instOfNatNat",
   "Lean.Name",
   "Lean.MonadQuotation",
   "instMonadReaderOfMonadReaderOf",
   "MonadWithReader.withReader",
   "instMonadWithReaderOfMonadWithReaderOf",
   "Applicative.toPure",
   "id"],
  "name": "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
  "constType": "Lean.MonadQuotation Lean.PrettyPrinter.UnexpandM",
  "constCategory": "Definition"},
 {"references":
  ["NeZero",
   "OfNat.ofNat",
   "NeZero.mk",
   "instAddNat",
   "instHAdd",
   "Zero.ofOfNat0",
   "HAdd.hAdd",
   "Nat.succ_ne_zero",
   "instOfNatNat",
   "Nat"],
  "name": "NeZero.succ",
  "constType": "∀ {n : ℕ}, NeZero (n + 1)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "ContravariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references": ["Classical.not_forall", "Exists", "propext", "Not", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.28",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["Ideal.Quotient.commRing",
   "CommSemiring.toSemiring",
   "RingHom",
   "Submodule",
   "Submodule.Quotient.mk",
   "AddCommGroup.toAddCommMonoid",
   "Ideal.Quotient.mk_eq_mk",
   "Ring.toSemiring",
   "RingHom.instFunLike",
   "CommRing",
   "Eq",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Submodule.hasQuotient",
   "CommRing.toRing",
   "Ideal.Quotient.mk",
   "Ring.toAddCommGroup",
   "HasQuotient.Quotient",
   "DFunLike.coe",
   "Eq.symm",
   "Ideal",
   "Ideal.instHasQuotient",
   "Semiring.toModule"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.8",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] {I : Ideal R} (x : R), (Ideal.Quotient.mk I) x = Submodule.Quotient.mk x",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Units",
   "Monoid",
   "instHPow",
   "Units.instMonoid",
   "Units.val",
   "Monoid.toNatPow",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Units.val_pow_eq_pow_val",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a : αˣ) (n : ℕ), ↑(a ^ n) = ↑a ^ n",
  "constCategory": "Theorem"},
 {"references": ["Int", "Neg", "Int.neg", "Neg.mk"],
  "name": "Int.instNegInt",
  "constType": "Neg ℤ",
  "constCategory": "Definition"},
 {"references": ["Zero", "MulZeroClass"],
  "name": "MulZeroClass.toZero",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Nat.decidablePrime1",
   "instOfNatNat",
   "Bool",
   "Nat"],
  "name": "Nat.prime_three",
  "constType": "Nat.Prime 3",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Macro.Exception",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Setoid.r",
   "Iff",
   "DecidableEq",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.induction_on",
   "List.mem_dedup",
   "Multiset.dedup",
   "Multiset.instMembership"],
  "name": "Multiset.mem_dedup",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, a ∈ s.dedup ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.15",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name._impl",
   "OfNat.ofNat",
   "UInt64.size",
   "Lean.Name.hash.proof_4",
   "Nat.decLt",
   "dite",
   "Lean.Name.num._impl",
   "instLTNat",
   "LT.lt",
   "Not",
   "instOfNatNat",
   "UInt64",
   "Lean.Name",
   "Nat",
   "UInt64.ofNatCore",
   "mixHash",
   "unsafeCast",
   "Lean.Name.hash"],
  "name": "Lean.Name.num._override",
  "constType": "Lean.Name → ℕ → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CommMagma",
   "HMul.hMul",
   "CommMagma.toMul",
   "CommMagma.mul_comm",
   "Eq"],
  "name": "mul_comm",
  "constType": "∀ {G : Type u_1} [inst : CommMagma G] (a b : G), a * b = b * a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_false",
   "OfNat.ofNat",
   "False",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Fin.succAbove_ne",
   "instOfNatNat",
   "Nat",
   "Fin.succAbove",
   "Fin",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.4",
  "constType":
  "∀ {n : ℕ} (p : Fin (n + 1)) (i : Fin n), (p.succAbove i = p) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "Monoid.toSemigroup",
   "CommSemiring.toNonUnitalCommSemiring.proof_3",
   "NonUnitalCommSemiring",
   "CommMonoid.mul_comm",
   "CommSemiring.toNonUnitalCommSemiring.proof_5",
   "NonUnitalNonAssocSemiring.mk",
   "CommSemiring.toNonUnitalCommSemiring.proof_1",
   "CommMonoid",
   "CommSemiring.toNonUnitalCommSemiring.proof_2",
   "CommSemiring",
   "NonUnitalSemiring.mk",
   "CommSemiring.toNonUnitalCommSemiring.proof_4",
   "inferInstanceAs",
   "CommSemiring.toCommMonoid",
   "NonUnitalCommSemiring.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommMonoid.toMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "CommSemiring.toNonUnitalCommSemiring",
  "constType":
  "{α : Type u} → [inst : CommSemiring α] → NonUnitalCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["OrderedAddCommMonoid",
   "Semiring.toNonUnitalSemiring",
   "OrderedSemiring",
   "OrderedSemiring.add_le_add_left",
   "OrderedSemiring.toSemiring",
   "OrderedAddCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "OrderedSemiring.toPartialOrder"],
  "name": "OrderedSemiring.toOrderedAddCommMonoid",
  "constType":
  "{α : Type u} → [self : OrderedSemiring α] → OrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Mathlib.Meta.NormNum.isNat_add.match_1",
   "Nat.cast_add",
   "Eq",
   "AddMonoidWithOne",
   "Nat.add",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "AddMonoid.toAddSemigroup",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.symm"],
  "name": "Mathlib.Meta.NormNum.isNat_add",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] {f : α → α → α} {a b : α} {a' b' c : ℕ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsNat a a' →\n      Mathlib.Meta.NormNum.IsNat b b' → a'.add b' = c → Mathlib.Meta.NormNum.IsNat (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionCommMonoid.mk",
   "Group.toDivisionMonoid",
   "DivisionMonoid",
   "CommGroup.toGroup",
   "DivisionMonoid.mul_inv_rev",
   "DivisionMonoid.inv_inv",
   "CommGroup",
   "CommGroup.mul_comm",
   "DivisionCommMonoid",
   "DivisionMonoid.mk",
   "DivisionMonoid.inv_eq_of_mul",
   "Group.toDivInvMonoid"],
  "name": "CommGroup.toDivisionCommMonoid",
  "constType": "{G : Type u_1} → [inst : CommGroup G] → DivisionCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "Submodule",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Semiring.toModule"],
  "name": "Ideal",
  "constType": "(R : Type u) → [inst : Semiring R] → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "And",
   "OfNat.ofNat",
   "instHAdd",
   "propext",
   "AddMonoid.toZero",
   "HAdd.hAdd",
   "Subsingleton",
   "AddCommMonoid.toAddMonoid",
   "add_eq_zero",
   "AddMonoid.toAddZeroClass",
   "AddUnits",
   "Eq",
   "AddCommMonoid"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.24",
  "constType":
  "∀ {α : Type u} [inst : AddCommMonoid α] [inst_1 : Subsingleton (AddUnits α)] {a b : α}, (a + b = 0) = (a = 0 ∧ b = 0)",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.5",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Fact",
  "constType": "Prop → Prop",
  "constCategory": "Other"},
 {"references": ["CancelMonoidWithZero", "MonoidWithZero"],
  "name": "CancelMonoidWithZero.toMonoidWithZero",
  "constType":
  "{M₀ : Type u_4} → [self : CancelMonoidWithZero M₀] → MonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Subgroup.mk",
   "MulAction.stabilizer.proof_1",
   "Subgroup",
   "Submonoid",
   "Group",
   "MulAction.stabilizerSubmonoid",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "MulAction",
   "Monoid.toMulOneClass"],
  "name": "MulAction.stabilizer",
  "constType":
  "(G : Type u_1) → {α : Type u_2} → [inst : Group G] → [inst_1 : MulAction G α] → α → Subgroup G",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Int.sub_lt_self",
   "Nat.mod_lt",
   "Int.ofNat_lt",
   "instLTNat",
   "Int.instLTInt",
   "Iff.mpr",
   "Eq",
   "Int.eq_succ_of_zero_lt",
   "instHMod",
   "Nat.cast",
   "instNatCastInt",
   "LT.lt",
   "HMod.hMod",
   "Nat",
   "Int.instMod",
   "Int.emod_lt_of_pos.match_1",
   "Nat.instMod",
   "Int",
   "instOfNat",
   "Nat.succ",
   "Nat.succ_pos",
   "Int.natAbs"],
  "name": "Int.emod_lt_of_pos",
  "constType": "∀ (a : ℤ) {b : ℤ}, 0 < b → a % b < b",
  "constCategory": "Theorem"},
 {"references":
  ["AlgEquiv",
   "CommSemiring.toSemiring",
   "unitsGal",
   "DivisionRing.toRing",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "AlgHomClass.toAlgHom",
   "unitGalConj.proof_1",
   "algebraRat",
   "Rat.commRing",
   "Set.instSingletonSet",
   "MonoidWithZero.toMonoid",
   "Field",
   "Units.instMulOneClass",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Rat.commSemiring",
   "Rat",
   "Field.toSemifield",
   "MonoidHom",
   "EuclideanDomain.toCommRing",
   "AlgEquiv.instFunLike",
   "IsCyclotomicExtension",
   "DivisionSemiring.toSemiring",
   "Units",
   "CommRing.toCommSemiring",
   "CharZero",
   "Field.toEuclideanDomain",
   "Singleton.singleton",
   "Semifield.toDivisionSemiring",
   "galConj",
   "Field.toDivisionRing",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "unitGalConj",
  "constType":
  "(K : Type u_1) →\n  (p : ℕ+) →\n    [inst : Field K] →\n      [inst_1 : CharZero K] →\n        [inst_2 : IsCyclotomicExtension {p} ℚ K] → (NumberField.RingOfIntegers K)ˣ →* (NumberField.RingOfIntegers K)ˣ",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Inv"],
  "name": "DivInvMonoid.toInv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Inv G",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "eq_false",
   "False",
   "of_decide_eq_false",
   "Bool.false",
   "Decidable",
   "Bool",
   "Eq"],
  "name": "eq_false_of_decide",
  "constType": "∀ {p : Prop} {x : Decidable p}, decide p = false → p = False",
  "constCategory": "Theorem"},
 {"references": ["Or", "Or.inl", "Or.inr", "Or.rec"],
  "name": "Or.casesOn",
  "constType":
  "∀ {a b : Prop} {motive : a ∨ b → Prop} (t : a ∨ b), (∀ (h : a), motive ⋯) → (∀ (h : b), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references": ["Lean.MacroM", "Lean.Syntax"],
  "name": "Lean.Macro",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne", "AddMonoidWithOne.toNatCast", "Nat.cast", "Nat"],
  "name": "Nat.rawCast",
  "constType": "{α : Type u} → [inst : AddMonoidWithOne α] → ℕ → α",
  "constCategory": "Definition"},
 {"references":
  ["BEq.beq",
   "Lean.Syntax.getKind",
   "Lean.SyntaxNodeKind",
   "Lean.Name.instBEq",
   "Bool",
   "Lean.Syntax"],
  "name": "Lean.Syntax.isOfKind",
  "constType": "Lean.Syntax → Lean.SyntaxNodeKind → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Ideal.Quotient.commRing",
   "CommSemiring.toSemiring",
   "algebraMap",
   "RingHom.comp",
   "Ideal.Quotient.algebra.proof_3",
   "CommRing",
   "CommRing.toCommSemiring",
   "Submodule.Quotient.instSMul'",
   "Ideal.Quotient.algebra.proof_2",
   "Semiring.toNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "CommRing.toRing",
   "Ideal.Quotient.mk",
   "Ring.toAddCommGroup",
   "Algebra.mk",
   "HasQuotient.Quotient",
   "Algebra.toSMul",
   "Ideal.Quotient.algebra.proof_1",
   "Ideal",
   "Ideal.instHasQuotient",
   "Semiring.toModule"],
  "name": "Ideal.Quotient.algebra",
  "constType":
  "(R₁ : Type u_1) →\n  {A : Type u_3} →\n    [inst : CommSemiring R₁] → [inst_1 : CommRing A] → [inst_2 : Algebra R₁ A] → {I : Ideal A} → Algebra R₁ (A ⧸ I)",
  "constCategory": "Definition"},
 {"references":
  ["Bot",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Bot.bot",
   "Submodule",
   "AddSubsemigroup.mk",
   "Semiring",
   "Set",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddSubmonoid",
   "Submodule.instBot.proof_3",
   "AddSubmonoid.instBot",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Submodule.instBot.proof_2",
   "Set.instSingletonSet",
   "Submodule.mk",
   "Bot.mk",
   "AddSubmonoid.mk",
   "Singleton.singleton",
   "Module",
   "Submodule.instBot.proof_1",
   "AddCommMonoid"],
  "name": "Submodule.instBot",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Bot (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "IsRegularPrime",
   "Mathlib.Tactic.Ring.pow_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Insert.insert",
   "Semiring.toNatCast",
   "ite",
   "Finset.instMembership",
   "DecidablePred",
   "FltRegular.CaseI.aux1k₁",
   "Finset.sum_range",
   "instOfNat",
   "Fin.mk",
   "Subtype",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Finset.filter_filter",
   "SMulZeroClass.toSMul",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "And",
   "Finset.sum_neg_distrib",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "MonoidWithZero.toZero",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "Int.instSemigroup",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "HEq",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Set",
   "Nat.decLt",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "semigroupDvd",
   "NeZero.pnat",
   "NonAssocSemiring.toMulZeroOneClass",
   "Finset.gcd",
   "Mathlib.Tactic.Ring.sub_pf",
   "CyclotomicField.instField",
   "zero_ne_one",
   "Monoid.toNatPow",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Mathlib.Tactic.Ring.mul_pow",
   "Mathlib.Tactic.Ring.mul_add",
   "Neg.neg",
   "NormedField.toNormedCommRing",
   "instDecidableAnd",
   "LE.le",
   "if_true",
   "CommRing.toCommSemiring",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "instNatCastInt",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "FltRegular.f",
   "NegZeroClass.toNeg",
   "Subtype.mk",
   "PNat",
   "Mathlib.Tactic.Ring.mul_congr",
   "instHSMul",
   "SubtractionCommMonoid.toAddCommMonoid",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "instSubsingletonForall",
   "AddGroup.toSubtractionMonoid",
   "Finset.sum_const_zero",
   "CanonicallyOrderedCommSemiring.toOne",
   "FltRegular.ex_fin_div",
   "FltRegular.CaseI.auxk₁k₂",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "AddCommGroup.intModule",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "IsCyclotomicExtension.ring_of_integers'",
   "dvd_coeff_cycl_integer",
   "And.casesOn",
   "Eq.trans",
   "NormedRing.toRing",
   "ite_smul",
   "Int.instDvd",
   "Int.instHPowNat",
   "IsCyclotomicExtension.zeta_spec",
   "Finset.instSingleton",
   "Fin.fintype",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "pow_zero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "Mathlib.Tactic.Ring.neg_mul",
   "Finset.univ",
   "MulActionWithZero.toSMulWithZero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "HEq.refl",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "Singleton.singleton",
   "mul_one",
   "instSubsingletonDecidable",
   "Finset.instEmptyCollection",
   "Int.ofNat",
   "CommRing.toNonUnitalCommRing",
   "Dvd.dvd.mul_right",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Set.instSingletonSet",
   "instDecidableNot",
   "AddMonoid.toZero",
   "ite_cond_eq_true",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Mathlib.Tactic.Ring.pow_congr",
   "id",
   "eq_self",
   "Membership.mem",
   "Nat.Prime.one_lt",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "False",
   "Int.instNormalizedGCDMonoid",
   "AddMonoidWithOne.toAddMonoid",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "ite_congr",
   "Nat.instCanonicallyOrderedCommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Eq.casesOn",
   "NumberField.RingOfIntegers",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.one_pow",
   "CommSemiring.toSemiring",
   "Finset.range_filter_eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Finset.instInsert",
   "Int.instDecidableEq",
   "EmptyCollection.emptyCollection",
   "AddCommGroup.toAddCommMonoid",
   "AddGroupWithOne.toAddGroup",
   "instDecidableEqNat",
   "pow_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Nat.Prime",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "Finset.range",
   "HSMul.hSMul",
   "LinearOrderedCommMonoidWithZero.toZero",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Mathlib.Tactic.Ring.pow_add",
   "Int.instSub",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "HPow.hPow",
   "zsmul_eq_mul",
   "eq_of_heq",
   "Int.instRing",
   "Module.toMulActionWithZero",
   "CyclotomicField",
   "ne_and_eq_iff_right",
   "instDecidableTrue",
   "Mathlib.Tactic.Ring.neg_zero",
   "CommRing.toCommMonoid",
   "eq_true",
   "Nat.zero",
   "LT.lt",
   "Finset.sum_ite",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "FltRegular.CaseI.aux0k₁",
   "Int",
   "Fin",
   "neg_smul",
   "Exists",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "AddMonoid.toAddZeroClass",
   "algebraInt",
   "True",
   "Subsingleton.elim",
   "Eq.rec",
   "Finset",
   "Decidable",
   "Finset.filter",
   "NeZero.charZero",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instMul",
   "Finset.sum",
   "One.toOfNat1",
   "FltRegular.CaseI.Statement._auxLemma.11",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "IsCyclotomicExtension",
   "Int.instCommRing",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "FltRegular.CaseI.aux0k₂",
   "FltRegular.auxf",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Rat.instNormedField",
   "CyclotomicField.instCharZero",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "AddGroup.intSMulWithZero",
   "Exists.casesOn",
   "instLTNat",
   "Int.instAdd",
   "IsCyclotomicExtension.zeta",
   "Eq",
   "Eq.mpr",
   "Ring.toNeg",
   "Finset.sum_singleton",
   "Nat",
   "Finset.sum_congr",
   "Ne",
   "Nat.Prime.pos",
   "Fin.val",
   "Int.ModEq",
   "Nat.rawCast",
   "SubNegMonoid.SMulInt",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "instHMul",
   "FltRegular.CaseI.aux1k₂",
   "NonAssocRing.toIntCast",
   "Not",
   "Fact",
   "congrArg",
   "add_zero",
   "zero_smul",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "NonAssocRing.toAddCommGroupWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "NumberField.RingOfIntegers.instCommRing",
   "Fact.out",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing",
   "PNat.val",
   "Zero.toOfNat0",
   "instLENat",
   "instHPow",
   "Ring.toSub",
   "Int.instNegInt",
   "Eq.symm",
   "NeZero.succ",
   "Rat.instField",
   "funext",
   "instHAdd",
   "CyclotomicField.isCyclotomicExtension",
   "HSub.hSub",
   "Rat",
   "Mathlib.Tactic.Ring.single_pow",
   "AddGroup.toSubNegMonoid",
   "Int.instCancelCommMonoidWithZero",
   "Rat.instCharZero",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "FltRegular.CaseI.Statement._auxLemma.10",
   "NegZeroClass.toZero",
   "Int.instCommSemiring",
   "Dvd"],
  "name": "FltRegular.caseI_easier",
  "constType":
  "∀ {p : ℕ} [hpri : Fact (Nat.Prime p)] {a b c : ℤ},\n  IsRegularPrime p → 5 ≤ p → {a, b, c}.gcd id = 1 → ¬a ≡ b [ZMOD ↑p] → ¬↑p ∣ a * b * c → a ^ p + b ^ p ≠ c ^ p",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "OfNat.ofNat",
   "Int.prime_iff_natAbs_prime",
   "Int.instDecidableEq",
   "Finset.instInsert",
   "Nat.exists_prime_and_dvd",
   "HAdd.hAdd",
   "IsCoprime",
   "Insert.insert",
   "Exists.casesOn",
   "instDecidableEqNat",
   "Int.instAdd",
   "Iff.mpr",
   "Finset.instMembership",
   "Eq",
   "mul_assoc",
   "Eq.mpr",
   "Nat.Prime",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toSemigroupWithZero",
   "Finset.dvd_gcd",
   "Nat.instDvd",
   "Nat",
   "And.casesOn",
   "instOfNat",
   "Eq.trans",
   "HPow.hPow",
   "Ne",
   "Or",
   "Int.instDistrib",
   "Int.instHPowNat",
   "Int.instDvd",
   "Finset.instSingleton",
   "Or.casesOn",
   "dvd_pow",
   "Int.gcd",
   "SemigroupWithZero.toSemigroup",
   "And",
   "instHMul",
   "Prime",
   "eq_true",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "dvd_add",
   "Eq.mp",
   "Int.instCommMonoid",
   "Not",
   "Singleton.singleton",
   "congrArg",
   "Int",
   "Int.instSemigroup",
   "Exists",
   "Prime.dvd_of_dvd_pow",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Int.instSemiring",
   "isUnit_of_dvd_one",
   "semigroupDvd",
   "Exists.intro",
   "FltRegular.CaseI.Statement._auxLemma.1",
   "Int.gcd_eq_one_iff_coprime",
   "Finset.gcd",
   "True",
   "Nat.cast_mul",
   "FltRegular.CaseI.Statement._auxLemma.2",
   "Finset",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Decidable.byContradiction",
   "Eq.symm",
   "CommMonoidWithZero.toMonoidWithZero",
   "id",
   "Membership.mem",
   "eq_self",
   "False",
   "instHAdd",
   "Int.instMul",
   "Int.instNormalizedGCDMonoid",
   "Dvd.dvd",
   "Int.instMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Int.gcd_dvd_left",
   "Int.instCancelCommMonoidWithZero",
   "Distrib.leftDistribClass",
   "Prime.not_unit",
   "instNatCastInt",
   "Int.gcd_dvd_right",
   "letFun",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "instMulNat",
   "Int.instCommSemiring",
   "Int.natAbs"],
  "name": "FltRegular.ab_coprime",
  "constType":
  "∀ {p : ℕ} {a b c : ℤ}, a ^ p + b ^ p = c ^ p → p ≠ 0 → {a, b, c}.gcd id = 1 → IsCoprime a b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "instHAdd",
   "Finset.sum",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Finset.fold_congr",
   "Eq",
   "Finset.instMembership",
   "Zero.toOfNat0",
   "Eq.mpr",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Finset",
   "AddCommMagma.to_isCommutative",
   "AddSemigroup.to_isAssociative",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid",
   "id"],
  "name": "Finset.sum_congr",
  "constType":
  "∀ {α : Type u_3} {β : Type u_4} {s₁ s₂ : Finset α} {f g : α → β} [inst : AddCommMonoid β],\n  s₁ = s₂ → (∀ x ∈ s₂, f x = g x) → s₁.sum f = s₂.sum g",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Exists",
   "OfNat.ofNat",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Odd.proof_1",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNatCast",
   "Semiring.toOne",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "instOfNatAtLeastTwo"],
  "name": "Odd",
  "constType": "{α : Type u_2} → [inst : Semiring α] → α → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Nat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["instHMul",
   "CommSemigroup.toCommMagma",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "CommMagma.toMul",
   "CommSemigroup",
   "dvd_mul_of_dvd_right",
   "CommSemigroup.toSemigroup"],
  "name": "Dvd.dvd.mul_left",
  "constType":
  "∀ {α : Type u_1} [inst : CommSemigroup α] {a b : α}, a ∣ b → ∀ (c : α), a ∣ c * b",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "pow_mul",
   "Monoid",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instMulNat",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.15",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (m n : ℕ), (a ^ m) ^ n = a ^ (m * n)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq.symm", "Eq"],
  "name": "Eq.mpr",
  "constType": "{α β : Sort u} → α = β → β → α",
  "constCategory": "Definition"},
 {"references": ["propext", "GE.ge", "ge_iff_le", "LE", "LE.le", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.5",
  "constType": "∀ {α : Type u} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Monoid.toOne",
   "IsPrimitiveRoot",
   "Eq.refl",
   "One.toOfNat1",
   "pow_one",
   "Eq",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "CommMonoid",
   "instHPow",
   "IsPrimitiveRoot.pow_eq_one",
   "Monoid.toNatPow",
   "IsPrimitiveRoot.one",
   "instOfNatNat",
   "Nat",
   "CommMonoid.toMonoid",
   "congrArg",
   "Eq.symm",
   "id"],
  "name": "IsPrimitiveRoot.one_right_iff",
  "constType":
  "∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M}, IsPrimitiveRoot ζ 1 ↔ ζ = 1",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Eq.refl",
   "instLTNat",
   "Nat.mod_eq_of_lt",
   "ZMod.val_natCast",
   "ZMod",
   "Eq",
   "Semiring.toNatCast",
   "CommRing.toCommSemiring",
   "Eq.mpr",
   "instHMod",
   "Nat.cast",
   "ZMod.val",
   "LT.lt",
   "HMod.hMod",
   "Nat",
   "congrArg",
   "Nat.instMod",
   "ZMod.commRing",
   "id"],
  "name": "ZMod.val_cast_of_lt",
  "constType": "∀ {n a : ℕ}, a < n → (↑a).val = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "MulAction.mul_smul",
  "constType":
  "∀ {α : Type u_11} {β : Type u_12} [inst : Monoid α] [self : MulAction α β] (x y : α) (b : β), (x * y) • b = x • y • b",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Lean.Omega.LinearCombo.eval",
   "OfNat.ofNat",
   "List.cons",
   "Lean.Omega.LinearCombo.coordinate",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "True",
   "Eq",
   "Lean.Omega.Coeffs.ofList",
   "of_eq_true",
   "List",
   "instOfNatNat",
   "Lean.Omega.Coeffs.get",
   "Nat",
   "congrArg",
   "Int",
   "Eq.trans"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_0",
  "constType":
  "∀ {a0 : ℤ} {t : List ℤ}, (Lean.Omega.LinearCombo.coordinate 0).eval (Lean.Omega.Coeffs.ofList (a0 :: t)) = a0",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "MvPolynomial.commSemiring",
   "CommSemiring.toSemiring",
   "RingHom",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "MvPolynomial.C_1",
   "MvPolynomial",
   "CommSemiring",
   "One.toOfNat1",
   "DFunLike.coe",
   "Eq.symm",
   "RingHom.instFunLike",
   "Eq",
   "MvPolynomial.C"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.29",
  "constType":
  "∀ {R : Type u} {σ : Type u_1} [inst : CommSemiring R], 1 = MvPolynomial.C 1",
  "constCategory": "Theorem"},
 {"references":
  ["and_assoc.match_2",
   "Iff.intro",
   "And",
   "Iff",
   "and_assoc.match_1",
   "And.intro"],
  "name": "and_assoc",
  "constType": "∀ {a b c : Prop}, (a ∧ b) ∧ c ↔ a ∧ b ∧ c",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidWithZero.toMonoid",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module",
   "DistribMulAction",
   "AddCommMonoid"],
  "name": "Module.toDistribMulAction",
  "constType":
  "{R : Type u} →\n  {M : Type v} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [self : Module R M] → DistribMulAction R M",
  "constCategory": "Definition"},
 {"references":
  ["CyclotomicField.algebra",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "DivisionRing.toRing",
   "algebraMap",
   "Semifield.toCommSemiring",
   "ValuationRing.localRing",
   "Field.toSemifield",
   "EuclideanDomain.toCommRing",
   "CyclotomicField",
   "RingHom.injective",
   "LocalRing.toNontrivial",
   "CyclotomicField.instField",
   "Field.isDomain",
   "DivisionSemiring.toSemiring",
   "ValuationRing.of_field",
   "CharZero",
   "Field.toEuclideanDomain",
   "Field",
   "Semifield.toDivisionSemiring",
   "Field.toDivisionRing",
   "PNat",
   "charZero_of_injective_algebraMap"],
  "name": "CyclotomicField.instCharZero",
  "constType":
  "∀ (n : ℕ+) (K : Type w) [inst : Field K] [inst_1 : CharZero K], CharZero (CyclotomicField n K)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "Iff",
   "Ring.toAddGroupWithOne",
   "instNatCastInt",
   "Int.cast",
   "Int.ModEq",
   "Ring.toIntCast",
   "ZMod.charP",
   "CommRing.toRing",
   "Nat",
   "Int",
   "ZMod",
   "CharP.intCast_eq_intCast",
   "Eq",
   "ZMod.commRing"],
  "name": "ZMod.intCast_eq_intCast_iff",
  "constType": "∀ (a b : ℤ) (c : ℕ), ↑a = ↑b ↔ a ≡ b [ZMOD ↑c]",
  "constCategory": "Theorem"},
 {"references":
  ["Rat.instNormedField.proof_1",
   "NormedAddCommGroup.toMetricSpace",
   "NormedAddCommGroup",
   "Rat.instField",
   "Rat.instNormedAddCommGroup",
   "NormedField",
   "NormedField.mk",
   "Field",
   "Rat",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm"],
  "name": "Rat.instNormedField",
  "constType": "NormedField ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "OfNat.ofNat",
   "Fin.val",
   "Exists.intro",
   "Exists.casesOn",
   "instLTNat",
   "LE.le",
   "FltRegular.auxf'",
   "Finset.mem_range",
   "Finset.instMembership",
   "Eq",
   "And",
   "Iff.mp",
   "instLENat",
   "Finset.range",
   "LT.lt",
   "Finset",
   "instOfNatNat",
   "Nat",
   "FltRegular.f",
   "And.casesOn",
   "Int",
   "instOfNat",
   "Fin.mk",
   "Fin"],
  "name": "FltRegular.auxf",
  "constType":
  "∀ {p : ℕ}, 5 ≤ p → ∀ (a b : ℤ) (k₁ k₂ : Fin p), ∃ i, FltRegular.f a b ↑k₁ ↑k₂ ↑i = 0",
  "constCategory": "Theorem"},
 {"references": ["Fact"],
  "name": "Fact.mk",
  "constType": "∀ {p : Prop}, p → Fact p",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Set.instMembership",
   "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.1",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["True.intro", "forall_prop_of_true", "Iff", "True"],
  "name": "forall_true_left",
  "constType": "∀ (p : True → Prop), (∀ (x : True), p x) ↔ p True.intro",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Semiring.mk",
   "Int.zero_mul",
   "Monoid.toOne",
   "SubNegMonoid.toNeg",
   "Int.instCommRing.proof_3",
   "Int.instCommRing.proof_6",
   "CommSemigroup",
   "Int.instCommRing.proof_11",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "Int.instCommRing.proof_2",
   "CommRing",
   "CommRing.mk",
   "Int.mul_one",
   "Int.instCommRing.proof_12",
   "SubNegMonoid.toSub",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Int.instCommRing.proof_5",
   "Int.one_mul",
   "Int.instCommSemigroup",
   "AddCommGroup.toAddGroup",
   "Int.instCommRing.proof_7",
   "Nat",
   "HPow.hPow",
   "Int.instCommRing.proof_10",
   "AddCommGroup.add_comm",
   "Int.instHPowNat",
   "Int.mul_add",
   "Int.instMonoid",
   "Int.instCommRing.proof_9",
   "Int.instCommRing.proof_1",
   "Int.instCommRing.proof_8",
   "AddGroup.toSubNegMonoid",
   "CommSemigroup.toSemigroup",
   "Int.mul_zero",
   "CommSemigroup.mul_comm",
   "IntCast.mk",
   "instNatCastInt",
   "NonUnitalSemiring.mk",
   "Int.instAddCommGroup",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "Int.add_mul",
   "Ring.mk",
   "AddCommGroup",
   "Int",
   "Int.instCommRing.proof_4"],
  "name": "Int.instCommRing",
  "constType": "CommRing ℤ",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_7",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_2",
   "Lean.Name.mkStr4",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_1",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_3"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["add_lt_add_iff_right",
   "Function.swap",
   "propext",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "ContravariantClass",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.18",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b c : α},\n  (b + a < c + a) = (b < c)",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "EStateM.tryCatch",
   "EStateM.Backtrackable",
   "MonadExceptOf",
   "EStateM.throw",
   "MonadExceptOf.mk"],
  "name": "EStateM.instMonadExceptOfOfBacktrackable",
  "constType":
  "{ε σ δ : Type u} → [inst : EStateM.Backtrackable δ σ] → MonadExceptOf ε (EStateM ε σ)",
  "constCategory": "Definition"},
 {"references": ["Monoid", "DivInvMonoid"],
  "name": "DivInvMonoid.toMonoid",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Monoid G",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddGroupWithOne.toSub",
   "AddGroupWithOne.toIntCast",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Int.cast_add",
   "AddGroupWithOne.toAddGroup",
   "Int.instAdd",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "AddMonoid.toAddSemigroup",
   "Int.cast_neg",
   "AddGroupWithOne",
   "Int.instNegInt",
   "Int.instSub",
   "Eq.trans",
   "instHSub",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "AddGroup.toSubNegMonoid",
   "of_eq_true",
   "Int.cast",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg",
   "Int"],
  "name": "Int.cast_sub",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℤ), ↑(m - n) = ↑m - ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["eq_true",
   "Fin.val",
   "LT.lt",
   "Fin.is_lt",
   "Nat",
   "instLTNat",
   "True",
   "Fin",
   "Eq"],
  "name": "FltRegular.CaseI.Statement._auxLemma.11",
  "constType": "∀ {n : ℕ} (a : Fin n), (↑a < n) = True",
  "constCategory": "Theorem"},
 {"references": ["One", "OfNat", "OfNat.mk", "One.one"],
  "name": "One.toOfNat1",
  "constType": "{α : Type u_1} → [inst : One α] → OfNat α 1",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_33",
   "_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_12",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_34._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_12"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Units",
   "Units.instOne",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "Units.val",
   "One.toOfNat1",
   "rfl",
   "Eq"],
  "name": "Units.val_one",
  "constType": "∀ {α : Type u} [inst : Monoid α], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Lean.TSyntax", "Lean.SyntaxNodeKinds", "Lean.Syntax"],
  "name": "Lean.TSyntax.raw",
  "constType": "{ks : Lean.SyntaxNodeKinds} → Lean.TSyntax ks → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "DivInvMonoid",
   "Eq.refl",
   "DivInvMonoid.Pow",
   "DivInvMonoid.toMonoid",
   "pow_one",
   "Eq",
   "zpow_ofNat",
   "Eq.mpr",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Int",
   "instOfNat",
   "id"],
  "name": "zpow_one",
  "constType": "∀ {G : Type u_1} [inst : DivInvMonoid G] (a : G), a ^ 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["Polynomial",
   "Finsupp.instFunLike",
   "Finsupp",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "MonoidWithZero.toZero",
   "DFunLike.coe",
   "Nat",
   "Polynomial.support.match_1",
   "AddMonoidAlgebra"],
  "name": "Polynomial.coeff",
  "constType": "{R : Type u} → [inst : Semiring R] → Polynomial R → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_15",
   "Lean.ParserDescr.symbol"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_16._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "exists_eq_right", "propext", "Eq"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.6",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') = p a'",
  "constCategory": "Theorem"},
 {"references": ["Prod.exists", "Exists", "Prod.mk", "propext", "Prod", "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.12",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {p : α × β → Prop}, (∃ x, p x) = ∃ a b, p (a, b)",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Zero.ofOfNat0",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.cast_ne_zero",
   "Iff.mpr",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "NeZero.mk",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "NeZero.out"],
  "name": "NeZero.charZero",
  "constType":
  "∀ {M : Type u_2} {n : ℕ} [inst : NeZero n] [inst : AddMonoidWithOne M] [inst_1 : CharZero M], NeZero ↑n",
  "constCategory": "Definition"},
 {"references":
  ["AddCancelCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "AddCancelMonoid",
   "IsRightCancelAdd",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_1",
   "AddCancelCommMonoid.toAddLeftCancelMonoid",
   "AddCancelMonoid.mk",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCancelCommMonoid.toAddCancelMonoid.proof_2",
   "AddCancelCommMonoid.toAddCommMonoid"],
  "name": "AddCancelCommMonoid.toAddCancelMonoid",
  "constType":
  "(M : Type u) → [inst : AddCancelCommMonoid M] → AddCancelMonoid M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddGroupWithOne",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "One.toOfNat1",
   "zero_lt_one",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "one_pos",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references": ["Subgroup", "Group"],
  "name": "Subgroup.Normal",
  "constType": "{G : Type u_1} → [inst : Group G] → Subgroup G → Prop",
  "constCategory": "Other"},
 {"references":
  ["Bool.false",
   "Lean.replaceRef.match_1",
   "Lean.Syntax",
   "Lean.Syntax.getPos?",
   "String.Pos",
   "Option"],
  "name": "Lean.replaceRef",
  "constType": "Lean.Syntax → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "mul_pow",
   "instHMul",
   "MulOneClass.toMul",
   "CommMonoid",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "CommMonoid.toMonoid",
   "Nat",
   "Eq.symm",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.20",
  "constType":
  "∀ {M : Type u_4} [inst : CommMonoid M] (a b : M) (n : ℕ), a ^ n * b ^ n = (a * b) ^ n",
  "constCategory": "Theorem"},
 {"references": ["InvolutiveNeg", "Neg"],
  "name": "InvolutiveNeg.toNeg",
  "constType": "{A : Type u_2} → [self : InvolutiveNeg A] → Neg A",
  "constCategory": "Definition"},
 {"references":
  ["Lean.withRef",
   "Lean.Syntax.matchesNull",
   "EStateM",
   "cond",
   "OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "Lean.TSyntax",
   "EStateM.instMonad",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node1",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Bind.bind",
   "Nat",
   "Lean.Name.anonymous",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.TSyntax.mk",
   "Lean.MonadQuotation.toMonadRef",
   "instMonadExceptOfMonadExceptOf",
   "Lean.Syntax.atom",
   "ReaderT.instMonadExceptOf",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "EStateM.instMonadExceptOfOfBacktrackable",
   "Lean.MacroScope",
   "Lean.MonadRef.mkInfoFromRefPos",
   "or",
   "ReaderT.instApplicativeOfMonad",
   "Lean.MonadQuotation.getMainModule",
   "Bool.false",
   "Lean.PrettyPrinter.UnexpandM",
   "letFun",
   "Lean.Name.mkNum",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "ReaderT.instMonad",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___unexpand_CyclotomicField_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_product",
   "And",
   "Prod.snd",
   "Iff",
   "Finset.instSProd",
   "SProd.sprod",
   "Finset",
   "Finset.val",
   "Prod",
   "Prod.fst",
   "Finset.instMembership"],
  "name": "Finset.mem_product",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {t : Finset β} {p : α × β}, p ∈ s ×ˢ t ↔ p.1 ∈ s ∧ p.2 ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "MonoidWithZero.toMulZeroOneClass",
   "Units",
   "OfNat.ofNat",
   "Units.instInv",
   "left_ne_zero_of_mul_eq_one",
   "MonoidWithZero.toMonoid",
   "Units.val",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Units.mul_inv",
   "Inv.inv",
   "MonoidWithZero"],
  "name": "Units.ne_zero",
  "constType":
  "∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] [inst_1 : Nontrivial M₀] (u : M₀ˣ), ↑u ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "propext",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Nat.cast_eq_zero",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.1",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, (↑n = 0) = (n = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["algebraInt.proof_2",
   "Ring.toAddGroupWithOne",
   "Int.castRingHom",
   "algebraInt.proof_1",
   "Algebra",
   "Ring",
   "Algebra.mk",
   "SubNegMonoid.SMulInt",
   "Ring.toSemiring",
   "Int.instCommSemiring",
   "AddGroup.toSubNegMonoid",
   "Int",
   "Ring.toNonAssocRing",
   "AddGroupWithOne.toAddGroup"],
  "name": "algebraInt",
  "constType": "(R : Type u_1) → [inst : Ring R] → Algebra ℤ R",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Exists",
   "PartialOrder.toPreorder",
   "StarOrderedRing.toExistsAddOfLE.match_1",
   "NonUnitalSemiring",
   "HAdd.hAdd",
   "StarOrderedRing.le_iff",
   "AddCommMonoid.toAddMonoid",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "ExistsAddOfLE",
   "Preorder.toLE",
   "SetLike.instMembership",
   "AddSubmonoid.closure",
   "Eq",
   "Set.range",
   "Iff.mp",
   "InvolutiveStar.toStar",
   "StarRing",
   "Membership.mem",
   "Star.star",
   "StarOrderedRing",
   "instHAdd",
   "NonUnitalNonAssocSemiring.toMul",
   "AddSubmonoid.instSetLike",
   "AddSubmonoid",
   "LE.le",
   "NonUnitalNonAssocSemiring.toDistrib",
   "PartialOrder",
   "And",
   "instHMul",
   "StarRing.toStarAddMonoid",
   "HMul.hMul",
   "ExistsAddOfLE.mk",
   "StarAddMonoid.toInvolutiveStar",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring"],
  "name": "StarOrderedRing.toExistsAddOfLE",
  "constType":
  "∀ {R : Type u} [inst : NonUnitalSemiring R] [inst_1 : PartialOrder R] [inst_2 : StarRing R]\n  [inst_3 : StarOrderedRing R], ExistsAddOfLE R",
  "constCategory": "Definition"},
 {"references":
  ["AddLeftCancelMonoid.toZero",
   "AddLeftCancelMonoid.add_zero",
   "AddLeftCancelMonoid.nsmul_zero",
   "AddLeftCancelMonoid.nsmul",
   "AddLeftCancelSemigroup.toAddSemigroup",
   "AddLeftCancelMonoid.zero_add",
   "AddLeftCancelMonoid.nsmul_succ",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "AddLeftCancelMonoid",
   "AddMonoid",
   "AddMonoid.mk"],
  "name": "AddLeftCancelMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddLeftCancelMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Exists",
  "constType": "{α : Sort u} → (α → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "ZeroMemClass",
   "Zero",
   "OfNat.ofNat",
   "SetLike",
   "Zero.mk",
   "ZeroMemClass.zero_mem",
   "Subtype.mk",
   "SetLike.instMembership",
   "Subtype"],
  "name": "ZeroMemClass.zero",
  "constType":
  "{A : Type u_4} →\n  {M₁ : Type u_5} → [inst : SetLike A M₁] → [inst_1 : Zero M₁] → [hA : ZeroMemClass A M₁] → (S' : A) → Zero ↥S'",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "True",
   "Nat.cast_mul",
   "Semiring.toNatCast",
   "Eq",
   "PProd",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "PUnit",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.succ",
   "Nat.cast_one",
   "id",
   "HPow.hPow",
   "eq_self",
   "Nat.below",
   "Nat.brecOn",
   "instAddNat",
   "instHAdd",
   "Semiring",
   "Unit",
   "Nat.cast_pow.match_1",
   "One.toOfNat1",
   "pow_succ'",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Monoid.toMulOneClass",
   "pow_zero",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Nat.instMonoid",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "congr",
   "instMulNat",
   "congrArg"],
  "name": "Nat.cast_pow",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] (m n : ℕ), ↑(m ^ n) = ↑m ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Membership.mem",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "One.toOfNat1",
   "instLTNat",
   "CommRing",
   "Iff.mpr",
   "Finset.instMembership",
   "Eq",
   "Semiring.toOne",
   "Polynomial.nthRootsFinset",
   "CommRing.toCommSemiring",
   "CommRing.toCommMonoid",
   "MonoidWithZero.toMonoid",
   "Polynomial.mem_nthRootsFinset",
   "instHPow",
   "LT.lt",
   "IsPrimitiveRoot.pow_eq_one",
   "Finset",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat"],
  "name": "IsPrimitiveRoot.mem_nthRootsFinset",
  "constType":
  "∀ {R : Type u_4} {k : ℕ} {ζ : R} [inst : CommRing R] [inst_1 : IsDomain R],\n  IsPrimitiveRoot ζ k → 0 < k → ζ ∈ Polynomial.nthRootsFinset k R",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NonUnitalCommSemiring.toCommSemigroup",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "CommSemigroup.toCommMagma",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "congrArg",
   "mul_left_comm",
   "id"],
  "name": "Mathlib.Tactic.Ring.mul_pf_right",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₃ c : R} (b₁ : R) (b₂ : ℕ), a * b₃ = c → a * (b₁ ^ b₂ * b₃) = b₁ ^ b₂ * c",
  "constCategory": "Theorem"},
 {"references": ["Int.ofNat", "_obj"],
  "name": "FltRegular.CaseI.f0k₁._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "eq_true",
   "PNat.pos",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "True",
   "Eq",
   "PNat"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.12",
  "constType": "∀ (n : ℕ+), (0 < ↑n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Multiset.map.proof_1",
   "Setoid.r",
   "List",
   "List.isSetoid",
   "Multiset",
   "List.map",
   "Multiset.ofList"],
  "name": "Multiset.map",
  "constType":
  "{α : Type u_1} → {β : Type v} → (α → β) → Multiset α → Multiset β",
  "constCategory": "Definition"},
 {"references": ["CommMagma", "Mul"],
  "name": "CommMagma.toMul",
  "constType": "{G : Type u} → [self : CommMagma G] → Mul G",
  "constCategory": "Definition"},
 {"references":
  ["MulAction.mem_stabilizer_iff",
   "Membership.mem",
   "MulAction.toSMul",
   "instHSMul",
   "propext",
   "HSMul.hSMul",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "MulAction.stabilizer",
   "DivInvMonoid.toMonoid",
   "MulAction",
   "Subgroup.instSetLike",
   "SetLike.instMembership",
   "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.15",
  "constType":
  "∀ {G : Type u_1} {α : Type u_2} [inst : Group G] [inst_1 : MulAction G α] {a : α} {g : G},\n  (g ∈ MulAction.stabilizer G a) = (g • a = a)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Monoid.toSemigroup",
   "IsUnit.dvd_mul_right",
   "MulOneClass.toMul",
   "Monoid",
   "propext",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "IsUnit",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Mathlib.Algebra.Divisibility.Units._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] {a b u : α}, IsUnit u → (a ∣ b * u) = (a ∣ b)",
  "constCategory": "Theorem"},
 {"references": ["cast", "HEq", "letFun", "HEq.rec", "rfl", "Eq"],
  "name": "eq_of_heq",
  "constType": "∀ {α : Sort u} {a a' : α}, HEq a a' → a = a'",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "eq_true",
   "OfNat.ofNat",
   "NeZero",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "zero_lt_one",
   "One.toOfNat1",
   "True",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "Mathlib.Algebra.Order.ZeroLEOne._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], (0 < 1) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Or",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references":
  ["Array.mkArray2",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node2",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Lean.Syntax → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references": [],
  "name": "MonoidWithZero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["NonUnitalNonAssocRing", "AddCommGroup"],
  "name": "NonUnitalNonAssocRing.toAddCommGroup",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocRing α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "Fin.decLt",
   "instOfNatNat",
   "Fin.castSucc",
   "Nat",
   "Fin.succ",
   "instLTFin",
   "Fin",
   "ite"],
  "name": "Fin.succAbove",
  "constType": "{n : ℕ} → Fin (n + 1) → Fin n → Fin (n + 1)",
  "constCategory": "Definition"},
 {"references": ["NonUnitalSemiring", "NonUnitalCommSemiring"],
  "name": "NonUnitalCommSemiring.toNonUnitalSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalCommSemiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.Name.num._override",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["NoZeroDivisors",
   "IsDomain.toIsCancelMulZero",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsCancelMulZero.toIsRightCancelMulZero",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "IsRightCancelMulZero.to_noZeroDivisors",
   "Ring",
   "MulZeroClass.toZero",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "MonoidWithZero.toZero",
   "Ring.toSemiring",
   "Ring.toNonAssocRing"],
  "name": "IsDomain.to_noZeroDivisors",
  "constType":
  "∀ (α : Type u_2) [inst : Ring α] [inst_1 : IsDomain α], NoZeroDivisors α",
  "constCategory": "Definition"},
 {"references": ["NatCast", "Nat", "NatCast.natCast"],
  "name": "Nat.cast",
  "constType": "{R : Type u} → [inst : NatCast R] → ℕ → R",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.natCast_zero",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "Nat.cast_zero",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references": ["MulZeroClass", "Mul"],
  "name": "MulZeroClass.toMul",
  "constType": "{M₀ : Type u} → [self : MulZeroClass M₀] → Mul M₀",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "Nat", "Nat.decEq"],
  "name": "instDecidableEqNat",
  "constType": "DecidableEq ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "EStateM.Result",
  "constType": "Type u → Type u → Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddCommMagma",
   "AddSemigroup.toAdd",
   "AddCommSemigroup",
   "AddCommSemigroup.toAddSemigroup",
   "AddCommMagma.mk",
   "AddCommSemigroup.add_comm"],
  "name": "AddCommSemigroup.toAddCommMagma",
  "constType": "{G : Type u} → [self : AddCommSemigroup G] → AddCommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_12",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_11"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Equiv",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["Bot",
   "Subgroup.mk",
   "Bot.bot",
   "Submonoid",
   "Subgroup",
   "Bot.mk",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Submonoid.instBot",
   "Subgroup.instBot.proof_1"],
  "name": "Subgroup.instBot",
  "constType": "{G : Type u_1} → [inst : Group G] → Bot (Subgroup G)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "trivial", "Set", "Set.instMembership", "Set.univ"],
  "name": "Set.mem_univ",
  "constType": "∀ {α : Type u} (x : α), x ∈ Set.univ",
  "constCategory": "Theorem"},
 {"references": ["Nat.mod", "Mod.mk", "Nat", "Mod"],
  "name": "Nat.instMod",
  "constType": "Mod ℕ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Bool",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "eq_false",
   "OfNat.ofNat",
   "NeZero",
   "False",
   "One",
   "one_ne_zero",
   "One.toOfNat1",
   "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.28",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], (1 = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Equiv",
   "Equiv.exists_congr_left",
   "Exists",
   "funext",
   "mul_neg",
   "HasDistribNeg",
   "Neg.neg",
   "Dvd.dvd",
   "semigroupDvd",
   "True",
   "iff_self",
   "Eq",
   "instHMul",
   "Iff",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "Equiv.neg",
   "HMul.hMul",
   "Equiv.instFunLike",
   "Iff.trans",
   "DFunLike.coe",
   "congrArg",
   "Eq.trans",
   "Semigroup",
   "Mathlib.Algebra.Ring.Divisibility.Basic._auxLemma.3",
   "Equiv.symm"],
  "name": "dvd_neg",
  "constType":
  "∀ {α : Type u_1} [inst : Semigroup α] [inst_1 : HasDistribNeg α] {a b : α}, a ∣ -b ↔ a ∣ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "List",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["OrderTop.toTop",
   "eq_true",
   "Top.top",
   "le_top",
   "OrderTop",
   "LE",
   "LE.le",
   "True",
   "Eq"],
  "name": "FltRegular.CaseII.AuxLemmas._auxLemma.5",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, (a ≤ ⊤) = True",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "NonAssocRing",
   "Int.instSemiring",
   "NonAssocRing.toAddCommGroupWithOne",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "map_one",
   "NonAssocSemiring.toMulZeroOneClass",
   "Eq",
   "Semiring.toOne",
   "NonAssocRing.toIntCast",
   "Semiring.toNonAssocSemiring",
   "RingHomClass.toAddMonoidHomClass",
   "RingHomClass.toMonoidHomClass",
   "FunLike",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "MonoidHomClass.toOneHomClass",
   "DFunLike.coe",
   "eq_intCast'",
   "NonAssocRing.toNonAssocSemiring",
   "Int",
   "AddCommGroupWithOne.toAddGroupWithOne"],
  "name": "eq_intCast",
  "constType":
  "∀ {F : Type u_1} {α : Type u_3} [inst : NonAssocRing α] [inst_1 : FunLike F ℤ α] [inst_2 : RingHomClass F ℤ α] (f : F)\n  (n : ℤ), f n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "Int.negOfNat",
   "Int.neg.match_1",
   "Nat",
   "Nat.succ",
   "Int"],
  "name": "Int.neg",
  "constType": "ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "of_decide_eq_true",
   "Nat.cast_ne_zero",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "instDecidableEqNat",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "NeZero",
   "NeZero.mk",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "AddMonoidWithOne.toOne",
   "instDecidableNot",
   "propext",
   "Bool.true",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Bool",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Nat.cast_one",
   "id"],
  "name": "NeZero.charZero_one",
  "constType":
  "∀ {M : Type u_2} [inst : AddMonoidWithOne M] [inst_1 : CharZero M], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Monoid.toNatPow",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.pow_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' c : R} {b b' : ℕ}, a = a' → b = b' → a' ^ b' = c → a ^ b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Subtype.coe_inj", "propext", "Subtype.val", "Eq.symm", "Subtype", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.9",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, (a = b) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references": ["AddGroup", "AddCommGroup"],
  "name": "AddCommGroup.toAddGroup",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddGroup G",
  "constCategory": "Definition"},
 {"references":
  ["False",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "absurd"],
  "name": "instDecidableNot",
  "constType": "{p : Prop} → [dp : Decidable p] → Decidable ¬p",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "IsPrimitiveRoot",
   "Subalgebra",
   "EuclideanDomain.toCommRing",
   "algebraInt",
   "IsPrimitiveRoot.toInteger.proof_1",
   "integralClosure",
   "Subalgebra.instSetLike",
   "SetLike.instMembership",
   "PNat.val",
   "CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "Field.toEuclideanDomain",
   "Field",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Int",
   "Subtype.mk",
   "PNat"],
  "name": "IsPrimitiveRoot.toInteger",
  "constType":
  "{K : Type u} → [inst : Field K] → {ζ : K} → {k : ℕ+} → IsPrimitiveRoot ζ ↑k → NumberField.RingOfIntegers K",
  "constCategory": "Definition"},
 {"references":
  ["Polynomial.smulZeroClass",
   "Polynomial.zero",
   "Polynomial",
   "instHSMul",
   "Semiring",
   "Polynomial.coeff",
   "Polynomial.coeff_smul",
   "HSMul.hSMul",
   "Semiring.toMonoidWithZero",
   "SMulZeroClass",
   "Nat",
   "MonoidWithZero.toZero",
   "Eq.symm",
   "Eq",
   "SMulZeroClass.toSMul"],
  "name": "FltRegular.NumberTheory.KummersLemma.Field._auxLemma.4",
  "constType":
  "∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : SMulZeroClass S R] (r : S) (p : Polynomial R) (n : ℕ),\n  r • p.coeff n = (r • p).coeff n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddGroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["propext", "forall_apply_eq_imp_iff₂", "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.6",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : α → Prop} {q : β → Prop},\n  (∀ (b : β) (a : α), p a → f a = b → q b) = ∀ (a : α), p a → q (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["Monoid.toSemigroup",
   "eq_true",
   "Monoid",
   "dvd_refl",
   "Dvd.dvd",
   "semigroupDvd",
   "True",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.10",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a : α), (a ∣ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Int.add_le_add_right",
   "HSub.hSub",
   "Neg.neg",
   "LE.le",
   "Int.instAdd",
   "letFun",
   "Eq.mp",
   "Int.instNegInt",
   "Int.add_right_neg",
   "Int.instSub",
   "congrArg",
   "Int",
   "instOfNat",
   "Int.instLEInt"],
  "name": "Int.sub_nonneg_of_le",
  "constType": "∀ {a b : ℤ}, b ≤ a → 0 ≤ a - b",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalSeminormedCommRing",
   "NonUnitalSeminormedCommRing.toNonUnitalSeminormedRing",
   "NonUnitalCommRing.mk",
   "NonUnitalSeminormedCommRing.mul_comm",
   "NonUnitalSeminormedRing.toNonUnitalRing"],
  "name": "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
  "constType":
  "{α : Type u_1} → [β : NonUnitalSeminormedCommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "Submodule",
   "Submodule.Quotient.mk",
   "AddCommGroup.toAddCommMonoid",
   "Ring.toSemiring",
   "Submodule.Quotient.instZeroQuotient",
   "SetLike.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "propext",
   "Ring",
   "Submodule.hasQuotient",
   "Submodule.Quotient.mk_eq_zero",
   "AddCommGroup",
   "Module",
   "HasQuotient.Quotient",
   "Submodule.setLike"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.10",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} {x : M} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (p : Submodule R M), (Submodule.Quotient.mk x = 0) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["FermatLastTheoremFor",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "PartialOrder.toPreorder",
   "FermatLastTheoremForThreeGen.Solution.isMinimal",
   "algebraRat",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "Set.Elem",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "instOfNatPNatOfNeZeroNat",
   "NormedCommRing.toNormedRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.instRing",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CyclotomicField",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "CommRing.toCommMonoid",
   "FermatLastTheoremForThreeGen.Solution.exists_Solution_multiplicity_lt",
   "False.elim",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "NumberField",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Field.toDivisionRing",
   "Finite.of_fintype",
   "Int",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Int.instAddGroup",
   "sub_nonpos_of_le",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Int.instSemiring",
   "IsCyclotomicExtension.numberField",
   "Set",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Int.rawCast",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "NeZero.one",
   "semigroupDvd",
   "AddMonoid.toAddZeroClass",
   "NeZero.pnat",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "CyclotomicField.instField",
   "Field.toCommRing",
   "FermatLastTheoremForThreeGen.Solution'.multiplicity",
   "Int.add_one_le_iff",
   "Int.instAddMonoid",
   "Int.instCovariantClassAddLE",
   "AddMonoid.toAddSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "zero_lt_one",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NeZero.charZero",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalNonAssocRing.toMul",
   "covariant_swap_add_of_covariant_add",
   "Ring.toAddGroupWithOne",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "Neg.neg",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "FermatLastTheoremForThreeGen.Solution'.mk",
   "LE.le",
   "CommRing.toCommSemiring",
   "Units",
   "Int.instLinearOrderedCommRing",
   "instNatCastInt",
   "letFun",
   "Mathlib.Tactic.Ring.atom_pf",
   "NegZeroClass.toNeg",
   "Rat.instNormedField",
   "FermatLastTheoremForThreeGen.proof_1",
   "PNat",
   "CyclotomicField.instCharZero",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "IsCoprime",
   "Exists.casesOn",
   "instLTNat",
   "Preorder.toLE",
   "FermatLastTheoremForThreeGen.Solution.multiplicity",
   "Int.instAdd",
   "IsCyclotomicExtension.zeta",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "FermatLastTheoremForThree_of_FermatLastTheoremThreeGen",
   "Nat",
   "NormedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Ne",
   "neg_neg_of_pos",
   "Set.fintypeSingleton",
   "FermatLastTheoremForThreeGen.Solution'",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.rawCast",
   "Classical.propDecidable",
   "IsCyclotomicExtension.zeta_spec",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Zify._auxLemma.3",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instLTInt",
   "Int.instAddCommSemigroup",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "CommRing.toRing",
   "Not",
   "Singleton.singleton",
   "congrArg",
   "Int.instLEInt",
   "FermatLastTheoremForThreeGen.exists_Solution_of_Solution'",
   "FermatLastTheoremForThreeGen.Solution",
   "OrderedAddCommGroup.toAddCommGroup",
   "Int.ofNat",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Linarith.lt_irrefl",
   "LinearOrderedRing.toStrictOrderedRing",
   "FermatLastTheoremForThreeGen.Solution.exists_minimal",
   "CommRing.toNonUnitalCommRing",
   "NumberField.RingOfIntegers.instCommRing",
   "Mathlib.Tactic.Zify._auxLemma.2",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instLENat",
   "IsPrimitiveRoot.toInteger",
   "instHPow",
   "Preorder.toLT",
   "Ring.toSub",
   "instOfNatNat",
   "add_lt_of_neg_of_le",
   "CommSemiring.toCommMonoidWithZero",
   "id",
   "Rat.numberField",
   "NeZero.succ",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "Rat.instField",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "CyclotomicField.isCyclotomicExtension",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Rat",
   "Dvd.dvd",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "NonUnitalNonAssocSemiring.toMul",
   "AddGroup.toSubNegMonoid",
   "Rat.instCharZero",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "OrderedCommSemiring.toOrderedSemiring",
   "Units.val",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "NumberField.RingOfIntegers",
   "Int.instCommSemiring",
   "Int.instNontrivial"],
  "name": "fermatLastTheoremThree",
  "constType": "FermatLastTheoremFor 3",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.map",
   "Finset.univ",
   "Fintype",
   "Set.Elem",
   "Set",
   "Finset",
   "Function.Embedding.subtype",
   "Set.instMembership",
   "Subtype"],
  "name": "Set.toFinset",
  "constType": "{α : Type u_1} → (s : Set α) → [inst : Fintype ↑s] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "_neutral",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "UInt8",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "_obj",
   "Lean.Name.num._override",
   "Lean.Syntax.node1",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termR_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Function.swap",
   "Iff",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "rel_iff_cov",
   "CovariantClass",
   "LT",
   "Add",
   "ContravariantClass"],
  "name": "add_lt_add_iff_right",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b c : α},\n  b + a < c + a ↔ b < c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Finset.instHasSubset",
   "HasSubset.Subset.trans",
   "Finset.mem_biUnion",
   "HasSubset.Subset",
   "Finset.subset_biUnion_of_mem",
   "Finset.disjiUnion_cons.match_1",
   "Finset.instMembership",
   "Finset.instIsTransSubset",
   "Iff.intro",
   "And",
   "Finset.biUnion",
   "Iff.mp",
   "Iff",
   "DecidableEq",
   "Finset"],
  "name": "Finset.biUnion_subset_iff_forall_subset",
  "constType":
  "∀ {α : Type u_4} {β : Type u_5} [inst : DecidableEq β] {s : Finset α} {t : Finset β} {f : α → Finset β},\n  s.biUnion f ⊆ t ↔ ∀ x ∈ s, f x ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "Distrib.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "LT.lt.ne'",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "NoZeroDivisors.mk",
   "Eq.refl",
   "And.left",
   "ExistsAddOfLE",
   "implies_congr",
   "MulZeroClass.toMul",
   "Preorder.toLE",
   "LT.lt.ne",
   "Eq",
   "Zero.toOfNat0",
   "OrderedCancelAddCommMonoid.toCancelAddCommMonoid",
   "And.right",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "mul_pos_of_neg_of_neg",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "mul_neg_of_pos_of_neg",
   "MulZeroClass.toZero",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedSemiring.toLinearOrderedAddCommMonoid",
   "mul_neg_of_neg_of_pos",
   "AddCommMonoid.toAddCommSemigroup",
   "contravariant_swap_add_of_contravariant_add",
   "id",
   "Ne.lt_or_lt",
   "Ne",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsCancelAdd.toIsLeftCancelAdd",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "NonUnitalNonAssocSemiring.toMul",
   "Or.casesOn",
   "StrictOrderedSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "NoZeroDivisors",
   "instHMul",
   "And",
   "Mathlib.Tactic.PushNeg.not_or_eq",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "AddCancelMonoid.toIsCancelAdd",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "HMul.hMul",
   "LinearOrderedSemiring",
   "LinearOrder.toPartialOrder",
   "Not",
   "mul_pos",
   "StrictOrderedSemiring.toPosMulStrictMono",
   "Mathlib.Tactic.Contrapose.mtr",
   "MonoidWithZero.toZero",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "LinearOrderedSemiring.noZeroDivisors",
  "constType":
  "∀ {α : Type u} [inst : LinearOrderedSemiring α] [inst_1 : ExistsAddOfLE α], NoZeroDivisors α",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "AddCommMonoid"],
  "name": "OrderedAddCommMonoid.toAddCommMonoid",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalSemiring"],
  "name": "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["MonoidWithZero.toMulZeroOneClass",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Finset",
   "Finset.instSingleton",
   "NormalizedGCDMonoid.toNormalizationMonoid",
   "Singleton.singleton",
   "normalize",
   "Multiset.gcd_singleton",
   "NormalizedGCDMonoid",
   "MonoidWithZeroHom",
   "DFunLike.coe",
   "MonoidWithZeroHom.funLike",
   "Finset.gcd",
   "CancelCommMonoidWithZero",
   "CommMonoidWithZero.toMonoidWithZero",
   "Eq"],
  "name": "Finset.gcd_singleton",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : CancelCommMonoidWithZero α] [inst_1 : NormalizedGCDMonoid α] {f : β → α}\n  {b : β}, {b}.gcd f = normalize (f b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Distrib.toAdd",
   "Associated",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Units.instInv",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Ideal.span",
   "Exists.casesOn",
   "algebraRat",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "instLTNat",
   "ClassGroup",
   "Eq",
   "mul_assoc",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Fintype",
   "Nat.Prime",
   "Set.Elem",
   "MonoidWithZero.toMonoid",
   "Field",
   "Ring.toIntCast",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Eq.trans",
   "Subtype",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "NumberField.RingOfIntegers.instIsDedekindDomain",
   "Nat.Prime.pos",
   "congr_arg",
   "Set.fintypeSingleton",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Submodule.IsPrincipal.mk",
   "CommMagma.toMul",
   "Ideal.submodule_span_eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "of_eq_true",
   "NumberField.RingOfIntegers.instIsDomain",
   "Int.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Eq.mp",
   "congr",
   "CommRing.toRing",
   "Singleton.singleton",
   "Algebra.id",
   "congrArg",
   "Fact",
   "Field.toDivisionRing",
   "Finite.of_fintype",
   "Int",
   "Ideal",
   "Inv.inv",
   "Submodule.IsPrincipal.casesOn",
   "Exists",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Submodule",
   "IsCyclotomicExtension.numberField",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Set",
   "Submodule.idemSemiring",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Fact.out",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "Submodule.span",
   "True",
   "mul_comm",
   "Field.toCommRing",
   "Rat.commRing",
   "Set.instSingletonSet",
   "one_mul",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "FltRegular.CaseI.Statement._auxLemma.5",
   "instHPow",
   "Monoid.toNatPow",
   "Ideal.span_singleton_pow",
   "instOfNatNat",
   "Eq.symm",
   "Submodule.IsPrincipal",
   "Semiring.toModule",
   "id",
   "Rat.numberField",
   "eq_self",
   "Rat.instField",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "Rat",
   "One.toOfNat1",
   "Fintype.card",
   "Monoid.toMulOneClass",
   "IsCyclotomicExtension",
   "Units",
   "CommRing.toCommSemiring",
   "CharZero",
   "Units.val",
   "letFun",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Nat.Coprime",
   "HMul.hMul",
   "IdemSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NumberField.RingOfIntegers",
   "IsPrincipal_of_IsPrincipal_pow_of_Coprime",
   "Units.inv_mul",
   "Subtype.mk",
   "PNat"],
  "name": "FltRegular.is_principal_aux",
  "constType":
  "∀ {p : ℕ} [hpri : Fact (Nat.Prime p)] (K' : Type u_1) [inst : Field K'] [inst_1 : CharZero K']\n  [inst_2 : IsCyclotomicExtension {⟨p, ⋯⟩} ℚ K'] [inst_3 : Fintype (ClassGroup (NumberField.RingOfIntegers K'))]\n  {a b : ℤ} {ζ : NumberField.RingOfIntegers K'},\n  p.Coprime (Fintype.card (ClassGroup (NumberField.RingOfIntegers K'))) →\n    ∀ (I : Ideal (NumberField.RingOfIntegers K')), Ideal.span {↑a + ζ * ↑b} = I ^ p → ∃ u α, ↑u * α ^ p = ↑a + ζ * ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Exists",
   "CommMonoidWithZero.toZero",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "mul_div_assoc'",
   "MulZeroClass.mul_zero",
   "dite",
   "ValuationRing.mk",
   "Semifield.toCommGroupWithZero",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Field",
   "MulZeroClass.toZero",
   "HDiv.hDiv",
   "DivisionRing.toDivInvMonoid",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "DivInvMonoid.toDiv",
   "eq_self",
   "instHDiv",
   "NonUnitalNonAssocRing.toMul",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Or.inr",
   "EuclideanDomain.toMulDivCancelClass",
   "MulOneClass.toOne",
   "Classical.propDecidable",
   "Field.toSemifield",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "mul_div_cancel_left₀",
   "One.toOfNat1",
   "Field.toInv",
   "DivInvMonoid.toMonoid",
   "EuclideanDomain.toCommRing",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "DivisionSemiring.toSemiring",
   "instHMul",
   "Field.isDomain",
   "inv_eq_one_div",
   "Or.inl",
   "of_eq_true",
   "Field.toEuclideanDomain",
   "HMul.hMul",
   "congr",
   "mul_one",
   "Semifield.toDivisionSemiring",
   "Not",
   "Field.toDivisionRing",
   "congrArg",
   "ValuationRing",
   "Inv.inv"],
  "name": "ValuationRing.of_field",
  "constType": "∀ (K : Type u) [inst : Field K], ValuationRing K",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulZeroClass.mul_zero",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.mul_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references": ["Fintype", "Finset", "Fintype.elems"],
  "name": "Finset.univ",
  "constType": "{α : Type u_1} → [inst : Fintype α] → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map",
   "MonoidWithZero.toMulZeroOneClass",
   "UniqueFactorizationMonoid",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "NormalizationMonoid",
   "Multiset",
   "UniqueFactorizationMonoid.factors",
   "normalize",
   "MonoidWithZeroHom",
   "DFunLike.coe",
   "MonoidWithZeroHom.funLike",
   "CancelCommMonoidWithZero",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "UniqueFactorizationMonoid.normalizedFactors",
  "constType":
  "{α : Type u_1} →\n  [inst : CancelCommMonoidWithZero α] →\n    [inst_1 : NormalizationMonoid α] → [inst : UniqueFactorizationMonoid α] → α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["MulZeroClass.mk",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroClass",
   "MulZeroOneClass.mul_zero",
   "MulZeroOneClass.zero_mul",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass"],
  "name": "MulZeroOneClass.toMulZeroClass",
  "constType": "{M₀ : Type u} → [self : MulZeroOneClass M₀] → MulZeroClass M₀",
  "constCategory": "Definition"},
 {"references": ["Classical.not_forall", "Exists", "propext", "Not", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.14",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "DivisionRing.toRing",
   "Semifield.toCommSemiring",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "DivInvMonoid.Pow",
   "Semifield.toCommGroupWithZero",
   "Units.map",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "instHPow",
   "Field",
   "MonoidHom.instMonoidHomClass",
   "Units.instMulOneClass",
   "DFunLike.coe",
   "DivisionRing.toDivInvMonoid",
   "CommGroupWithZero.toDivisionCommMonoid",
   "HPow.hPow",
   "Units.coeHom",
   "algebraMap",
   "Field.toSemifield",
   "MonoidHom.comp",
   "MonoidHomClass.toMonoidHom",
   "MonoidHom",
   "Monoid.toMulOneClass",
   "RingHom.instFunLike",
   "DivisionSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "Units",
   "RingHomClass.toMonoidHomClass",
   "Units.val",
   "letFun",
   "map_zpow",
   "Semifield.toDivisionSemiring",
   "MonoidHom.instFunLike",
   "Algebra.id",
   "Units.instGroup",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Int",
   "Units.instDivInvMonoid",
   "NumberField.RingOfIntegers.instAlgebra_1"],
  "name": "NumberField.Units.coe_zpow",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] (x : (NumberField.RingOfIntegers K)ˣ) (n : ℤ),\n  (algebraMap (NumberField.RingOfIntegers K) K) ↑(x ^ n) = (algebraMap (NumberField.RingOfIntegers K) K) ↑x ^ n",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.fst",
  "constType": "{α : Type u} → {β : Type v} → α × β → α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddCommGroup.toDivisionAddCommMonoid",
   "inferInstance",
   "Ring",
   "Ring.toAddCommGroup",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SubtractionMonoid"],
  "name": "Ring.toSubtractionMonoid",
  "constType": "{S : Type u_1} → [inst : Ring S] → SubtractionMonoid S",
  "constCategory": "Definition"},
 {"references": ["eq_true", "False.elim", "False", "Not", "True", "Eq"],
  "name": "not_false_eq_true",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references": ["And.rec", "And", "And.intro"],
  "name": "And.casesOn",
  "constType":
  "{a b : Prop} → {motive : a ∧ b → Sort u} → (t : a ∧ b) → ((left : a) → (right : b) → motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_9",
   "_obj",
   "Lean.ParserDescr.symbol"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HPow",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "Decidable.casesOn",
   "Decidable",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.decEq",
   "Int",
   "Int.sub",
   "Eq"],
  "name": "FltRegular.CaseI.f0k₂._cstage1",
  "constType": "ℤ → ℤ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Nat.succ_pred_prime",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "SubNegMonoid.toNeg",
   "integralClosure",
   "Subalgebra.instSetLike",
   "NumberField.RingOfIntegers.val",
   "Finset.instMembership",
   "Finset.sum_range",
   "RelIso",
   "lt_trans",
   "IsPrimitiveRoot.integralPowerBasis'_gen",
   "Function.Embedding",
   "instOfNat",
   "Fin.mk",
   "Subtype",
   "RingHomInvPair.ids",
   "IsPrimitiveRoot.coe_submonoidClass_iff",
   "IsPrimitiveRoot.pow_sub_one_eq",
   "Nat.totient_prime",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Fin.last",
   "Set.instMembership",
   "SMulZeroClass.toSMul",
   "Finset.sum_neg_distrib",
   "False.elim",
   "Nat.le_pred_of_lt",
   "NumberField.RingOfIntegers.instIsDomain",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "LinearOrder.toPartialOrder",
   "MonoidWithZero.toZero",
   "Field.toDivisionRing",
   "Function.instFunLikeEmbedding",
   "Int.instSemigroup",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Int.instSemiring",
   "Set",
   "Nat.decLt",
   "Eq.refl",
   "semigroupDvd",
   "Fin.cast",
   "rfl",
   "Basis.repr",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "Pi.Function.module",
   "Basis.equivFun_symm_apply",
   "Decidable.byContradiction",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Neg",
   "Basis.coord_apply",
   "OrderIso",
   "Fin.coe_orderIso_apply",
   "Field.toSemifield",
   "SubmonoidClass.toCommMonoid",
   "Neg.neg",
   "Int.instMonoid",
   "LE.le",
   "Distrib.leftDistribClass",
   "CommRing.toCommSemiring",
   "Eq.ndrec",
   "letFun",
   "Semifield.toDivisionSemiring",
   "not_true_eq_false",
   "NegZeroClass.toNeg",
   "Subtype.mk",
   "PNat",
   "instHSMul",
   "SubtractionCommMonoid.toAddCommMonoid",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "Subalgebra.SubsemiringClass",
   "dvd_mul_right",
   "dite",
   "IsPrimitiveRoot.toInteger.proof_1",
   "IsPrimitiveRoot.isIntegral",
   "Semiring.toNonAssocSemiring",
   "AddCommGroup.intModule",
   "SMulWithZero.toSMulZeroClass",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "RelIso.instFunLike",
   "HPow",
   "Eq.trans",
   "LinearMap.map_sub",
   "Finsupp.instFunLike",
   "Finset.sum_sub_distrib",
   "smul_neg",
   "Int.instDvd",
   "Fin.fintype",
   "Fin.sum_univ_castSucc",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Fin.castSucc",
   "Finsupp.module",
   "SemigroupWithZero.toSemigroup",
   "Finset.univ",
   "PowerBasis",
   "MulActionWithZero.toSMulWithZero",
   "Field.toEuclideanDomain",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "Singleton.singleton",
   "instSubNat",
   "CommRing.toNonUnitalCommRing",
   "dvd_last_coeff_cycl_integer",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Basis.equivFun",
   "LinearEquiv.instFunLike",
   "Pi.addCommMonoid",
   "Set.instSingletonSet",
   "Rat.commRing",
   "IsPrimitiveRoot.toInteger",
   "AddMonoid.toZero",
   "smul_eq_mul",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "DFunLike.coe",
   "Fin.isLt",
   "id",
   "Membership.mem",
   "eq_self",
   "Nat.Prime.one_lt",
   "IsPrimitiveRoot.power_basis_int'_dim",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Finsupp",
   "False",
   "instAddNat",
   "Algebra.toModule",
   "Basis",
   "LinearEquiv",
   "Dvd.dvd",
   "Nat.pred_lt",
   "Ring.toSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "CharZero",
   "zsmul_eq_smul_cast",
   "Nat.instLinearOrder",
   "NonUnitalSemiring.toSemigroupWithZero",
   "NumberField.RingOfIntegers",
   "Equiv",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "AddCommGroup.toAddCommMonoid",
   "instDecidableEqFin",
   "Nat.sub",
   "algebraRat",
   "Mathlib.Tactic.PushNeg.not_lt_eq",
   "AddGroupWithOne.toAddGroup",
   "Iff.mpr",
   "SubNegMonoid.toSub",
   "Nat.Prime",
   "DistribSMul.toSMulZeroClass",
   "Finset.range",
   "Field",
   "HSMul.hSMul",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "LinearMap",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "SubsemiringClass.toSubmonoidClass",
   "Mul.toSMul",
   "instHSub",
   "HPow.hPow",
   "Int.instDistrib",
   "PowerBasis.basis",
   "instLEFin",
   "Module.toMulActionWithZero",
   "CommRing.toCommMonoid",
   "dvd_add",
   "LT.lt",
   "Int.instAddCommGroup",
   "le_antisymm",
   "Finite.of_fintype",
   "Int",
   "Fin",
   "SetLike.coe",
   "Exists",
   "Int.instAddGroup",
   "Nat.instStrictOrderedSemiring",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "Fin.is_lt",
   "AddMonoid.toAddZeroClass",
   "algebraInt",
   "RingHom.id",
   "True",
   "RelIso.toEquiv",
   "Eq.rec",
   "PowerBasis.coe_basis",
   "Basis.coord",
   "Finset",
   "Equiv.sum_comp",
   "Nat.succ",
   "Semiring.toModule",
   "PowerBasis.dim",
   "Ring.toAddGroupWithOne",
   "congr_fun",
   "AddRightCancelMonoid.toZero",
   "Finset.sum",
   "LinearEquiv.symm",
   "Nat.pred_eq_sub_one",
   "SubNegZeroMonoid.toNegZeroClass",
   "IsCyclotomicExtension",
   "Fin.castSuccEmb",
   "Int.instCommRing",
   "Fact.mk",
   "Finset.smul_sum",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.12",
   "Module.toDistribMulAction",
   "Fin.ext",
   "sub_eq_add_neg",
   "Exists.casesOn",
   "instLTNat",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "Finset.sum_add_distrib",
   "Eq.mpr",
   "Ring.toNeg",
   "Nat.Prime.ne_zero",
   "Nat",
   "Finset.sum_congr",
   "Basis.dvd_coord_smul",
   "Nat.totient",
   "DistribMulAction.toDistribSMul",
   "AddCommMonoid",
   "congr_arg",
   "instModuleRingOfIntegers_fltRegular",
   "Fin.val",
   "EuclideanDomain.toCommRing",
   "SubNegMonoid.SMulInt",
   "Basis.coord_equivFun_symm",
   "instHMul",
   "Not",
   "IsPrimitiveRoot.integralPowerBasis'",
   "congrArg",
   "Fact",
   "PNat.pos",
   "DivisionRing.toRing",
   "NumberField.RingOfIntegers.instCommRing",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Fact.out",
   "Subalgebra",
   "LinearMap.instFunLike",
   "AddCommMonoid.toAddMonoid",
   "IsPrimitiveRoot.toInteger.eq_1",
   "Basis.instFunLike",
   "Ring.toNonAssocRing",
   "PowerBasis.gen",
   "PNat.val",
   "Nat.pred",
   "instHPow",
   "Preorder.toLT",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "Equiv.instFunLike",
   "Eq.symm",
   "HAdd",
   "Fin.castOrderIso",
   "funext",
   "HSMul",
   "instHAdd",
   "HSub.hSub",
   "Rat",
   "AddGroup.toSubNegMonoid",
   "Fin.cast_mk",
   "DivisionSemiring.toSemiring",
   "Finsupp.instAddCommMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "NegZeroClass.toZero"],
  "name": "dvd_coeff_cycl_integer",
  "constType":
  "∀ {p : ℕ+} {L : Type u} [inst : Field L] [inst_1 : CharZero L] [inst_2 : IsCyclotomicExtension {p} ℚ L],\n  Nat.Prime ↑p →\n    ∀ {ζ : NumberField.RingOfIntegers L},\n      IsPrimitiveRoot ζ ↑p →\n        ∀ {f : Fin ↑p → ℤ}, (∃ i, f i = 0) → ∀ {m : ℤ}, ↑m ∣ ∑ j : Fin ↑p, f j • ζ ^ ↑j → ∀ (j : Fin ↑p), m ∣ f j",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Int.instDecidableEq",
   "instAddNat",
   "DecidableEq",
   "instHAdd",
   "ZMod.match_1",
   "HAdd.hAdd",
   "Unit",
   "instDecidableEqFin",
   "inferInstanceAs",
   "instOfNatNat",
   "Nat",
   "Int",
   "Fin",
   "ZMod"],
  "name": "ZMod.decidableEq",
  "constType": "(n : ℕ) → DecidableEq (ZMod n)",
  "constCategory": "Definition"},
 {"references": ["trivial", "Or", "eq_true", "Or.inl", "True", "Eq"],
  "name": "true_or",
  "constType": "∀ (p : Prop), (True ∨ p) = True",
  "constCategory": "Theorem"},
 {"references": ["Iff"],
  "name": "Iff.mp",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a → b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.natCast_zero",
   "Semiring.toOne",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_succ",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.one_mul",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring",
   "NonAssocSemiring.mk",
   "Semiring.toNatCast"],
  "name": "Semiring.toNonAssocSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.16",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references": ["Classical.not_not", "propext", "Not", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.3",
  "constType": "∀ {a : Prop}, (¬¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Units",
   "Units.isUnit",
   "eq_true",
   "Monoid",
   "Units.val",
   "IsUnit",
   "True",
   "Eq"],
  "name": "FltRegular.NumberTheory.KummersLemma.KummersLemma._auxLemma.7",
  "constType": "∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ), IsUnit ↑u = True",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_2",
   "_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_5",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["funext", "Subsingleton.intro", "Subsingleton", "Subsingleton.elim"],
  "name": "instSubsingletonForall",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} [inst : ∀ (a : α), Subsingleton (β a)], Subsingleton ((a : α) → β a)",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "MulMemClass.mk",
   "ZeroMemClass.mk",
   "Subalgebra",
   "AddSubmonoidClass.toAddMemClass",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Subalgebra.instSetLike",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "AddSubmonoidClass.mk",
   "AddMemClass.mk",
   "CommSemiring",
   "Algebra",
   "Subsemiring.instSetLike",
   "OneMemClass.mk",
   "ZeroMemClass.zero_mem",
   "SubsemiringClass.addSubmonoidWithOneClass",
   "SubsemiringClass.toSubmonoidClass",
   "SubsemiringClass",
   "Semiring",
   "MulOneClass.toOne",
   "Subsemiring.instSubsemiringClass",
   "AddMonoidWithOne.toAddMonoid",
   "Subsemiring",
   "SubsemiringClass.toAddSubmonoidClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "SubsemiringClass.mk",
   "SubmonoidClass.mk",
   "AddMemClass.add_mem",
   "AddSubmonoidClass.toZeroMemClass",
   "OneMemClass.one_mem",
   "AddMonoidWithOne.toOne",
   "SubmonoidClass.toMulMemClass",
   "MulMemClass.mul_mem",
   "AddSubmonoidWithOneClass.toOneMemClass",
   "Subalgebra.toSubsemiring"],
  "name": "Subalgebra.SubsemiringClass",
  "constType":
  "∀ {R : Type u} {A : Type v} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A],\n  SubsemiringClass (Subalgebra R A) A",
  "constCategory": "Definition"},
 {"references": ["outParam", "HAdd"],
  "name": "HAdd.hAdd",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HAdd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["CommMonoid", "Nat"],
  "name": "IsPrimitiveRoot",
  "constType": "{M : Type u_1} → [inst : CommMonoid M] → M → ℕ → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "CommMonoidWithZero.toZero",
   "Or",
   "OfNat.ofNat",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "GCDMonoid",
   "propext",
   "GCDMonoid.lcm",
   "lcm_eq_zero_iff",
   "CancelCommMonoidWithZero",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.4",
  "constType":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : GCDMonoid α] (a b : α), (lcm a b = 0) = (a = 0 ∨ b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.const",
   "Lean.Omega.Coeffs.dot",
   "instHAdd",
   "Lean.Omega.LinearCombo.coeffs",
   "HAdd.hAdd",
   "Lean.Omega.Coeffs",
   "Int",
   "Lean.Omega.LinearCombo",
   "Int.instAdd"],
  "name": "Lean.Omega.LinearCombo.eval",
  "constType": "Lean.Omega.LinearCombo → Lean.Omega.Coeffs → ℤ",
  "constCategory": "Definition"},
 {"references": ["cond.match_1", "Unit", "Bool"],
  "name": "cond",
  "constType": "{α : Type u} → Bool → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "eq_true",
   "Fintype",
   "Finset",
   "Finset.mem_univ",
   "True",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.9",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (x : α), (x ∈ Finset.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Nat.rawCast",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "one_mul",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one"],
  "name": "Mathlib.Tactic.Ring.one_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), Nat.rawCast 1 * a = a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Ne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "SetLike.instMembership",
   "Eq",
   "nonZeroDivisors",
   "NoZeroDivisors",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "propext",
   "mem_nonZeroDivisors_iff_ne_zero",
   "Submonoid",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Submonoid.instSetLike",
   "MonoidWithZero"],
  "name": "FltRegular.NumberTheory.QuotientTrace._auxLemma.8",
  "constType":
  "∀ {M : Type u_2} [inst : MonoidWithZero M] [inst_1 : NoZeroDivisors M] [inst_2 : Nontrivial M] {x : M},\n  (x ∈ nonZeroDivisors M) = (x ≠ 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "a_eta_zero_dvd_p_pow",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "Ideal.span",
   "algebraRat",
   "MulZeroClass.toMul",
   "Eq",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "Nat",
   "HPow.hPow",
   "instHSub",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "root_div_zeta_sub_one_dvd_gcd",
   "NumberField.to_charZero",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Field.toEuclideanDomain",
   "NumberField.inst_ringOfIntegersAlgebra",
   "NumberField",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Algebra.id",
   "Fact",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ideal",
   "Submodule.idemSemiring",
   "PNat.Prime",
   "Set",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "semigroupDvd",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instHPow",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "zeta_sub_one_dvd_root",
   "Eq.symm",
   "NeZero.succ",
   "instAddNat",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Dvd.dvd",
   "Ring.toSemiring",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "Units.val",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IdemSemiring.toSemiring",
   "NumberField.RingOfIntegers",
   "a_eta_zero_dvd_p_pow_spec",
   "PNat"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.16",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [hpri : Fact p.Prime] [inst : Field K] [inst_1 : NumberField K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K] (hp : p ≠ 2) {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p)\n  {x y z : NumberField.RingOfIntegers K} {ε : (NumberField.RingOfIntegers K)ˣ} {m : ℕ}\n  (e : x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p) (hy : ¬↑hζ.unit' - 1 ∣ y),\n  root_div_zeta_sub_one_dvd_gcd hp hζ e hy (zeta_sub_one_dvd_root hp hζ e hy) =\n    Ideal.span {↑hζ.unit' - 1} ^ m * a_eta_zero_dvd_p_pow hp hζ e hy",
  "constCategory": "Theorem"},
 {"references": ["Bool.false", "Bool.true", "Bool.rec", "Bool"],
  "name": "Bool.casesOn",
  "constType":
  "{motive : Bool → Sort u} → (t : Bool) → motive false → motive true → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Finsupp.single",
   "Finsupp.instAddCommMonoid",
   "Finsupp",
   "AddMonoid.toZero",
   "Finsupp.sum",
   "AddCommMonoid.toAddMonoid",
   "AddCommMonoid"],
  "name": "Finsupp.mapDomain",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → {M : Type u_5} → [inst : AddCommMonoid M] → (α → β) → (α →₀ M) → β →₀ M",
  "constCategory": "Definition"},
 {"references": ["GroupWithZero", "Div"],
  "name": "GroupWithZero.toDiv",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → Div G₀",
  "constCategory": "Definition"},
 {"references":
  ["Polynomial",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Polynomial.X",
   "Polynomial.C",
   "Semiring",
   "RingHom.comp",
   "Polynomial.eval₂",
   "Polynomial.semiring"],
  "name": "Polynomial.map",
  "constType":
  "{R : Type u} → {S : Type v} → [inst : Semiring R] → [inst_1 : Semiring S] → (R →+* S) → Polynomial R → Polynomial S",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Finset.instInsert",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "ite_cond_eq_false",
   "Nat.succ_le_succ",
   "Finset.card_pos",
   "Insert.insert",
   "Iff.mpr",
   "instDecidableEqNat",
   "Nat.cast_zero",
   "Mathlib.Meta.NormNum.isInt_add",
   "ite",
   "Semiring.toNatCast",
   "Finset.instMembership",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "Finset.range",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNat",
   "false_or",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHSub",
   "HPow.hPow",
   "Or",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "SDiff.sdiff",
   "or_true",
   "Int.instRing",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "Int.instCharZero",
   "eq_true",
   "Nat.zero",
   "False.elim",
   "Finset.card_sdiff",
   "AddMonoidWithOne.toOne",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "congr",
   "instNatAtLeastTwo",
   "LinearOrder.toPartialOrder",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "And.intro",
   "Nat.instCharZero",
   "Int",
   "Fin",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "CommMonoidWithZero.toZero",
   "Int.instAddGroup",
   "Nat.instStrictOrderedSemiring",
   "sub_nonpos_of_le",
   "Int.instSemiring",
   "Eq.ge",
   "Init.Data.Fin.Lemmas._auxLemma.1",
   "GE.ge",
   "Semiring.toMonoidWithZero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Int.rawCast",
   "Eq.refl",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Exists.intro",
   "NeZero.one",
   "Fin.is_lt",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "Mathlib.Data.Finset.Basic._auxLemma.154",
   "rfl",
   "IsCancelAdd.toIsRightCancelAdd",
   "True",
   "Mathlib.Tactic.Ring.sub_pf",
   "AddMonoidWithOne.toNatCast",
   "Finset.card_insert_le",
   "Int.instAddMonoid",
   "Int.instCovariantClassAddLE",
   "AddMonoid.toAddSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Finset",
   "Monoid.toNatPow",
   "zero_lt_one",
   "Nat.instAddCommMonoidWithOne",
   "Nat.sub_pos_of_lt",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalNonAssocRing.toMul",
   "covariant_swap_add_of_covariant_add",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "lt_of_lt_of_le",
   "Mathlib.Algebra.NeZero._auxLemma.3",
   "Mathlib.Tactic.Ring.cast_pos",
   "Mathlib.Tactic.Ring.mul_add",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "LE.le",
   "Finset.instSDiff",
   "Finset.mem_range",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "Int.instLinearOrderedCommRing",
   "Mathlib.Tactic.Ring.zero_mul",
   "instNatCastInt",
   "Bool.false",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "letFun",
   "not_true_eq_false",
   "FltRegular.f",
   "Mathlib.Tactic.Ring.add_mul",
   "NegZeroClass.toNeg",
   "Mathlib.Tactic.Ring.atom_pf",
   "Finset.insert_subset_iff",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Mathlib.Tactic.Ring.mul_congr",
   "Finset.instHasSubset",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "CanonicallyOrderedCommSemiring.toOne",
   "Exists.casesOn",
   "instLTNat",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "true_or",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "le_trans",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "Ne",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "neg_neg_of_pos",
   "Mathlib.Data.Finset.Basic._auxLemma.116",
   "Fin.val",
   "OrderedSemiring.zeroLEOneClass",
   "Nat.rawCast",
   "Finset.singleton_subset_iff",
   "Finset.card_range",
   "HasSubset.Subset",
   "Finset.instSingleton",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "lt_of_not_ge",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instLTInt",
   "Int.instAddCommSemigroup",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Nat.instOrderedSemiring",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "Eq.mp",
   "Not",
   "Singleton.singleton",
   "congrArg",
   "Int.instLEInt",
   "OrderedAddCommGroup.toAddCommGroup",
   "Finset.card",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Finset.Nonempty",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "Linarith.lt_irrefl",
   "LinearOrderedRing.toStrictOrderedRing",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "instSubNat",
   "Mathlib.Data.Finset.Basic._auxLemma.64",
   "Mathlib.Tactic.Zify._auxLemma.2",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "instLENat",
   "and_false",
   "Preorder.toLT",
   "instHPow",
   "AddMonoid.toZero",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Linarith.mul_neg",
   "Int.instNegInt",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "add_lt_of_neg_of_le",
   "Eq.symm",
   "id",
   "instOfNatAtLeastTwo",
   "NeZero.succ",
   "eq_self",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "False",
   "instAddNat",
   "lt_of_le_of_lt",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "eq_false",
   "StrictOrderedSemiring.toPartialOrder",
   "Finset.sdiff_subset",
   "OrderedCommSemiring.toOrderedSemiring",
   "Nat.instCanonicallyOrderedCommSemiring",
   "Nat.instLinearOrder",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "Bool",
   "NegZeroClass.toZero",
   "Int.instCommSemiring",
   "Int.instNontrivial"],
  "name": "FltRegular.auxf'",
  "constType":
  "∀ {p : ℕ}, 5 ≤ p → ∀ (a b : ℤ) (k₁ k₂ : Fin p), ∃ i ∈ Finset.range p, FltRegular.f a b (↑k₁) (↑k₂) i = 0",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero", "MonoidWithZero"],
  "name": "GroupWithZero.toMonoidWithZero",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → MonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LeftCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["NormedField.toNormedCommRing.proof_2",
   "NormedField.toField",
   "Field.toCommRing",
   "NormedCommRing",
   "NormedField.toMetricSpace",
   "NormedField.dist_eq",
   "NormedField",
   "CommRing.toRing",
   "NormedRing.mk",
   "NormedCommRing.mk",
   "NormedField.toNormedCommRing.proof_1",
   "NormedField.toNorm"],
  "name": "NormedField.toNormedCommRing",
  "constType": "{α : Type u_1} → [inst : NormedField α] → NormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "EmptyCollection.emptyCollection",
   "Nat.le_of_dvd",
   "Finset.Ico",
   "HAdd.hAdd",
   "instSubsingletonForall",
   "Mathlib.Algebra.GroupWithZero.Divisibility._auxLemma.2",
   "instLTNat",
   "Preorder.toLE",
   "Eq",
   "Finset.instMembership",
   "DecidablePred",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff",
   "Finset.range",
   "Nat.instDvd",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "Eq.trans",
   "Ne",
   "Or",
   "eq_or_ne",
   "Mathlib.Order.Basic._auxLemma.1",
   "Mathlib.NumberTheory.Divisors._auxLemma.10",
   "Nat.filter_dvd_eq_divisors",
   "Mathlib.NumberTheory.Divisors._auxLemma.2",
   "Or.casesOn",
   "Mathlib.Data.Finset.Basic._auxLemma.20",
   "instDecidableTrue",
   "Ne.bot_lt",
   "SemigroupWithZero.toSemigroup",
   "Nat.instLocallyFiniteOrder",
   "And",
   "of_eq_true",
   "LT.lt",
   "congr",
   "Finset.filter_empty",
   "Not",
   "congrArg",
   "Mathlib.NumberTheory.Divisors._auxLemma.11",
   "Finset.instEmptyCollection",
   "instSubsingletonDecidable",
   "AddZeroClass.toAdd",
   "Nat.instStrictOrderedSemiring",
   "Eq.refl",
   "Mathlib.NumberTheory.Divisors._auxLemma.8",
   "CommSemiring.toNonUnitalCommSemiring",
   "semigroupDvd",
   "Nat.instAddMonoid",
   "SemigroupWithZero.toZero",
   "AddMonoid.toAddZeroClass",
   "True",
   "iff_self",
   "Subsingleton.elim",
   "Zero.toOfNat0",
   "zero_add",
   "instLENat",
   "and_false",
   "Eq.rec",
   "Finset",
   "Decidable",
   "Finset.filter",
   "instOfNatNat",
   "Eq.symm",
   "Mathlib.NumberTheory.Divisors._auxLemma.9",
   "Nat.succ",
   "id",
   "eq_self",
   "Membership.mem",
   "funext",
   "False",
   "instAddNat",
   "instHAdd",
   "Dvd.dvd",
   "Nat.instOrderBot",
   "LE.le",
   "Nat.divisors",
   "eq_false",
   "Nat.instCommSemiring",
   "Eq.ndrec",
   "StrictOrderedSemiring.toPartialOrder",
   "Mathlib.NumberTheory.Divisors._auxLemma.1",
   "Nat.decidable_dvd",
   "NonUnitalSemiring.toSemigroupWithZero",
   "not_true_eq_false",
   "Finset.Ico_eq_empty_of_le"],
  "name": "Nat.mem_divisors",
  "constType": "∀ {n m : ℕ}, n ∈ m.divisors ↔ n ∣ m ∧ m ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Algebra.toRingHom",
   "CommSemiring.toSemiring",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "CommSemiring",
   "Algebra"],
  "name": "algebraMap",
  "constType":
  "(R : Type u) → (A : Type v) → [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → R →+* A",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "mul_sub_right_distrib",
   "HSub.hSub",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "sub_mul",
  "constType":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), (a - b) * c = a * c - b * c",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "IsDomain",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "IsDomain.toCancelCommMonoidWithZero.proof_1",
   "CancelCommMonoidWithZero",
   "CancelCommMonoidWithZero.mk"],
  "name": "IsDomain.toCancelCommMonoidWithZero",
  "constType":
  "{α : Type u_1} → [inst : CommSemiring α] → [inst : IsDomain α] → CancelCommMonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["Units.instMul",
   "instHMul",
   "Units",
   "MulOneClass.toMul",
   "Monoid",
   "Units.val",
   "HMul.hMul",
   "Units.val_mul",
   "Eq.symm",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.21",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : αˣ), ↑a * ↑b = ↑(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "add_left_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "add_zero",
   "congrArg",
   "id"],
  "name": "neg_add_cancel_right",
  "constType": "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + -b + b = a",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "MulOneClass.toMul",
   "Monoid",
   "MulAction.toSMul",
   "instHSMul",
   "HSMul.hSMul",
   "HMul.hMul",
   "MulAction.mul_smul",
   "Eq.symm",
   "MulAction",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.18",
  "constType":
  "∀ {α : Type u_11} {β : Type u_12} [inst : Monoid α] [self : MulAction α β] (x y : α) (b : β), x • y • b = (x * y) • b",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.symm", "Units", "Monoid", "Iff", "Units.val", "Units.eq_iff", "Eq"],
  "name": "Units.ext_iff",
  "constType": "∀ {α : Type u} [inst : Monoid α] {a b : αˣ}, a = b ↔ ↑a = ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "RingHom",
   "CommSemiring.toSemiring",
   "FractionalIdeal.coeIdeal",
   "Exists",
   "MulZeroOneClass.toMulOneClass",
   "algebraMap",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.instFunLike",
   "CommRing",
   "SetLike.instMembership",
   "Eq",
   "CommRing.toCommSemiring",
   "And",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "Algebra",
   "Submonoid",
   "FractionalIdeal",
   "FractionalIdeal.mem_coeIdeal",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DFunLike.coe",
   "Ideal",
   "FractionalIdeal.instSetLike",
   "Semiring.toModule",
   "Submodule.setLike"],
  "name": "FltRegular.NumberTheory.Different._auxLemma.3",
  "constType":
  "∀ {R : Type u_1} [inst : CommRing R] (S : Submonoid R) {P : Type u_2} [inst_1 : CommRing P] [inst_2 : Algebra R P]\n  {x : P} {I : Ideal R}, (x ∈ ↑I) = ∃ x' ∈ I, (algebraMap R P) x' = x",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "Part.ext'",
   "Part.Dom",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "PartENat.instAddCommMonoidWithOne",
   "Part.get",
   "PartENat",
   "iff_of_true",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "rfl",
   "Eq"],
  "name": "PartENat.natCast_get",
  "constType": "∀ {x : PartENat} (h : x.Dom), ↑(x.get h) = x",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Finset.card",
   "Membership.mem",
   "Finset.insert_eq_of_mem",
   "OfNat.ofNat",
   "Finset.decidableMem",
   "PartialOrder.toPreorder",
   "Finset.instInsert",
   "Lattice.toSemilatticeInf",
   "instAddNat",
   "Finset.card_insert_of_not_mem",
   "instHAdd",
   "HAdd.hAdd",
   "SemilatticeInf.toPartialOrder",
   "dite",
   "Insert.insert",
   "LE.le",
   "instDistribLatticeNat",
   "Eq",
   "Finset.instMembership",
   "DistribLattice.toLattice",
   "Eq.mpr",
   "instLENat",
   "DecidableEq",
   "le_refl",
   "Finset",
   "Nat.le_succ",
   "Not",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "id"],
  "name": "Finset.card_insert_le",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] (a : α) (s : Finset α), (insert a s).card ≤ s.card + 1",
  "constCategory": "Theorem"},
 {"references":
  ["QuotientGroup.instHasQuotientSubgroup",
   "Quotient.mk''",
   "QuotientGroup.leftRel",
   "Subgroup",
   "Group",
   "HasQuotient.Quotient"],
  "name": "QuotientGroup.mk",
  "constType":
  "{α : Type u_1} → [inst : Group α] → {s : Subgroup α} → α → α ⧸ s",
  "constCategory": "Definition"},
 {"references": ["LE", "Sub", "Add"],
  "name": "OrderedSub",
  "constType":
  "(α : Type u_3) → [inst : LE α] → [inst : Add α] → [inst : Sub α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Units",
   "UniqueFactorizationMonoid",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "MonoidWithZero.toMonoid",
   "Multiset",
   "UniqueFactorizationMonoid.factors",
   "UniqueFactorizationMonoid.factors_eq_normalizedFactors",
   "Eq.symm",
   "normalizationMonoidOfUniqueUnits",
   "UniqueFactorizationMonoid.normalizedFactors",
   "CancelCommMonoidWithZero",
   "Eq",
   "CommMonoidWithZero.toMonoidWithZero",
   "Unique"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.9",
  "constType":
  "∀ {M : Type u_2} [inst : CancelCommMonoidWithZero M] [inst_1 : UniqueFactorizationMonoid M] [inst_2 : Unique Mˣ]\n  (x : M), UniqueFactorizationMonoid.normalizedFactors x = UniqueFactorizationMonoid.factors x",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.dvd_of_mod_eq_zero",
   "Or",
   "OfNat.ofNat",
   "Nat.mod_two_eq_zero_or_one",
   "of_decide_eq_true",
   "Eq.refl",
   "instDecidableEqNat",
   "Eq",
   "Or.resolve_left",
   "Nat.Prime",
   "Or.imp_left",
   "instHMod",
   "instDecidableNot",
   "Bool.true",
   "HMod.hMod",
   "instOfNatNat",
   "Not",
   "Bool",
   "Nat",
   "Eq.symm",
   "Nat.Prime.eq_one_or_self_of_dvd",
   "Nat.instMod"],
  "name": "Nat.Prime.eq_two_or_odd",
  "constType": "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ p % 2 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "AddZeroClass.toAdd",
   "MulOneClass.toMul",
   "AlgHomClass.mk",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "EquivLike",
   "Semiring.toNonAssocSemiring",
   "MulEquivClass.map_mul",
   "AlgEquivClass.toRingEquivClass",
   "RingHomClass.toMonoidWithZeroHomClass",
   "CommSemiring",
   "Algebra",
   "MonoidHomClass.toOneHomClass",
   "EquivLike.toFunLike",
   "AddMonoidHomClass.mk",
   "MonoidHomClass.mk",
   "RingEquivClass.toRingHomClass",
   "RingHomClass.mk",
   "AlgHomClass",
   "Semiring",
   "AddMonoidWithOne.toAddMonoid",
   "AlgEquivClass.commutes",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "MulHomClass.mk",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddHomClass.mk",
   "RingEquivClass.map_add",
   "RingHomClass.toMonoidHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingEquivClass.toMulEquivClass",
   "AlgEquivClass",
   "MonoidWithZeroHomClass.toZeroHomClass"],
  "name": "AlgEquivClass.toAlgHomClass",
  "constType":
  "∀ (F : Type u_1) (R : Type u_2) (A : Type u_3) (B : Type u_4) [inst : CommSemiring R] [inst_1 : Semiring A]\n  [inst_2 : Semiring B] [inst_3 : Algebra R A] [inst_4 : Algebra R B] [inst_5 : EquivLike F A B]\n  [h : AlgEquivClass F R A B], AlgHomClass F R A B",
  "constCategory": "Definition"},
 {"references":
  ["instCommGroupRelativeUnits",
   "CommGroup.toGroup",
   "DivisionRing.toRing",
   "Algebra.toModule",
   "Semifield.toCommSemiring",
   "LieRing.toAddCommGroup",
   "Field.toSemifield",
   "Eq.refl",
   "RelativeUnits",
   "MonoidHom",
   "DivInvMonoid.toMonoid",
   "AlgHom",
   "Monoid.toMulOneClass",
   "Eq",
   "DivisionSemiring.toSemiring",
   "relativeUnitsMap",
   "relativeUnitsMapHom",
   "AlgHom.End",
   "Monoid.End.inst",
   "Field",
   "NumberField",
   "Algebra",
   "Semifield.toDivisionSemiring",
   "MonoidHom.instFunLike",
   "Group.toDivInvMonoid",
   "DFunLike.coe",
   "LieRing.ofAssociativeRing",
   "Field.toDivisionRing",
   "Monoid.End",
   "FiniteDimensional"],
  "name": "relativeUnitsMapHom_apply",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] [inst_1 : NumberField K] {k : Type u_2} [inst_2 : Field k] [inst_3 : NumberField k]\n  [inst_4 : Algebra k K] [inst_5 : FiniteDimensional k K] (σ : K →ₐ[k] K), relativeUnitsMapHom σ = relativeUnitsMap σ",
  "constCategory": "Theorem"},
 {"references": ["PNat.val", "Nat.Prime", "PNat"],
  "name": "PNat.Prime",
  "constType": "ℕ+ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Semiring",
   "Int.instCommSemiring",
   "Int"],
  "name": "Int.instSemiring",
  "constType": "Semiring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Iff.rfl",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.covconv_swap",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Function.swap",
   "AddZeroClass.toZero",
   "zero_add",
   "Eq.mpr",
   "AddGroup",
   "Iff",
   "LE",
   "add_le_add_iff_right",
   "Eq.symm",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "LE.le",
   "AddGroup.toSubNegMonoid",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "CovariantClass",
   "NegZeroClass.toZero",
   "congrArg"],
  "name": "sub_nonpos_of_le",
  "constType":
  "∀ {α : Type u} [inst : AddGroup α] [inst_1 : LE α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1] {a b : α}, a ≤ b → a - b ≤ 0",
  "constCategory": "Theorem"},
 {"references":
  ["instHMod",
   "Int.instDecidableEq",
   "Int.ModEq",
   "Decidable",
   "HMod.hMod",
   "Int.instMod",
   "decEq",
   "Int"],
  "name": "Int.instDecidableModEq",
  "constType": "{n a b : ℤ} → Decidable (a ≡ b [ZMOD n])",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___unexpand_CyclotomicField_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Field.zpow_succ'",
   "DivisionRing",
   "Field.qsmul_def",
   "DivisionRing.mk",
   "Field.zpow_zero'",
   "Field.nnqsmul",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.nnqsmul_def",
   "Field.toNNRatCast",
   "Field.toRatCast",
   "Field.ratCast_def",
   "Field.toCommRing",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Field.toDiv",
   "Field.qsmul",
   "Field.nnratCast_def",
   "Field.div_eq_mul_inv"],
  "name": "Field.toDivisionRing",
  "constType": "{K : Type u} → [self : Field K] → DivisionRing K",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "propext",
   "MonoidHom.mem_range",
   "Subgroup",
   "Group",
   "MonoidHom.instFunLike",
   "Group.toDivInvMonoid",
   "MonoidHom",
   "DFunLike.coe",
   "MonoidHom.range",
   "DivInvMonoid.toMonoid",
   "Subgroup.instSetLike",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.8",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] {N : Type u_5} [inst_1 : Group N] {f : G →* N} {y : N}, (y ∈ f.range) = ∃ x, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Submodule.instBot",
   "Bot.bot",
   "OfNat.ofNat",
   "Semiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "Ideal.span",
   "Set.instMembership",
   "Ideal.span_eq_bot",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Ideal",
   "Semiring.toModule"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.1",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] {s : Set α}, (Ideal.span s = ⊥) = ∀ x ∈ s, x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "RingHom",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "Set",
   "IsDomain",
   "Module.Finite",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "FractionRing.field",
   "Ideal.span",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "Eq",
   "nonZeroDivisors",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Set.image_image",
   "OreLocalization.oreSetComm",
   "FractionRing.liftAlgebra",
   "Algebra",
   "DFunLike.coe",
   "Set.image",
   "CommSemiring.toCommMonoidWithZero",
   "IsIntegrallyClosed",
   "Algebra.toSMul",
   "Semiring.toModule",
   "Algebra.intNorm",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "id",
   "OreLocalization.instCommRing",
   "NoZeroSMulDivisors",
   "Ideal.map",
   "Algebra.toModule",
   "Function.comp",
   "Ideal.spanIntNorm.eq_1",
   "OreLocalization.instRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MonoidHom",
   "RingHom.instFunLike",
   "OreLocalization.instAlgebra",
   "CommRing.toCommSemiring",
   "CommRing.toCommMonoid",
   "FractionRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "FractionRing.instNoZeroSMulDivisors",
   "MonoidHom.instFunLike",
   "Ideal.spanIntNorm",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.IsSeparable",
   "congrArg",
   "Ideal",
   "Submodule.setLike",
   "Ideal.map_span",
   "SetLike.coe"],
  "name": "Ideal.map_spanIntNorm",
  "constType":
  "∀ (R : Type u_1) [inst : CommRing R] {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsIntegrallyClosed R] [inst_4 : IsDomain R] [inst_5 : IsDomain S] [inst_6 : NoZeroSMulDivisors R S]\n  [hRS : Module.Finite R S] [inst_7 : IsIntegrallyClosed S]\n  [inst_8 : Algebra.IsSeparable (FractionRing R) (FractionRing S)] (I : Ideal S) {T : Type u_3} [inst_9 : CommRing T]\n  (f : R →+* T), Ideal.map f (Ideal.spanIntNorm R I) = Ideal.span (⇑f ∘ ⇑(Algebra.intNorm R S) '' ↑I)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrder", "PartialOrder"],
  "name": "LinearOrder.toPartialOrder",
  "constType": "{α : Type u} → [self : LinearOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.AtLeastTwo",
   "OfNat.ofNat",
   "Nat.AtLeastTwo.mk",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.succ_le_succ",
   "instOfNatNat",
   "Nat.zero_le",
   "Nat"],
  "name": "instNatAtLeastTwo",
  "constType": "∀ {n : ℕ}, (n + 2).AtLeastTwo",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHomClass",
   "outParam",
   "FunLike",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring"],
  "name": "RingHomClass.toMonoidHomClass",
  "constType":
  "∀ {F : Type u_5} {α : outParam (Type u_6)} {β : outParam (Type u_7)} [inst : NonAssocSemiring α]\n  [inst_1 : NonAssocSemiring β] [inst_2 : FunLike F α β] [self : RingHomClass F α β], MonoidHomClass F α β",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "And",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["Zero", "Mul"],
  "name": "NoZeroDivisors",
  "constType": "(M₀ : Type u_4) → [inst : Mul M₀] → [inst : Zero M₀] → Prop",
  "constCategory": "Other"},
 {"references": ["Nat.gcd", "Nat", "Int", "Int.natAbs"],
  "name": "Int.gcd",
  "constType": "ℤ → ℤ → ℕ",
  "constCategory": "Definition"},
 {"references": ["Zero", "SMul", "SMulZeroClass"],
  "name": "SMulZeroClass.toSMul",
  "constType":
  "{M : Type u_10} → {A : Type u_11} → [inst : Zero A] → [self : SMulZeroClass M A] → SMul M A",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ne",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Finsupp.instFunLike",
   "Finsupp",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "MvPolynomial",
   "Semiring.toMonoidWithZero",
   "Mathlib.Data.Finsupp.Defs._auxLemma.1",
   "MvPolynomial.coeff",
   "True",
   "iff_self",
   "Finset.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "MvPolynomial.support",
   "Iff",
   "of_eq_true",
   "CommSemiring",
   "Finset",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Not",
   "CommSemiring.toCommMonoidWithZero",
   "DFunLike.coe",
   "Nat",
   "MonoidWithZero.toZero",
   "congrArg",
   "Eq.trans",
   "Finsupp.support"],
  "name": "MvPolynomial.mem_support_iff",
  "constType":
  "∀ {R : Type u} {σ : Type u_1} [inst : CommSemiring R] {p : MvPolynomial σ R} {m : σ →₀ ℕ},\n  m ∈ p.support ↔ MvPolynomial.coeff m p ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["One", "MulOneClass"],
  "name": "MulOneClass.toOne",
  "constType": "{M : Type u} → [self : MulOneClass M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.mul_zero",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero.match_1",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "AddMonoid.toZero",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Mathlib.Tactic.Ring.Basic._auxLemma.1",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.trans",
   "eq_self",
   "HPow.hPow",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.add_overlap_pf_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b : R} (x : R) (e : ℕ),\n  Mathlib.Meta.NormNum.IsNat (a + b) 0 → Mathlib.Meta.NormNum.IsNat (x ^ e * a + x ^ e * b) 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_singleton",
   "Iff",
   "Finset",
   "Finset.instSingleton",
   "Singleton.singleton",
   "Eq",
   "Finset.instMembership"],
  "name": "Finset.mem_singleton",
  "constType": "∀ {α : Type u_1} {a b : α}, b ∈ {a} ↔ b = a",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "PartENat.instLE",
   "Monoid.toSemigroup",
   "PartENat.partialOrder",
   "Monoid",
   "PartialOrder.toPreorder",
   "PartENat",
   "Dvd.dvd",
   "semigroupDvd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Eq",
   "multiplicity.Finite",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "instHPow",
   "PartENat.natCast_get",
   "PartENat.instAddCommMonoidWithOne",
   "Part.get",
   "le_refl",
   "multiplicity.pow_dvd_of_le_multiplicity",
   "Monoid.toNatPow",
   "multiplicity",
   "Nat",
   "congrArg",
   "id",
   "DecidableRel"],
  "name": "multiplicity.pow_multiplicity_dvd",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] [inst_1 : DecidableRel fun x x_1 => x ∣ x_1] {a b : α} (h : multiplicity.Finite a b),\n  a ^ (multiplicity a b).get h ∣ b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Subtype",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references": ["Multiset", "Finset"],
  "name": "Finset.val",
  "constType": "{α : Type u_4} → Finset α → Multiset α",
  "constCategory": "Definition"},
 {"references": ["InvolutiveNeg", "HasDistribNeg", "Mul"],
  "name": "HasDistribNeg.toInvolutiveNeg",
  "constType":
  "{α : Type u_1} → [inst : Mul α] → [self : HasDistribNeg α] → InvolutiveNeg α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.gcd_image",
   "DecidableEq",
   "Finset.image",
   "Finset",
   "NormalizedGCDMonoid",
   "Eq.symm",
   "Finset.gcd",
   "CancelCommMonoidWithZero",
   "Eq",
   "id"],
  "name": "Finset.gcd_eq_gcd_image",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : CancelCommMonoidWithZero α] [inst_1 : NormalizedGCDMonoid α] {s : Finset β}\n  {f : β → α} [inst_2 : DecidableEq α], s.gcd f = (Finset.image f s).gcd id",
  "constCategory": "Theorem"},
 {"references": ["And"],
  "name": "And.right",
  "constType": "∀ {a b : Prop}, a ∧ b → b",
  "constCategory": "Theorem"},
 {"references": ["Decidable"],
  "name": "DecidablePred",
  "constType": "{α : Sort u} → (α → Prop) → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset",
   "Finset",
   "Finset.val",
   "Membership.mk",
   "Membership",
   "Multiset.instMembership"],
  "name": "Finset.instMembership",
  "constType": "{α : Type u_1} → Membership α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.isFalse",
   "Bool.false",
   "Bool.true",
   "Nat.eq_of_beq_eq_true",
   "Decidable",
   "Nat.ne_of_beq_eq_false",
   "Decidable.isTrue",
   "Nat.beq",
   "Bool",
   "Nat.decEq.match_1",
   "Nat",
   "Eq"],
  "name": "Nat.decEq",
  "constType": "(n m : ℕ) → Decidable (n = m)",
  "constCategory": "Definition"},
 {"references": ["And"],
  "name": "And.left",
  "constType": "∀ {a b : Prop}, a ∧ b → a",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "algebraMap",
   "CommSemiring",
   "Algebra",
   "DFunLike.coe",
   "Eq.symm",
   "Algebra.toSMul",
   "IsScalarTower",
   "RingHom.instFunLike",
   "IsScalarTower.algebraMap_apply",
   "Eq"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.10",
  "constType":
  "∀ (R : Type u) (S : Type v) (A : Type w) [inst : CommSemiring R] [inst_1 : CommSemiring S] [inst_2 : Semiring A]\n  [inst_3 : Algebra R S] [inst_4 : Algebra S A] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R S A] (x : R),\n  (algebraMap S A) ((algebraMap R S) x) = (algebraMap R A) x",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Iff", "Eq.rec", "rfl", "Eq"],
  "name": "forall_apply_eq_imp_iff₂",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : α → Prop} {q : β → Prop},\n  (∀ (b : β) (a : α), p a → f a = b → q b) ↔ ∀ (a : α), p a → q (f a)",
  "constCategory": "Theorem"},
 {"references": ["OfNat", "Nat"],
  "name": "OfNat.ofNat",
  "constType": "{α : Type u} → (x : ℕ) → [self : OfNat α x] → α",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedAddCommMonoid", "CanonicallyLinearOrderedAddCommMonoid"],
  "name":
  "CanonicallyLinearOrderedAddCommMonoid.toCanonicallyOrderedAddCommMonoid",
  "constType":
  "{α : Type u_1} → [self : CanonicallyLinearOrderedAddCommMonoid α] → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["Zero", "NegZeroClass"],
  "name": "NegZeroClass.toZero",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Zero G",
  "constCategory": "Definition"},
 {"references": ["MulOneClass"],
  "name": "Submonoid",
  "constType": "(M : Type u_4) → [inst : MulOneClass M] → Type u_4",
  "constCategory": "Other"},
 {"references": ["NatCast", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNatCast",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["Max"],
  "name": "Max.max",
  "constType": "{α : Type u} → [self : Max α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Exists",
   "Iff",
   "Subtype.exists.match_2",
   "Exists.intro",
   "Subtype.exists.match_1",
   "Subtype.mk",
   "Subtype"],
  "name": "Subtype.exists",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) ↔ ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "CommSemiring.toCommMonoidWithZero",
   "add_zero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_zero",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a + 0 = a",
  "constCategory": "Theorem"},
 {"references": ["One", "Semiring"],
  "name": "Semiring.toOne",
  "constType": "{α : Type u} → [self : Semiring α] → One α",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Name.num._override",
   "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_7"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LT.lt", "LT"],
  "name": "GT.gt",
  "constType": "{α : Type u} → [inst : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidableEq",
   "propext",
   "Multiset.mem_dedup",
   "Multiset",
   "Eq",
   "Multiset.dedup",
   "Multiset.instMembership"],
  "name": "FltRegular.NumberTheory.KummersLemma.Field._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, (a ∈ s.dedup) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat",
   "Eq.symm",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.isNat_ofNat",
  "constType":
  "∀ (α : Type u) [inst : AddMonoidWithOne α] {a : α} {n : ℕ}, ↑n = a → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "lt_of_le_not_le",
   "lt_of_le_of_lt.match_1",
   "le_not_le_of_lt",
   "Preorder.toLT",
   "LT.lt",
   "le_trans",
   "Not",
   "Preorder",
   "lt_of_lt_of_le.match_1",
   "LE.le",
   "Preorder.toLE"],
  "name": "lt_of_le_of_lt",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b < c → a < c",
  "constCategory": "Theorem"},
 {"references": ["Membership.mem", "setOf", "Set", "Set.instMembership"],
  "name": "Set.preimage",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set β → Set α",
  "constCategory": "Definition"},
 {"references":
  ["Quot.liftOn", "letFun", "Quot", "congrArg", "Quot.sound", "Quot.mk", "Eq"],
  "name": "funext",
  "constType":
  "∀ {α : Sort u} {β : α → Sort v} {f g : (x : α) → β x}, (∀ (x : α), f x = g x) → f = g",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "IsDomain",
   "Module.Finite",
   "Semiring.toMonoidWithZero",
   "FractionRing.field",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "nonZeroDivisors",
   "Algebra.intNorm.proof_1",
   "Semiring.toNonAssocSemiring",
   "OreLocalization.oreSetComm",
   "FractionRing.liftAlgebra",
   "Algebra",
   "Algebra.intNorm.proof_2",
   "Algebra.intNorm.proof_4",
   "CommSemiring.toCommMonoidWithZero",
   "IsIntegrallyClosed",
   "Algebra.toSMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "OreLocalization.instCommRing",
   "NoZeroSMulDivisors",
   "Algebra.toModule",
   "OreLocalization.instRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MonoidHom",
   "OreLocalization.instAlgebra",
   "Algebra.intNormAux",
   "Algebra.intNorm.proof_5",
   "CommRing.toCommSemiring",
   "CommRing.toCommMonoid",
   "FractionRing",
   "CommRing.toRing",
   "FractionRing.instNoZeroSMulDivisors",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.IsSeparable",
   "Algebra.id",
   "Algebra.intNorm.proof_3"],
  "name": "Algebra.intNorm",
  "constType":
  "(A : Type u_1) →\n  (B : Type u_4) →\n    [inst : CommRing A] →\n      [inst_1 : CommRing B] →\n        [inst_2 : Algebra A B] →\n          [inst_3 : IsDomain A] →\n            [inst_4 : IsIntegrallyClosed A] →\n              [inst_5 : IsDomain B] →\n                [inst_6 : IsIntegrallyClosed B] →\n                  [inst_7 : Module.Finite A B] →\n                    [inst_8 : NoZeroSMulDivisors A B] →\n                      [inst_9 : Algebra.IsSeparable (FractionRing A) (FractionRing B)] → B →* A",
  "constCategory": "Definition"},
 {"references": ["Applicative", "Pure"],
  "name": "Applicative.toPure",
  "constType": "{f : Type u → Type v} → [self : Applicative f] → Pure f",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "Int.instNormedCommRing",
   "DivInvMonoid.Pow",
   "Ideal.span",
   "algebraRat",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Exists.casesOn",
   "SetLike.instMembership",
   "Semiring.toNatCast",
   "Eq",
   "Eq.mpr",
   "Nat.Prime",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "Field",
   "Ring.toIntCast",
   "IsPrimitiveRoot.unit'",
   "Nat",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "HPow.hPow",
   "Ne",
   "Monoid",
   "instOfNatPNatOfNeZeroNat",
   "eq_of_heq",
   "Units.instMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "CommMagma.toMul",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "CommRing.toCommMonoid",
   "instHMul",
   "zpow_mul",
   "HEq.refl",
   "Field.toEuclideanDomain",
   "Int.cast",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "Singleton.singleton",
   "congrArg",
   "Field.toDivisionRing",
   "Int",
   "Ideal",
   "CommGroup.toDivisionCommMonoid",
   "Units.instDivInvMonoid",
   "Submodule.setLike",
   "Exists",
   "HEq",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Set",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "Eq.refl",
   "Exists.intro",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "Membership",
   "zpow_ofNat",
   "mul_comm",
   "PNat.val",
   "outParam",
   "Set.instSingletonSet",
   "Rat.commRing",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "instHPow",
   "Ring.toSub",
   "Monoid.toNatPow",
   "Int.instNegInt",
   "instOfNatNat",
   "Eq.symm",
   "Semiring.toModule",
   "id",
   "NeZero.succ",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.instMul",
   "instHAdd",
   "HSub.hSub",
   "Rat",
   "Neg.neg",
   "FltRegular.CaseI.exists_int_sum_eq_zero'",
   "DivInvMonoid.toMonoid",
   "IsCyclotomicExtension",
   "NormedCommRing.toSeminormedCommRing",
   "CommRing.toCommSemiring",
   "Units",
   "Eq.ndrec",
   "Units.instCommGroupUnits",
   "instNatCastInt",
   "CharZero",
   "Units.val",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "HSub",
   "Eq.casesOn",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NumberField.RingOfIntegers",
   "HMul",
   "PNat"],
  "name": "FltRegular.CaseI.exists_int_sum_eq_zero",
  "constType":
  "∀ {p : ℕ+} {K : Type u_1} [inst : Field K] [inst_1 : CharZero K] [inst_2 : IsCyclotomicExtension {p} ℚ K] {ζ : K}\n  (hζ : IsPrimitiveRoot ζ ↑p),\n  p ≠ 2 →\n    Nat.Prime ↑p →\n      ∀ (x y i : ℤ) {u : (NumberField.RingOfIntegers K)ˣ} {α : NumberField.RingOfIntegers K},\n        ↑x + ↑y * ↑(hζ.unit' ^ i) = ↑u * α ^ ↑p →\n          ∃ k, ↑x + ↑y * ↑(hζ.unit' ^ i) - ↑(hζ.unit' ^ (2 * k)) * (↑x + ↑y * ↑(hζ.unit' ^ (-i))) ∈ Ideal.span {↑↑p}",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_27._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Units.instMul",
   "Units",
   "Units.instOne",
   "Monoid",
   "Units.instMulOneClass.proof_1",
   "MulOneClass",
   "Units.instMulOneClass.proof_2",
   "MulOneClass.mk"],
  "name": "Units.instMulOneClass",
  "constType": "{α : Type u} → [inst : Monoid α] → MulOneClass αˣ",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_5",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_4"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_8",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_7"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Fin.ext_iff", "Fin.val", "propext", "Nat", "Fin", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.26",
  "constType": "∀ {n : ℕ} {a b : Fin n}, (a = b) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references": ["LT", "Preorder"],
  "name": "Preorder.toLT",
  "constType": "{α : Type u} → [self : Preorder α] → LT α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Macro.State",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_3",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_1"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.swap",
  "constType":
  "{α : Sort u₁} → {β : Sort u₂} → {φ : α → β → Sort u₃} → ((x : α) → (y : β) → φ x y) → (y : β) → (x : α) → φ x y",
  "constCategory": "Definition"},
 {"references": ["Zero", "OfNat", "OfNat.mk", "Zero.zero"],
  "name": "Zero.toOfNat0",
  "constType": "{α : Type u_1} → [inst : Zero α] → OfNat α 0",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "HPow.hPow",
   "Ne",
   "OfNat.ofNat",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "Monoid.toNatPow",
   "Nat",
   "MonoidWithZero.toZero"],
  "name": "FermatLastTheoremWith",
  "constType": "(α : Type u_1) → [inst : Semiring α] → ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Nat.mod_self",
   "dite",
   "Mathlib.Tactic.PushNeg.not_lt_eq",
   "instLTNat",
   "implies_congr",
   "ZMod.val_eq_zero",
   "Nat.mod_eq_of_lt",
   "Preorder.toLE",
   "Eq",
   "ite",
   "Eq.mpr",
   "Ring.toNeg",
   "ZMod.decidableEq",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "instHSub",
   "Nat.instOrderedSub",
   "ZMod.val_zero",
   "Mathlib.Tactic.PushNeg.not_not_eq",
   "ZMod",
   "tsub_zero",
   "propext",
   "LT.lt",
   "Eq.mp",
   "CommRing.toRing",
   "Not",
   "LinearOrder.toPartialOrder",
   "Mathlib.Tactic.Contrapose.mtr",
   "congrArg",
   "CommMonoidWithZero.toZero",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "Nat.instStrictOrderedSemiring",
   "instSubNat",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "Nat.instAddCommMonoid",
   "Zero.toOfNat0",
   "NeZero",
   "instLENat",
   "ZMod.val",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "Nat.le_zero",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "if_neg",
   "id",
   "NeZero.pos",
   "HSub.hSub",
   "Neg.neg",
   "LE.le",
   "CommRing.toCommSemiring",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "if_pos",
   "instHMod",
   "Nat.sub_lt",
   "StrictOrderedSemiring.toPartialOrder",
   "Nat.instCanonicallyOrderedCommSemiring",
   "Nat.instLinearOrder",
   "HMod.hMod",
   "ZMod.neg_val'",
   "Nat.instMod",
   "ZMod.commRing"],
  "name": "ZMod.neg_val",
  "constType":
  "∀ {n : ℕ} [inst : NeZero n] (a : ZMod n), (-a).val = if a = 0 then 0 else n - a.val",
  "constCategory": "Theorem"},
 {"references": ["Or", "Iff", "or_true", "iff_of_eq", "True"],
  "name": "or_true_iff",
  "constType": "∀ (p : Prop), p ∨ True ↔ True",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "OfNat.ofNat",
   "pow_eq_zero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq",
   "NoZeroDivisors",
   "Iff.intro",
   "Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "Iff",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "MonoidWithZero.toZero",
   "Eq.symm",
   "zero_pow",
   "MonoidWithZero"],
  "name": "pow_eq_zero_iff",
  "constType":
  "∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] {a : M₀} {n : ℕ} [inst_1 : NoZeroDivisors M₀], n ≠ 0 → (a ^ n = 0 ↔ a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Finsupp",
   "Classical.decEq",
   "OfNat.ofNat",
   "Finsupp.mk",
   "EmptyCollection.emptyCollection",
   "Finset",
   "Finset.instSingleton",
   "Singleton.singleton",
   "Finsupp.single.proof_1",
   "Finset.instEmptyCollection",
   "Pi.single",
   "Eq",
   "ite"],
  "name": "Finsupp.single",
  "constType":
  "{α : Type u_1} → {M : Type u_5} → [inst : Zero M] → α → M → α →₀ M",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Zero",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["OrderedAddCommGroup", "AddCommGroup"],
  "name": "OrderedAddCommGroup.toAddCommGroup",
  "constType": "{α : Type u} → [self : OrderedAddCommGroup α] → AddCommGroup α",
  "constCategory": "Definition"},
 {"references":
  ["add_right_inj",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "Add",
   "IsLeftCancelAdd",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CaseI._auxLemma.1",
  "constType":
  "∀ {G : Type u_3} [inst : Add G] [inst_1 : IsLeftCancelAdd G] (a : G) {b c : G}, (a + b = a + c) = (b = c)",
  "constCategory": "Theorem"},
 {"references": ["False"],
  "name": "Not",
  "constType": "Prop → Prop",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.ParserDescr.node",
   "Lean.Name.mkNum",
   "instOfNatNat",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termR._@.FltRegular.CaseI.AuxLemmas._hyg.717",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["Mul", "Mul.mul", "HMul", "HMul.mk"],
  "name": "instHMul",
  "constType": "{α : Type u_1} → [inst : Mul α] → HMul α α α",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.intro",
  "constType": "∀ {a b : Prop}, (a → b) → (b → a) → (a ↔ b)",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_23._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.combo",
   "Lean.Omega.Coeffs.combo",
   "Lean.Omega.Coeffs.dot",
   "Int.instMul",
   "instHAdd",
   "HAdd.hAdd",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Constraint.sat",
   "Lean.Omega.IntList",
   "Lean.Omega.IntList.instAdd",
   "Lean.Omega.Coeffs.dot_smul_left",
   "Lean.Omega.Coeffs.combo_eq_smul_add_smul",
   "Int.instAdd",
   "Eq",
   "instHMul",
   "Lean.Omega.Constraint.sat'.eq_1",
   "Eq.mpr",
   "Bool.true",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "HMul.hMul",
   "Lean.Omega.Constraint.combo_sat",
   "Bool",
   "Lean.Omega.Constraint",
   "Lean.Omega.Constraint.sat'",
   "congrArg",
   "Int",
   "Lean.Omega.IntList.instHMulInt",
   "id"],
  "name": "Lean.Omega.combo_sat'",
  "constType":
  "∀ (s t : Lean.Omega.Constraint) (a : ℤ) (x : Lean.Omega.Coeffs) (b : ℤ) (y v : Lean.Omega.Coeffs),\n  s.sat' x v = true →\n    t.sat' y v = true → (Lean.Omega.Constraint.combo a s b t).sat' (Lean.Omega.Coeffs.combo a x b y) v = true",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "Nat.pred",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Nat.succ",
   "Nat.pred_lt_self.match_1",
   "instLTNat",
   "Eq"],
  "name": "Nat.succ_pred_eq_of_pos",
  "constType": "∀ {n : ℕ}, 0 < n → n.pred.succ = n",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Fin"],
  "name": "Fin.val",
  "constType": "{n : ℕ} → Fin n → ℕ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_26._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "MulOneClass.toMul",
   "one_nsmul",
   "OfNat.ofNat",
   "Multiset.prod_add",
   "instHSMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Eq.refl",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "pow_one",
   "Eq",
   "Zero.toOfNat0",
   "zero_nsmul",
   "PProd",
   "Eq.mpr",
   "instHPow",
   "AddMonoid.toZero",
   "PUnit",
   "HSMul.hSMul",
   "Multiset",
   "Monoid.toNatPow",
   "instOfNatNat",
   "CommMonoid.toMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Nat",
   "Nat.succ",
   "id",
   "HPow.hPow",
   "Multiset.prod_nsmul.match_1",
   "Nat.brecOn",
   "Nat.below",
   "instAddNat",
   "instHAdd",
   "Unit",
   "One.toOfNat1",
   "Multiset.instAdd",
   "Monoid.toMulOneClass",
   "pow_zero",
   "pow_add",
   "AddMonoid.toNatSMul",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "CommMonoid",
   "add_nsmul",
   "Multiset.prod",
   "HMul.hMul",
   "congrArg",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Multiset.prod_nsmul",
  "constType":
  "∀ {α : Type u_3} [inst : CommMonoid α] (m : Multiset α) (n : ℕ), (n • m).prod = m.prod ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.Prime",
   "Nat.pos_of_ne_zero",
   "LT.lt",
   "instOfNatNat",
   "Nat.Prime.ne_zero",
   "Nat",
   "instLTNat"],
  "name": "Nat.Prime.pos",
  "constType": "∀ {p : ℕ}, Nat.Prime p → 0 < p",
  "constCategory": "Theorem"},
 {"references":
  ["StrictOrderedRing.toRing",
   "Int.instAddGroup",
   "PartialOrder.toPreorder",
   "LinearOrderedRing.toStrictOrderedRing",
   "DivisionRing.toRing",
   "Semifield.toCommSemiring",
   "EuclideanDomain.to_principal_ideal_domain",
   "NumberField.RingOfIntegers.instCommRing",
   "Rat.isFractionRing",
   "NumberField.to_finiteDimensional",
   "algebraInt",
   "algebraRat",
   "IsPrincipalIdealRing.isDedekindDomain",
   "Preorder.toLE",
   "IsIntegralClosure.isDedekindDomain",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "PerfectField.ofCharZero",
   "Field",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "LinearOrderedRing.isDomain",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Rat.instField",
   "Algebra.toModule",
   "Rat.commSemiring",
   "AddGroup.existsAddOfLE",
   "Rat",
   "Algebra.IsAlgebraic.of_finite",
   "Field.toSemifield",
   "AddCommGroup.intIsScalarTower",
   "NumberField.to_charZero",
   "Int.euclideanDomain",
   "IsDedekindDomain",
   "Rat.instCharZero",
   "CommRing.toCommSemiring",
   "DivisionSemiring.toSemiring",
   "Int.instLinearOrderedCommRing",
   "Int.instCommRing",
   "NumberField.RingOfIntegers.instIsDomain",
   "StrictOrderedSemiring.toPartialOrder",
   "NumberField.RingOfIntegers.instIsIntegralClosureInt",
   "NumberField",
   "Algebra.IsAlgebraic.isSeparable_of_perfectField",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "Ring.toAddCommGroup",
   "Algebra.id",
   "Rat.instLinearOrderedRing",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Int",
   "NumberField.RingOfIntegers.instAlgebra_1"],
  "name": "NumberField.RingOfIntegers.instIsDedekindDomain",
  "constType":
  "∀ (K : Type u_1) [inst : Field K] [nf : NumberField K], IsDedekindDomain (NumberField.RingOfIntegers K)",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "Int.instLinearOrder",
   "inferInstance",
   "Lattice",
   "instDistribLatticeOfLinearOrder",
   "Int"],
  "name": "instLatticeInt",
  "constType": "Lattice ℤ",
  "constCategory": "Definition"},
 {"references": ["PUnit"],
  "name": "PUnit.unit",
  "constType": "PUnit.{u}",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "Set",
   "Dvd.dvd",
   "CommSemiring.toNonUnitalCommSemiring",
   "Ideal.span",
   "semigroupDvd",
   "SetLike.instMembership",
   "Eq",
   "SemigroupWithZero.toSemigroup",
   "Semiring.toNonAssocSemiring",
   "Set.instSingletonSet",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Ideal.mem_span_singleton",
   "Ideal",
   "Submodule.setLike",
   "Semiring.toModule"],
  "name": "FltRegular.CaseI.Statement._auxLemma.6",
  "constType":
  "∀ {α : Type u} [inst : CommSemiring α] {x y : α}, (x ∈ Ideal.span {y}) = (y ∣ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_10"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_15",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_1"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_16._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LT", "Nat.lt", "Nat", "LT.mk"],
  "name": "instLTNat",
  "constType": "LT ℕ",
  "constCategory": "Definition"},
 {"references": ["Lean.Syntax.Preresolved", "Lean.Name"],
  "name": "Lean.Syntax.Preresolved.namespace",
  "constType": "Lean.Name → Lean.Syntax.Preresolved",
  "constCategory": "Other"},
 {"references": ["False", "propext", "Not", "not_true", "True", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert90._auxLemma.7",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubNegMonoid.sub_eq_add_neg",
   "Eq"],
  "name": "sub_eq_add_neg",
  "constType":
  "∀ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a - b = a + -b",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.biUnion_subset_iff_forall_subset",
   "Membership.mem",
   "Finset.instHasSubset",
   "Finset.biUnion",
   "DecidableEq",
   "propext",
   "Finset",
   "HasSubset.Subset",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.2",
  "constType":
  "∀ {α : Type u_4} {β : Type u_5} [inst : DecidableEq β] {s : Finset α} {t : Finset β} {f : α → Finset β},\n  (s.biUnion f ⊆ t) = ∀ x ∈ s, f x ⊆ t",
  "constCategory": "Theorem"},
 {"references": ["Fin.eq_of_val_eq", "Fin.val", "Nat", "Fin", "Eq"],
  "name": "Fin.ext",
  "constType": "∀ {n : ℕ} {a b : Fin n}, ↑a = ↑b → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "instHDiv",
   "Int.instDvd",
   "Int.instMul",
   "HMul.hMul",
   "Int.ediv_mul_cancel_of_emod_eq_zero",
   "Dvd.dvd",
   "Int.instDiv",
   "HDiv.hDiv",
   "Int.emod_eq_zero_of_dvd",
   "Int",
   "Eq"],
  "name": "Int.ediv_mul_cancel",
  "constType": "∀ {a b : ℤ}, b ∣ a → a / b * b = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Add",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Distrib.rightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocSemiring.toMul",
   "True",
   "add_mul",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_mul",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b c₁ c₂ d : R},\n  a₁ * b = c₁ → a₂ * b = c₂ → c₁ + c₂ = d → (a₁ + a₂) * b = d",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "Finset.range_filter_eq",
   "OfNat.ofNat",
   "EmptyCollection.emptyCollection",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "pow_one",
   "AddGroupWithOne.toAddGroup",
   "instDecidableEqNat",
   "Semiring.toNatCast",
   "ite",
   "Finset.instMembership",
   "DecidablePred",
   "SubNegMonoid.toSub",
   "Nat.Prime",
   "One",
   "Nat.cast",
   "Finset.sum_range",
   "Finset.range",
   "HSMul.hSMul",
   "LinearOrderedCommMonoidWithZero.toZero",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Int.instSub",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Fin.mk",
   "HPow.hPow",
   "instHSub",
   "zsmul_eq_mul",
   "MulOneClass.toOne",
   "eq_of_heq",
   "NormedCommRing.toNormedRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Finset.filter_filter",
   "Int.ModEq.symm",
   "Int.instRing",
   "ZMod.intCast_eq_intCast_iff_dvd_sub",
   "instDecidableTrue",
   "ne_and_eq_iff_right",
   "CyclotomicField",
   "CommRing.toCommMonoid",
   "And",
   "Int.instCharZero",
   "eq_true",
   "Nat.zero",
   "propext",
   "LT.lt",
   "Finset.sum_ite",
   "congr",
   "Field.toDivisionRing",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "Int",
   "Fin",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "HEq",
   "Subtype.val",
   "Nat.decLt",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "semigroupDvd",
   "NeZero.pnat",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "FltRegular.CaseI.auxf0k₂",
   "True",
   "Subsingleton.elim",
   "CyclotomicField.instField",
   "NeZero",
   "zero_ne_one",
   "Eq.rec",
   "Finset",
   "Decidable",
   "Monoid.toNatPow",
   "Finset.filter",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NeZero.charZero",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "sub_mul",
   "Finset.sum",
   "One.toOfNat1",
   "Int.cast_sub",
   "Ne.symm",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "instDecidableAnd",
   "LE.le",
   "if_true",
   "Fin.val_mk",
   "CommRing.toCommSemiring",
   "Eq.ndrec",
   "Fact.mk",
   "instNatCastInt",
   "letFun",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Rat.instNormedField",
   "ZMod.intCast_eq_intCast_iff",
   "Subtype.mk",
   "FltRegular.CaseI.f0k₂",
   "CyclotomicField.instCharZero",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "AddGroupWithOne.toSub",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "instSubsingletonForall",
   "AddGroup.intSMulWithZero",
   "AddGroup.toSubtractionMonoid",
   "Finset.sum_const_zero",
   "CanonicallyOrderedCommSemiring.toOne",
   "instLTNat",
   "ZMod.instField",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "dvd_coeff_cycl_integer",
   "Finset.sum_singleton",
   "Nat",
   "Finset.sum_congr",
   "Eq.trans",
   "NormedRing.toRing",
   "ite_smul",
   "Ne",
   "Nat.Prime.pos",
   "Int.instDvd",
   "Fin.val",
   "add_sub_right_comm",
   "Int.ModEq",
   "Finset.instSingleton",
   "Fin.fintype",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "SubNegMonoid.SMulInt",
   "pow_zero",
   "ZMod",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.cast_zero",
   "SemigroupWithZero.toSemigroup",
   "Finset.univ",
   "instHMul",
   "NonAssocRing.toIntCast",
   "of_eq_true",
   "HEq.refl",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "mul_one",
   "Singleton.singleton",
   "Not",
   "sub_eq_zero",
   "add_zero",
   "congrArg",
   "Finset.instEmptyCollection",
   "instSubsingletonDecidable",
   "zero_smul",
   "Zero",
   "NonAssocRing.toAddCommGroupWithOne",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "CommRing.toNonUnitalCommRing",
   "NumberField.RingOfIntegers.instCommRing",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "PNat.val",
   "Zero.toOfNat0",
   "instLENat",
   "instHPow",
   "instDecidableNot",
   "AddMonoid.toZero",
   "Ring.toSub",
   "ite_cond_eq_true",
   "instOfNatNat",
   "AddCommGroup.toAddGroup",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "id",
   "eq_self",
   "NeZero.succ",
   "Nat.Prime.one_lt",
   "Membership.mem",
   "FltRegular.CaseI.aux_cong0k₂",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Rat.instField",
   "funext",
   "False",
   "CyclotomicField.isCyclotomicExtension",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Rat",
   "HSub.hSub",
   "Dvd.dvd",
   "AddGroup.toSubNegMonoid",
   "ite_congr",
   "Rat.instCharZero",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "Nat.instCanonicallyOrderedCommSemiring",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Eq.casesOn",
   "Int.instCommSemiring",
   "NegZeroClass.toZero",
   "NumberField.RingOfIntegers",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.3",
   "ZMod.commRing",
   "add_sub_assoc",
   "Dvd"],
  "name": "FltRegular.CaseI.aux0k₂",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p) {a b : ℤ} {ζ : NumberField.RingOfIntegers (CyclotomicField ⟨p, ⋯⟩ ℚ)},\n  5 ≤ p →\n    IsPrimitiveRoot ζ p →\n      ¬a ≡ b [ZMOD ↑p] →\n        ∀ {k₁ k₂ : Fin p}, ↑↑k₂ ≡ ↑↑k₁ - 1 [ZMOD ↑p] → ↑p ∣ ↑a + ↑b * ζ - ↑a * ζ ^ ↑k₁ - ↑b * ζ ^ ↑k₂ → 0 ≠ ↑k₂",
  "constCategory": "Theorem"},
 {"references": ["outParam", "MonadExcept"],
  "name": "MonadExcept.throw",
  "constType":
  "{ε : outParam (Type u)} → {m : Type v → Type w} → [self : MonadExcept ε m] → {α : Type v} → ε → m α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "Submodule",
   "HAdd.hAdd",
   "Submodule.Quotient.mk",
   "Submodule.addSubgroupClass",
   "AddCommGroup.toAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "SetLike.instMembership",
   "Submodule.Quotient.instZeroQuotient",
   "Eq",
   "Submodule.Quotient.eq'",
   "Mathlib.Algebra.Group.Subgroup.Basic._auxLemma.2",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Iff",
   "Submodule.hasQuotient",
   "Ring",
   "AddSubgroupClass.toNegMemClass",
   "AddCommGroup.toAddGroup",
   "HasQuotient.Quotient",
   "Module",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Membership.mem",
   "instHAdd",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Ring.toSemiring",
   "SubtractionMonoid.toInvolutiveNeg",
   "AddGroup.toSubNegMonoid",
   "Eq.mp",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup",
   "NegZeroClass.toZero",
   "add_zero",
   "NegZeroClass.toNeg",
   "congrArg",
   "Submodule.setLike"],
  "name": "Submodule.Quotient.mk_eq_zero",
  "constType":
  "∀ {R : Type u_1} {M : Type u_2} {x : M} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M]\n  (p : Submodule R M), Submodule.Quotient.mk x = 0 ↔ x ∈ p",
  "constCategory": "Theorem"},
 {"references": ["Iff.intro", "Nonempty.elim", "Iff", "Nonempty"],
  "name": "forall_const",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], α → b ↔ b",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.LinearCombo.casesOn",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Coeffs.dot",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Lean.Omega.Coeffs",
   "Lean.Omega.LinearCombo.mk",
   "Lean.Omega.IntList.instAdd",
   "Int.add_left_comm",
   "Lean.Omega.LinearCombo.instAdd",
   "Int.instAdd",
   "Eq",
   "Eq.mpr",
   "Eq.rec",
   "Lean.Omega.Coeffs.dot_distrib_left",
   "Int.add_assoc",
   "congr",
   "congrArg",
   "HAdd",
   "Eq.trans",
   "Lean.Omega.LinearCombo",
   "Int",
   "id"],
  "name": "Lean.Omega.LinearCombo.add_eval",
  "constType":
  "∀ (l₁ l₂ : Lean.Omega.LinearCombo) (v : Lean.Omega.Coeffs), (l₁ + l₂).eval v = l₁.eval v + l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.casesAuxOn",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "IsDomain",
   "Eq.refl",
   "Field.toSemifield",
   "Fact.out",
   "ZMod",
   "Eq",
   "ZMod.instField",
   "Field.isDomain",
   "DivisionSemiring.toSemiring",
   "Nat.Prime",
   "Eq.ndrec",
   "False.elim",
   "Field",
   "inferInstanceAs",
   "Semifield.toDivisionSemiring",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Fact",
   "Nat.not_prime_zero"],
  "name": "ZMod.instIsDomain",
  "constType": "∀ (p : ℕ) [hp : Fact (Nat.Prime p)], IsDomain (ZMod p)",
  "constCategory": "Definition"},
 {"references": ["setOf", "Set", "True"],
  "name": "Set.univ",
  "constType": "{α : Type u} → Set α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "Nat.pred",
   "HSub.hSub",
   "instOfNatNat",
   "Nat",
   "rfl",
   "Eq"],
  "name": "Nat.pred_eq_sub_one",
  "constType": "∀ {n : ℕ}, n.pred = n - 1",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "LT.lt",
   "instOfNat",
   "LE.le",
   "Int",
   "Int.instAdd",
   "Int.instLEInt",
   "Int.instLTInt"],
  "name": "Int.add_one_le_of_lt",
  "constType": "∀ {a b : ℤ}, a < b → a + 1 ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map", "Multiset.sum", "Finset", "Finset.val", "AddCommMonoid"],
  "name": "Finset.sum",
  "constType":
  "{α : Type u_3} → {β : Type u_4} → [inst : AddCommMonoid β] → Finset α → (α → β) → β",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inr",
  "constType": "∀ {a b : Prop}, b → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["Function.swap",
   "AddCommSemigroup.toAddCommMagma",
   "Covariant",
   "covariant_flip_iff",
   "flip",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommSemigroup",
   "AddCommMagma.to_isCommutative",
   "isSymmOp_of_isCommutative",
   "CovariantClass.mk",
   "AddCommMagma.toAdd",
   "Iff.mpr",
   "CovariantClass.elim"],
  "name": "covariant_swap_add_of_covariant_add",
  "constType":
  "∀ (N : Type u_2) (r : N → N → Prop) [inst : AddCommSemigroup N] [inst_1 : CovariantClass N N (fun x x_1 => x + x_1) r],\n  CovariantClass N N (Function.swap fun x x_1 => x + x_1) r",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "Mul"],
  "name": "NonUnitalNonAssocRing.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocRing α] → Mul α",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "Iff", "and_imp.match_1", "And.intro"],
  "name": "and_imp",
  "constType": "∀ {a b c : Prop}, a ∧ b → c ↔ a → b → c",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "GCDMonoid",
   "NormalizedGCDMonoid.toNormalizationMonoid",
   "Insert.insert",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Semiring.toNatCast",
   "Finset.instMembership",
   "HasDistribNeg.toInvolutiveNeg",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "add_comm",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "MulOneClass.toOne",
   "or_true",
   "AddCommMagma.toAdd",
   "Int.gcd",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "And",
   "Int.instCharZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "neg_add_eq_iff_eq_add",
   "Int.coe_gcd",
   "instNatAtLeastTwo",
   "congr",
   "Nat.gcd",
   "And.intro",
   "MonoidWithZero.toZero",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Int.instDecidableModEq",
   "CommMonoidWithZero.toZero",
   "Int.instSemiring",
   "sub_nonpos_of_le",
   "HEq",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "NonAssocSemiring.toMulZeroOneClass",
   "Finset.gcd",
   "IsCancelAdd.toIsRightCancelAdd",
   "Mathlib.Tactic.Ring.sub_pf",
   "GCDMonoid.gcd",
   "Int.instAddMonoid",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "zero_lt_one",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Mathlib.Tactic.Ring.mul_add",
   "Neg.neg",
   "Int.instMonoid",
   "LE.le",
   "Monoid.toMulOneClass",
   "Int.normalizationMonoid",
   "NormedCommRing.toSeminormedCommRing",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "instNatCastInt",
   "Mathlib.Tactic.Ring.one_mul",
   "letFun",
   "NegZeroClass.toNeg",
   "FltRegular.p_dvd_c_of_ab_of_anegc",
   "Mathlib.Tactic.Ring.mul_congr",
   "MulOneClass.toMul",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "dite",
   "NormalizedGCDMonoid.toGCDMonoid",
   "Units.isUnit",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Finset.ext",
   "Ring.toIntCast",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "true_or",
   "MonoidWithZeroHom",
   "Mathlib.Tactic.RingNF.nat_rawCast_1",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Int.instDvd",
   "Int.instHPowNat",
   "neg_neg_of_pos",
   "Nat.instSemiring",
   "Finset.instSingleton",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "MulZeroOneClass.toMulZeroClass",
   "ZMod",
   "Int.instLTInt",
   "Int.instGCDMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "Or.resolve_left",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "HEq.refl",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "mul_one",
   "Singleton.singleton",
   "Finset.gcd_singleton",
   "Int.ofNat",
   "StrictOrderedRing.toRing",
   "Linarith.lt_irrefl",
   "LinearOrderedRing.toStrictOrderedRing",
   "Mathlib.Tactic.Zify._auxLemma.2",
   "Mathlib.Algebra.Group.Basic._auxLemma.18",
   "normalize",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "CancelCommMonoidWithZero",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "DFunLike.coe",
   "instOfNatAtLeastTwo",
   "id",
   "sub_eq_zero_of_eq",
   "Membership.mem",
   "eq_self",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "Int.instNormalizedGCDMonoid",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "OrderedCommSemiring.toOrderedSemiring",
   "Units.val",
   "Finset.gcd_insert",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Bool",
   "Eq.casesOn",
   "Int.isUnit_iff",
   "OrderedSemiring.toPartialOrder",
   "Int.natAbs",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "AddCommSemigroup.toAddCommMagma",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "mul_neg",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Int.instDecidableEq",
   "Finset.instInsert",
   "neg_pow",
   "pow_one",
   "Mathlib.Meta.NormNum.isInt_add",
   "MulZeroClass.toMul",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "Nat.Prime",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.cast",
   "Int.natAbs_neg",
   "Mathlib.Tactic.Ring.neg_congr",
   "Linarith.lt_of_lt_of_eq",
   "MonoidWithZeroHom.funLike",
   "FltRegular.MayAssume.Lemmas._auxLemma.7",
   "instHSub",
   "HPow.hPow",
   "Or",
   "eq_of_heq",
   "FltRegular.MayAssume.Lemmas._auxLemma.4",
   "Int.instRing",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "FltRegular.MayAssume.Lemmas._auxLemma.5",
   "Mathlib.Tactic.Ring.neg_zero",
   "MonoidWithZero.toMulZeroOneClass",
   "eq_true",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "Exists",
   "FltRegular.MayAssume.Lemmas._auxLemma.6",
   "Int.instAddGroup",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Exists.intro",
   "NeZero.one",
   "AddMonoid.toAddZeroClass",
   "True",
   "AddMonoid.toAddSemigroup",
   "Int.instCovariantClassAddLE",
   "InvolutiveNeg.toNeg",
   "Eq.rec",
   "Finset",
   "neg_mul",
   "CommMonoidWithZero.toMonoidWithZero",
   "NonUnitalNonAssocRing.toMul",
   "Not.intro",
   "Ring.toAddGroupWithOne",
   "covariant_swap_add_of_covariant_add",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "Int.instMul",
   "Odd.neg_one_pow",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Int.instLinearOrderedCommRing",
   "Bool.false",
   "IsUnit",
   "Int.gcd_eq_natAbs",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "ZMod.intCast_eq_intCast_iff",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "Int.instNormedCommRing",
   "Exists.casesOn",
   "FltRegular.MayAssume.Lemmas._auxLemma.8",
   "Int.instAdd",
   "Preorder.toLE",
   "Mathlib.Tactic.RingNF.mul_assoc_rev",
   "Eq",
   "Eq.mpr",
   "Mathlib.Tactic.Zify._auxLemma.1",
   "Nat.Prime.eq_two_or_odd'",
   "Nat",
   "Odd",
   "Ne",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.rawCast",
   "Int.ModEq",
   "OrderedSemiring.zeroLEOneClass",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instAddCommSemigroup",
   "Iff.intro",
   "instHMul",
   "AddCancelMonoid.toIsCancelAdd",
   "Not",
   "add_zero",
   "congrArg",
   "Int.instLEInt",
   "OrderedAddCommGroup.toAddCommGroup",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Data.Finset.Basic._auxLemma.64",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "instLENat",
   "one_mul",
   "NormalizationMonoid.normUnit",
   "instHPow",
   "Preorder.toLT",
   "Linarith.mul_neg",
   "Int.instNegInt",
   "add_lt_of_neg_of_le",
   "Eq.symm",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "Int.instCancelCommMonoidWithZero",
   "GT.gt",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Nat.instCommSemiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "OrderedSemiring.toSemiring",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Int.instCommSemiring",
   "NegZeroClass.toZero",
   "ZMod.commRing",
   "Int.instNontrivial"],
  "name": "FltRegular.a_not_cong_b",
  "constType":
  "∀ {p : ℕ} {a b c : ℤ},\n  Nat.Prime p →\n    5 ≤ p →\n      a * b * c ≠ 0 →\n        a ^ p + b ^ p = c ^ p →\n          {a, b, c}.gcd id = 1 →\n            ¬↑p ∣ a * b * c →\n              ∃ x y z, x ^ p + y ^ p = z ^ p ∧ {x, y, z}.gcd id = 1 ∧ ¬x ≡ y [ZMOD ↑p] ∧ x * y * z ≠ 0 ∧ ¬↑p ∣ x * y * z",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finset",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": [],
  "name": "Decidable",
  "constType": "Prop → Type",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.Name.num._override",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["propext", "forall_apply_eq_imp_iff₂", "Eq"],
  "name": "FltRegular.NumberTheory.Different._auxLemma.6",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} {f : α → β} {p : α → Prop} {q : β → Prop},\n  (∀ (b : β) (a : α), p a → f a = b → q b) = ∀ (a : α), p a → q (f a)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_9",
   "Lean.ParserDescr.symbol"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "LT",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "MulOneClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Semiring", "Module", "AddCommMonoid"],
  "name": "Submodule",
  "constType":
  "(R : Type u) → (M : Type v) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Type v",
  "constCategory": "Other"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "dvd_gcd_iff",
   "And",
   "GCDMonoid.gcd",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "GCDMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "propext",
   "Dvd.dvd",
   "semigroupDvd",
   "CancelCommMonoidWithZero",
   "Eq",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "FltRegular.CaseII.Statement._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : GCDMonoid α] (a b c : α), (a ∣ gcd b c) = (a ∣ b ∧ a ∣ c)",
  "constCategory": "Theorem"},
 {"references": ["outParam", "SetLike", "Set"],
  "name": "SetLike.coe",
  "constType":
  "{A : Type u_1} → {B : outParam (Type u_2)} → [self : SetLike A B] → A → Set B",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "pow_mul",
   "Monoid",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instMulNat",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "FltRegular.NumberTheory.Different._auxLemma.1",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (m n : ℕ), (a ^ m) ^ n = a ^ (m * n)",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Fin",
  "constType": "ℕ → Type",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Submodule",
   "MulZeroOneClass.toMulOneClass",
   "Algebra.toModule",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Algebra",
   "IsFractional",
   "Submonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Subtype",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "FractionalIdeal",
  "constType":
  "{R : Type u_1} →\n  [inst : CommRing R] → Submonoid R → (P : Type u_2) → [inst_1 : CommRing P] → [inst : Algebra R P] → Type u_2",
  "constCategory": "Definition"},
 {"references": ["Field"],
  "name": "NumberField",
  "constType": "(K : Type u_1) → [inst : Field K] → Prop",
  "constCategory": "Other"},
 {"references": ["LT"],
  "name": "LT.lt",
  "constType": "{α : Type u} → [self : LT α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Semigroup.toMul",
   "instHAdd",
   "HAdd.hAdd",
   "LeftDistribClass",
   "Dvd.dvd",
   "semigroupDvd",
   "Dvd.intro",
   "True",
   "Eq",
   "instHMul",
   "of_eq_true",
   "Dvd.elim",
   "HMul.hMul",
   "congr",
   "Add",
   "congrArg",
   "left_distrib",
   "Eq.trans",
   "Semigroup"],
  "name": "dvd_add",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : Semigroup α] [inst_2 : LeftDistribClass α] {a b c : α},\n  a ∣ b → a ∣ c → a ∣ b + c",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_24"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_25._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "eq_true",
   "OfNat.ofNat",
   "NeZero",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "one_pos",
   "One.toOfNat1",
   "True",
   "Preorder.toLE",
   "Eq",
   "PartialOrder"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.11",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], (0 < 1) = True",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne", "One"],
  "name": "AddMonoidWithOne.toOne",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → One R",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "FiniteField.pow_card",
   "DivisionSemiring.toGroupWithZero",
   "Semiring.toMonoidWithZero",
   "Field.toSemifield",
   "NeZero.of_gt'",
   "Fintype.card",
   "CanonicallyOrderedCommSemiring.toOne",
   "ZMod.card",
   "GroupWithZero.toMonoidWithZero",
   "ZMod",
   "Eq",
   "ZMod.instField",
   "DivisionSemiring.toSemiring",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Nat.Prime",
   "Nat.Prime.one_lt'",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Eq.mp",
   "Nat.instCanonicallyOrderedCommSemiring",
   "letFun",
   "Monoid.toNatPow",
   "Semifield.toDivisionSemiring",
   "ZMod.fintype",
   "Nat",
   "congrArg",
   "Fact"],
  "name": "ZMod.pow_card",
  "constType": "∀ {p : ℕ} [inst : Fact (Nat.Prime p)] (x : ZMod p), x ^ p = x",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "Monoid.toOne",
   "MulZeroOneClass.mk",
   "MonoidWithZero.toMonoid",
   "Monoid.one_mul",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.toZero",
   "Monoid.mul_one",
   "MulOneClass.mk",
   "MulZeroOneClass",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toMulZeroOneClass",
  "constType":
  "{M₀ : Type u} → [self : MonoidWithZero M₀] → MulZeroOneClass M₀",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Unique",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "SubNegMonoid.toSub",
   "AddGroup",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "sub_eq_iff_eq_add",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "FltRegular.MayAssume.Lemmas._auxLemma.5",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, (a - b = c) = (a = c + b)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.add_succ",
   "HAdd.hAdd",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "True",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Nat.recAux",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.succ",
   "id",
   "eq_self",
   "add_assoc",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoidWithOne",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "congrArg",
   "add_zero"],
  "name": "Nat.cast_add",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] (m n : ℕ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Int.instDvd",
   "Iff.rfl",
   "Int.ModEq",
   "HSub.hSub",
   "Dvd.dvd",
   "ZMod",
   "Eq",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "instNatCastInt",
   "propext",
   "Int.cast",
   "Ring.toIntCast",
   "CommRing.toRing",
   "Int.modEq_iff_dvd",
   "Nat",
   "congrArg",
   "Int.instSub",
   "Int",
   "ZMod.intCast_eq_intCast_iff",
   "id",
   "ZMod.commRing"],
  "name": "ZMod.intCast_eq_intCast_iff_dvd_sub",
  "constType": "∀ (a b : ℤ) (c : ℕ), ↑a = ↑b ↔ ↑c ∣ b - a",
  "constCategory": "Theorem"},
 {"references": ["Nat.gcd_comm", "Nat", "Int", "Int.gcd", "Eq", "Int.natAbs"],
  "name": "Int.gcd_comm",
  "constType": "∀ (i j : ℤ), i.gcd j = j.gcd i",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "MulZeroOneClass.toMulOneClass",
   "CommSemiring",
   "Algebra",
   "Submonoid",
   "NonAssocSemiring.toMulZeroOneClass"],
  "name": "IsLocalization",
  "constType":
  "{R : Type u_1} →\n  [inst : CommSemiring R] → Submonoid R → (S : Type u_2) → [inst_1 : CommSemiring S] → [inst : Algebra R S] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "Exists",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "IsDomain",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Exists.casesOn",
   "AddGroupWithOne.toAddGroup",
   "True",
   "CommRing",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "Ring.toSub",
   "LocalRing.of_isUnit_or_isUnit_one_sub_self",
   "IsDomain.toNontrivial",
   "CommMonoid.toMonoid",
   "add_sub_cancel",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "instHSub",
   "NonUnitalNonAssocRing.toMul",
   "Or",
   "Ring.toAddGroupWithOne",
   "mul_add",
   "Or.inr",
   "isUnit_of_mul_eq_one",
   "MulOneClass.toOne",
   "instHAdd",
   "HSub.hSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "One.toOfNat1",
   "LocalRing",
   "Or.casesOn",
   "ValuationRing.cond",
   "Monoid.toMulOneClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "Semiring.toOne",
   "sub_add_cancel",
   "instHMul",
   "CommRing.toCommSemiring",
   "CommRing.toCommMonoid",
   "Or.inl",
   "of_eq_true",
   "congr",
   "HMul.hMul",
   "CommRing.toRing",
   "Ring.toAddCommGroup",
   "mul_one",
   "IsUnit",
   "congrArg",
   "ValuationRing"],
  "name": "ValuationRing.localRing",
  "constType":
  "∀ (A : Type u) [inst : CommRing A] [inst_1 : IsDomain A] [inst_2 : ValuationRing A], LocalRing A",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Eq.refl",
   "Nat.instAddMonoid",
   "AddMonoid.toAddZeroClass",
   "algebraRat",
   "pow_one",
   "Eq",
   "Zero.toOfNat0",
   "PNat.val",
   "zero_add",
   "AddZeroClass.toZero",
   "Rat.commRing",
   "Set.instSingletonSet",
   "Nat.Prime",
   "Eq.mpr",
   "IsPrimitiveRoot.toInteger",
   "instHPow",
   "Field",
   "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "CommMonoid.toMonoid",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "id",
   "HPow.hPow",
   "instHSub",
   "LinearOrderedCommMonoid.toOrderedCommMonoid",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "One.toOfNat1",
   "EuclideanDomain.toCommRing",
   "Semiring.toOne",
   "IsCyclotomicExtension",
   "OrderedCommMonoid.toCommMonoid",
   "CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "Prime",
   "CharZero",
   "Field.toEuclideanDomain",
   "instPNatLinearOrderedCancelCommMonoid",
   "CommRing.toRing",
   "Singleton.singleton",
   "congrArg",
   "Fact",
   "Field.toDivisionRing",
   "NumberField.RingOfIntegers",
   "IsPrimitiveRoot.zeta_sub_one_prime",
   "PNat"],
  "name": "IsPrimitiveRoot.zeta_sub_one_prime'",
  "constType":
  "∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] {ζ : K} [hp : Fact (Nat.Prime ↑p)]\n  [h : IsCyclotomicExtension {p} ℚ K] (hζ : IsPrimitiveRoot ζ ↑p), Prime (hζ.toInteger - 1)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Function.comp",
  "constType":
  "{α : Sort u} → {β : Sort v} → {δ : Sort w} → (β → δ) → (α → β) → α → δ",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "and_true_iff", "True", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.12",
  "constType": "∀ (p : Prop), (p ∧ True) = p",
  "constCategory": "Theorem"},
 {"references": ["not_or", "And", "Or", "propext", "Not", "Eq"],
  "name": "FltRegular.CaseII.Statement._auxLemma.5",
  "constType": "∀ {p q : Prop}, (¬(p ∨ q)) = (¬p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike",
   "Equiv.toFun",
   "AlgEquiv",
   "Equiv.invFun",
   "AlgEquiv.instEquivLike.proof_2",
   "AlgEquiv.toEquiv",
   "Semiring",
   "CommSemiring",
   "Algebra",
   "AlgEquiv.instEquivLike.proof_3",
   "AlgEquiv.instEquivLike.proof_1",
   "EquivLike.mk"],
  "name": "AlgEquiv.instEquivLike",
  "constType":
  "{R : Type uR} →\n  {A₁ : Type uA₁} →\n    {A₂ : Type uA₂} →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A₁] →\n          [inst_2 : Semiring A₂] → [inst_3 : Algebra R A₁] → [inst_4 : Algebra R A₂] → EquivLike (A₁ ≃ₐ[R] A₂) A₁ A₂",
  "constCategory": "Definition"},
 {"references": ["Monoid"],
  "name": "MulAction",
  "constType":
  "(α : Type u_11) → Type u_12 → [inst : Monoid α] → Type (max u_11 u_12)",
  "constCategory": "Other"},
 {"references": ["Zero", "LinearOrderedCommMonoidWithZero"],
  "name": "LinearOrderedCommMonoidWithZero.toZero",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommMonoidWithZero α] → Zero α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.instMonoid",
   "propext",
   "instOfNatNat",
   "IsUnit",
   "Nat",
   "Nat.isUnit_iff",
   "Eq"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.7",
  "constType": "∀ {n : ℕ}, IsUnit n = (n = 1)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "Unit",
   "Int.natAbs_neg.match_1",
   "Int.instNegInt",
   "Neg.neg",
   "Nat",
   "Nat.succ",
   "instOfNat",
   "rfl",
   "Int",
   "Int.natAbs",
   "Eq"],
  "name": "Int.natAbs_neg",
  "constType": "∀ (a : ℤ), (-a).natAbs = a.natAbs",
  "constCategory": "Theorem"},
 {"references":
  ["LinearOrderedCommRing.toLinearOrderedRing",
   "StrictOrderedRing.toRing",
   "StrictOrderedRing.toPartialOrder",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_10",
   "StrictOrderedCommSemiring.mk",
   "LinearOrderedCommSemiring.mk",
   "LinearOrderedRing.toStrictOrderedRing",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_3",
   "LinearOrderedRing.decidableEq",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_6",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_9",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_1",
   "Ring.toSemiring",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_8",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_2",
   "LinearOrderedCommSemiring",
   "LinearOrderedRing.decidableLE",
   "StrictOrderedSemiring.mk",
   "LinearOrderedRing.toOrd",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_5",
   "LinearOrderedSemiring",
   "LinearOrderedCommRing",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_7",
   "LinearOrderedCommRing.mul_comm",
   "LinearOrderedRing.toLinearOrderedSemiring",
   "LinearOrderedRing.toMin",
   "LinearOrderedRing.toMax",
   "LinearOrderedRing.decidableLT",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring.proof_4"],
  "name": "LinearOrderedCommRing.toLinearOrderedCommSemiring",
  "constType":
  "{α : Type u} → [d : LinearOrderedCommRing α] → LinearOrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.lt_or_ge.match_2",
   "Or",
   "instLENat",
   "LT.lt",
   "GE.ge",
   "Nat.lt_or_ge",
   "Not",
   "Nat",
   "Nat.le_antisymm",
   "absurd",
   "instLTNat",
   "LE.le",
   "Eq"],
  "name": "Nat.lt_of_le_of_ne",
  "constType": "∀ {n m : ℕ}, n ≤ m → ¬n = m → n < m",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "EStateM",
   "Function.comp",
   "Unit",
   "Function.const",
   "Functor.mk",
   "Monad.mk",
   "Applicative.mk",
   "EStateM.seqRight",
   "EStateM.bind",
   "EStateM.pure",
   "Pure.mk",
   "Unit.unit",
   "Seq.mk",
   "SeqRight.mk",
   "EStateM.map",
   "Bind.mk",
   "SeqLeft.mk"],
  "name": "EStateM.instMonad",
  "constType": "{ε σ : Type u} → Monad (EStateM ε σ)",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Name.num._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_35"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_36._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "And",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "LinearOrder.toMax",
   "Max.max",
   "SemilatticeInf.toPartialOrder",
   "max_lt_iff",
   "instDistribLatticeOfLinearOrder",
   "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.22",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, (max a b < c) = (a < c ∧ b < c)",
  "constCategory": "Theorem"},
 {"references": ["List", "String", "Lean.Syntax.Preresolved", "Lean.Name"],
  "name": "Lean.Syntax.Preresolved.decl",
  "constType": "Lean.Name → List String → Lean.Syntax.Preresolved",
  "constCategory": "Other"},
 {"references": ["Classical.not_not", "propext", "Not", "Eq"],
  "name": "FltRegular.NumberTheory.KummersLemma.KummersLemma._auxLemma.9",
  "constType": "∀ {a : Prop}, (¬¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Group.toDivisionMonoid",
   "Membership.mem",
   "InvOneClass.toOne",
   "OfNat.ofNat",
   "Bot.bot",
   "Iff",
   "DivInvOneMonoid.toInvOneClass",
   "Iff.rfl",
   "Subgroup",
   "One.toOfNat1",
   "Group",
   "DivisionMonoid.toDivInvOneMonoid",
   "Subgroup.instSetLike",
   "Subgroup.instBot",
   "SetLike.instMembership",
   "Eq"],
  "name": "Subgroup.mem_bot",
  "constType": "∀ {G : Type u_1} [inst : Group G] {x : G}, x ∈ ⊥ ↔ x = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Or.resolve_left",
   "Ne",
   "OfNat.ofNat",
   "Nat.Prime",
   "Nat.instSemiring",
   "instOfNatNat",
   "Nat.Prime.eq_two_or_odd'",
   "Odd",
   "Nat",
   "Eq"],
  "name": "Nat.Prime.odd_of_ne_two",
  "constType": "∀ {p : ℕ}, Nat.Prime p → p ≠ 2 → Odd p",
  "constCategory": "Theorem"},
 {"references":
  ["Ne",
   "PartialOrder.toPreorder",
   "LT.lt.le",
   "instHAdd",
   "HAdd.hAdd",
   "LE.le",
   "Preorder.toLE",
   "Iff.mpr",
   "LT.lt.ne",
   "PartialOrder",
   "CovariantClass.elim",
   "LE.le.lt_of_ne",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "Add",
   "CovariantClass.mk",
   "add_ne_add_right",
   "IsLeftCancelAdd"],
  "name": "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
  "constType":
  "∀ (N : Type u_2) [inst : Add N] [inst_1 : IsLeftCancelAdd N] [inst_2 : PartialOrder N]\n  [inst_3 : CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1],\n  CovariantClass N N (fun x x_1 => x + x_1) fun x x_1 => x < x_1",
  "constCategory": "Definition"},
 {"references":
  ["Subtype.ext_iff", "propext", "Subtype.val", "Eq.symm", "Subtype", "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.17",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, (↑a1 = ↑a2) = (a1 = a2)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Name.mkStr3",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_26",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_27",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_28"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_29._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Nat.rawCast",
   "Semiring.toMonoidWithZero",
   "One.toOfNat1",
   "one_pow",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "congr",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one"],
  "name": "Mathlib.Tactic.Ring.one_pow",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (b : ℕ), Nat.rawCast 1 ^ b = Nat.rawCast 1",
  "constCategory": "Theorem"},
 {"references": ["Int.neg.match_1", "Nat", "Nat.succ", "Int"],
  "name": "Int.natAbs",
  "constType": "ℤ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "add_assoc",
   "SubNegMonoid",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Neg.neg",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "id"],
  "name": "add_sub_assoc",
  "constType":
  "∀ {G : Type u_3} [inst : SubNegMonoid G] (a b c : G), a + b - c = a + (b - c)",
  "constCategory": "Theorem"},
 {"references":
  ["Units", "Monoid", "propext", "Units.val", "Units.eq_iff", "Eq.symm", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert90._auxLemma.5",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] {a b : αˣ}, (a = b) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references": ["Mul", "Nat", "Nat.mul", "Mul.mk"],
  "name": "instMulNat",
  "constType": "Mul ℕ",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.ParserDescr.symbol",
   "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_9"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "OreLocalization.OreSet",
   "RingHom",
   "Module.toDistribMulAction",
   "MulZeroOneClass.toMulOneClass",
   "RingHom.comp",
   "Semiring.toMonoidWithZero",
   "OreLocalization.instModuleOfIsScalarTower",
   "AddCommMonoid.toAddMonoid",
   "OreLocalization.instAlgebra.proof_1",
   "OreLocalization.instAddCommMonoidOreLocalization",
   "NonAssocSemiring.toMulZeroOneClass",
   "Semiring.toNonAssocSemiring",
   "OreLocalization.instAlgebra.proof_2",
   "MonoidWithZero.toMonoid",
   "CommSemiring",
   "OreLocalization.instSemiring",
   "MonoidWithZero.toMulActionWithZero",
   "Algebra",
   "OreLocalization.numeratorRingHom",
   "Module",
   "MulActionWithZero.toMulAction",
   "Semiring.toModule",
   "DistribMulAction.toMulAction",
   "IsScalarTower.right",
   "Algebra.toModule",
   "Semiring",
   "algebraMap",
   "MulAction.toSMul",
   "OreLocalization",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Submonoid",
   "inferInstanceAs",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Algebra.mk"],
  "name": "OreLocalization.instAlgebra",
  "constType":
  "{R : Type u_1} →\n  [inst : Semiring R] →\n    {S : Submonoid R} →\n      [inst_1 : OreLocalization.OreSet S] →\n        {R₀ : Type u_3} → [inst_2 : CommSemiring R₀] → [inst_3 : Algebra R₀ R] → Algebra R₀ (OreLocalization S R)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "DivInvMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_19",
   "_obj",
   "Lean.Name.num._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_20._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "instHSMul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HSMul.hSMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.hasSMul'",
   "Mul",
   "Ideal",
   "Semiring.toModule",
   "Mul.mk"],
  "name": "Ideal.instMul",
  "constType": "{R : Type u} → [inst : CommSemiring R] → Mul (Ideal R)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "False",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["Zero"],
  "name": "Finsupp",
  "constType":
  "Type u_13 → (M : Type u_14) → [inst : Zero M] → Type (max u_13 u_14)",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toMul",
   "RingCon.Quotient",
   "Ideal.Quotient.ringCon",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "CommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "CommRing.toCommSemiring",
   "RingCon.instCommRingQuotient",
   "inferInstanceAs",
   "HasQuotient.Quotient",
   "Ideal.instHasQuotient",
   "Ideal",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Ideal.Quotient.commRing",
  "constType":
  "{R : Type u} → [inst : CommRing R] → (I : Ideal R) → CommRing (R ⧸ I)",
  "constCategory": "Definition"},
 {"references": ["outParam", "Membership"],
  "name": "Membership.mem",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Membership α γ] → α → γ → Prop",
  "constCategory": "Definition"},
 {"references": ["outParam", "DFunLike"],
  "name": "DFunLike.coe",
  "constType":
  "{F : Sort u_1} → {α : outParam (Sort u_2)} → {β : outParam (α → Sort u_3)} → [self : DFunLike F α β] → F → (a : α) → β a",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_39._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Zero", "AddMonoid"],
  "name": "AddMonoid.toZero",
  "constType": "{M : Type u} → [self : AddMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "ZMod.val.match_1",
   "instAddNat",
   "instHAdd",
   "Fin.val",
   "HAdd.hAdd",
   "Unit",
   "instOfNatNat",
   "Nat",
   "ZMod",
   "Int.natAbs"],
  "name": "ZMod.val",
  "constType": "{n : ℕ} → ZMod n → ℕ",
  "constCategory": "Definition"},
 {"references": ["Pure"],
  "name": "Pure.pure",
  "constType":
  "{f : Type u → Type v} → [self : Pure f] → {α : Type u} → α → f α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "Semifield.toCommSemiring",
   "NumberField.RingOfIntegers.instCommRing",
   "algebraRat",
   "algebraInt",
   "integralClosure",
   "AlgHom.codRestrict",
   "intGal.proof_1",
   "Field",
   "NormedRing.toRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "gal_map_mem_subtype",
   "Rat.commSemiring",
   "AlgHom.restrictScalars",
   "Rat",
   "Field.toSemifield",
   "NormedCommRing.toNormedRing",
   "AlgHom.restrictDomain",
   "NormedField.toNormedCommRing",
   "EuclideanDomain.toCommRing",
   "AlgHom",
   "DivisionSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "intGal.proof_2",
   "CharZero",
   "Field.toEuclideanDomain",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "Algebra.id",
   "Int.instCommSemiring",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Int",
   "Rat.instNormedField",
   "NumberField.RingOfIntegers.instAlgebra_1"],
  "name": "intGal",
  "constType":
  "{K : Type u_1} →\n  [inst : Field K] →\n    [inst_1 : CharZero K] → (K →ₐ[ℚ] K) → NumberField.RingOfIntegers K →ₐ[ℤ] NumberField.RingOfIntegers K",
  "constCategory": "Definition"},
 {"references": ["SubtractionCommMonoid", "SubtractionMonoid"],
  "name": "SubtractionCommMonoid.toSubtractionMonoid",
  "constType":
  "{G : Type u} → [self : SubtractionCommMonoid G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Group",
   "Group.toDivInvMonoid",
   "mul_left_inv",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Inv.inv",
   "Eq"],
  "name": "inv_mul_self",
  "constType": "∀ {G : Type u_1} [inst : Group G] (a : G), a⁻¹ * a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Prime.pos",
   "OfNat.ofNat",
   "Nat.Prime",
   "Fact.mk",
   "LT.lt",
   "Fact.out",
   "instOfNatNat",
   "Nat",
   "Fact",
   "instLTNat"],
  "name": "instFactLtNatOfNatOfPrime_fltRegular",
  "constType": "∀ {p : ℕ} [hp : Fact (Nat.Prime p)], Fact (0 < p)",
  "constCategory": "Definition"},
 {"references": ["String", "String.toSubstring", "Substring"],
  "name": "String.toSubstring'",
  "constType": "String → Substring",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "IntCast"],
  "name": "AddGroupWithOne.toIntCast",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → IntCast R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "DecidablePred",
   "And",
   "propext",
   "Finset",
   "Finset.mem_filter",
   "Finset.filter",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.18",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α} {a : α}, (a ∈ Finset.filter p s) = (a ∈ s ∧ p a)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "RingHom",
   "OfNat.ofNat",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "MvPolynomial.monomial",
   "MulZeroOneClass.toMulOneClass",
   "MvPolynomial.C.proof_3",
   "LinearMap.instFunLike",
   "Nat.instAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.mk",
   "RingHom.id",
   "AddMonoidAlgebra",
   "MvPolynomial.commSemiring",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "AddMonoidAlgebra.singleZeroRingHom",
   "CommSemiring",
   "LinearOrderedCommMonoidWithZero.toZero",
   "OneHom.mk",
   "MvPolynomial.C.proof_1",
   "MonoidHom.mk",
   "Nat",
   "DFunLike.coe",
   "Finsupp.instZero",
   "LinearMap",
   "Semiring.toModule",
   "Finsupp",
   "MvPolynomial.C.proof_2",
   "MulOneClass.toOne",
   "MvPolynomial.C.proof_4",
   "MvPolynomial",
   "AddMonoidAlgebra.nonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Finsupp.instAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MvPolynomial.module"],
  "name": "MvPolynomial.C",
  "constType":
  "{R : Type u} → {σ : Type u_1} → [inst : CommSemiring R] → R →+* MvPolynomial σ R",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Eq.refl",
   "DivInvMonoid.Pow",
   "inv_one",
   "True",
   "DivInvMonoid.zpow_neg'",
   "Eq",
   "DivisionMonoid",
   "Eq.mpr",
   "Nat.cast",
   "instHPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Int.instNegInt",
   "InvolutiveInv.toInv",
   "Nat",
   "Eq.symm",
   "DivisionMonoid.toInvolutiveInv",
   "InvOneClass.toInv",
   "instOfNat",
   "Eq.trans",
   "zpow_negSucc",
   "id",
   "HPow.hPow",
   "eq_self",
   "instAddNat",
   "instHAdd",
   "Unit",
   "Neg.neg",
   "One.toOfNat1",
   "inv_inv",
   "zpow_natCast",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "InvOneClass.toOne",
   "instNatCastInt",
   "of_eq_true",
   "Int.negSucc",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "letFun",
   "congr",
   "zpow_zero",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "Int",
   "zpow_neg.match_1",
   "Inv.inv"],
  "name": "zpow_neg",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionMonoid α] (a : α) (n : ℤ), a ^ (-n) = (a ^ n)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "One.toOfNat1",
   "instLTNat",
   "CommRing",
   "Finset.instMembership",
   "Eq",
   "Semiring.toOne",
   "Polynomial.nthRootsFinset",
   "CommRing.toCommSemiring",
   "MonoidWithZero.toMonoid",
   "Polynomial.mem_nthRootsFinset",
   "propext",
   "instHPow",
   "LT.lt",
   "Finset",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.2",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {n : ℕ},\n  0 < n → ∀ {x : R}, (x ∈ Polynomial.nthRootsFinset n R) = (x ^ n = 1)",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNormedRing", "NonUnitalNormedCommRing"],
  "name": "NonUnitalNormedCommRing.toNonUnitalNormedRing",
  "constType":
  "{α : Type u_5} → [self : NonUnitalNormedCommRing α] → NonUnitalNormedRing α",
  "constCategory": "Definition"},
 {"references": ["HEq"],
  "name": "HEq.refl",
  "constType": "∀ {α : Sort u} (a : α), HEq a a",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "CommMonoidWithZero.toZero",
   "Or",
   "OfNat.ofNat",
   "Dvd.dvd",
   "semigroupDvd",
   "MulZeroOneClass.toMulZeroClass",
   "CommMonoidWithZero",
   "MulZeroClass.toMul",
   "Zero.toOfNat0",
   "SemigroupWithZero.toSemigroup",
   "MonoidWithZero.toMulZeroOneClass",
   "And",
   "instHMul",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "HMul.hMul",
   "Not",
   "IsUnit",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "Prime",
  "constType": "{α : Type u_1} → [inst : CommMonoidWithZero α] → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Module.toDistribMulAction",
   "MulZeroOneClass.toMulOneClass",
   "map_smul",
   "Semiring.toMonoidWithZero",
   "AlgHomClass.linearMapClass",
   "AddCommMonoid.toAddMonoid",
   "AlgHomClass.toRingHomClass",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.id",
   "DistribMulActionSemiHomClass.mk",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "RingHomClass.toAddMonoidHomClass",
   "FunLike",
   "MonoidWithZero.toMonoid",
   "DistribSMul.toSMulZeroClass",
   "CommSemiring",
   "AddMonoid.toZero",
   "Algebra",
   "MonoidHom.id",
   "DFunLike.coe",
   "NonUnitalAlgSemiHomClass.mk",
   "NonUnitalAlgHomClass",
   "DistribMulAction.toDistribSMul",
   "AlgHomClass",
   "Algebra.toModule",
   "MonoidHomClass.toMulHomClass",
   "Semiring",
   "MonoidHom",
   "Monoid.toMulOneClass",
   "SemilinearMapClass.toMulActionSemiHomClass",
   "SMulZeroClass.toSMul",
   "RingHomClass.toMonoidHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MulActionSemiHomClass.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidHom.instFunLike"],
  "name": "AlgHom.instNonUnitalAlgHomClassOfAlgHomClass",
  "constType":
  "∀ {F : Type u_1} {R : Type u_2} [inst : CommSemiring R] {A : Type u_3} {B : Type u_4} [inst_1 : Semiring A]\n  [inst_2 : Semiring B] [inst_3 : Algebra R A] [inst_4 : Algebra R B] [inst_5 : FunLike F A B]\n  [inst_6 : AlgHomClass F R A B], NonUnitalAlgHomClass F R A B",
  "constCategory": "Definition"},
 {"references": ["Semigroup", "SemigroupWithZero"],
  "name": "SemigroupWithZero.toSemigroup",
  "constType": "{S₀ : Type u} → [self : SemigroupWithZero S₀] → Semigroup S₀",
  "constCategory": "Definition"},
 {"references":
  ["Add", "Lean.Omega.LinearCombo.add", "Lean.Omega.LinearCombo", "Add.mk"],
  "name": "Lean.Omega.LinearCombo.instAdd",
  "constType": "Add Lean.Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "Finsupp.instFunLike",
   "Finsupp",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "MvPolynomial",
   "CommSemiring",
   "LinearOrderedCommMonoidWithZero.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "DFunLike.coe",
   "Nat"],
  "name": "MvPolynomial.coeff",
  "constType":
  "{R : Type u} → {σ : Type u_1} → [inst : CommSemiring R] → (σ →₀ ℕ) → MvPolynomial σ R → R",
  "constCategory": "Definition"},
 {"references":
  ["lt_of_le_not_le",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Or.resolve_right",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "le_total"],
  "name": "lt_of_not_ge",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≥ b → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_6",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_1"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["NonAssocRing", "NonUnitalNonAssocRing"],
  "name": "NonAssocRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_8",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_32"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_33._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Lean.Omega.LinearCombo.mk",
   "List.nil",
   "Nat",
   "Lean.Omega.Coeffs.set",
   "Lean.Omega.LinearCombo",
   "instOfNat",
   "Int"],
  "name": "Lean.Omega.LinearCombo.coordinate",
  "constType": "ℕ → Lean.Omega.LinearCombo",
  "constCategory": "Definition"},
 {"references": ["Iff", "iff_true_intro", "rfl", "True", "Eq"],
  "name": "eq_self_iff_true",
  "constType": "∀ {α : Sort u_1} (a : α), a = a ↔ True",
  "constCategory": "Theorem"},
 {"references": ["not_exists", "Exists", "propext", "Not", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.19",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) = ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["OmegaCompletePartialOrder.mk",
   "CompleteSemilatticeInf.toPartialOrder",
   "PartialOrder.toPreorder",
   "CompleteLattice",
   "OmegaCompletePartialOrder.Chain",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_2",
   "OmegaCompletePartialOrder.Chain.instFunLikeNat",
   "OmegaCompletePartialOrder",
   "CompleteLattice.instOmegaCompletePartialOrder.proof_1",
   "iSup",
   "DFunLike.coe",
   "Nat",
   "CompleteLattice.toCompleteSemilatticeInf",
   "CompleteLattice.toSupSet"],
  "name": "CompleteLattice.instOmegaCompletePartialOrder",
  "constType":
  "(α : Type u) → [inst : CompleteLattice α] → OmegaCompletePartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "MulZeroClass.mul_zero",
   "pow_eq_zero.match_1",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "PProd",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "PUnit",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "Eq.trans",
   "Or.elim",
   "id",
   "MonoidWithZero",
   "HPow.hPow",
   "mul_eq_zero",
   "Or",
   "Nat.below",
   "Nat.brecOn",
   "congr_arg",
   "instAddNat",
   "instHAdd",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "MulZeroOneClass.toMulZeroClass",
   "pow_zero",
   "NoZeroDivisors",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "propext",
   "Eq.mp",
   "HMul.hMul",
   "congr",
   "pow_succ",
   "mul_one",
   "MonoidWithZero.toZero",
   "congrArg"],
  "name": "pow_eq_zero",
  "constType":
  "∀ {M₀ : Type u_2} [inst : MonoidWithZero M₀] {a : M₀} [inst_1 : NoZeroDivisors M₀] {n : ℕ}, a ^ n = 0 → a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AlgEquiv",
   "CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "Set",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "AlgEquivClass.toAlgHomClass",
   "AlgHomClass.toAlgHom",
   "intGal",
   "algebraInt",
   "algebraRat",
   "rfl",
   "AlgEquiv.instAlgEquivClass",
   "Eq",
   "Rat.commRing",
   "Set.instSingletonSet",
   "MonoidWithZero.toMonoid",
   "Field",
   "Units.instMulOneClass",
   "DFunLike.coe",
   "AlgEquiv.instEquivLike",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Rat.commSemiring",
   "Rat",
   "Field.toSemifield",
   "MonoidHom",
   "EuclideanDomain.toCommRing",
   "AlgHom",
   "AlgEquiv.instFunLike",
   "unitGalConj",
   "IsCyclotomicExtension",
   "DivisionSemiring.toSemiring",
   "Units",
   "CommRing.toCommSemiring",
   "CharZero",
   "Field.toEuclideanDomain",
   "AlgHom.funLike",
   "Units.val",
   "CommRing.toRing",
   "galConj",
   "Semifield.toDivisionSemiring",
   "Singleton.singleton",
   "MonoidHom.instFunLike",
   "Int.instCommSemiring",
   "Field.toDivisionRing",
   "NumberField.RingOfIntegers",
   "Int",
   "PNat"],
  "name": "FltRegular.CaseI.coe_unitGalConj",
  "constType":
  "∀ {p : ℕ+} {K : Type u_1} [inst : Field K] [inst_1 : CharZero K] [inst_2 : IsCyclotomicExtension {p} ℚ K]\n  (x : (NumberField.RingOfIntegers K)ˣ), ↑((unitGalConj K p) x) = (intGal ↑(galConj K p)) ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["ENat",
   "Nat.instCanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring",
   "Nat.instNontrivial",
   "WithTop.instCanonicallyOrderedCommSemiringOfNontrivial",
   "Nat",
   "instDecidableEqNat"],
  "name": "instENatCanonicallyOrderedCommSemiring",
  "constType": "CanonicallyOrderedCommSemiring ℕ∞",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "DivisionRing",
   "Monoid.mk",
   "DivisionRing.div_eq_mul_inv",
   "NonUnitalSemiring.mul_assoc",
   "DivisionRing.zpow_succ'",
   "DivisionRing.toRing",
   "DivisionRing.zpow_zero'",
   "DivInvMonoid",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "DivInvMonoid.mk",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Ring.toSemiring",
   "Semiring.one_mul",
   "DivisionRing.zpow_neg'",
   "DivisionRing.zpow",
   "DivisionRing.toInv",
   "Semiring.toOne",
   "Semiring.npow",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "DivisionRing.toDiv",
   "Semigroup.mk"],
  "name": "DivisionRing.toDivInvMonoid",
  "constType": "{α : Type u_4} → [self : DivisionRing α] → DivInvMonoid α",
  "constCategory": "Definition"},
 {"references": ["MulZeroOneClass"],
  "name": "MonoidWithZeroHom",
  "constType":
  "(α : Type u_7) → (β : Type u_8) → [inst : MulZeroOneClass α] → [inst : MulZeroOneClass β] → Type (max u_7 u_8)",
  "constCategory": "Other"},
 {"references": ["Div.mk", "Div", "Int.ediv", "Int"],
  "name": "Int.instDiv",
  "constType": "Div ℤ",
  "constCategory": "Definition"},
 {"references": ["Monoid", "MonoidWithZero"],
  "name": "MonoidWithZero.toMonoid",
  "constType": "{M₀ : Type u} → [self : MonoidWithZero M₀] → Monoid M₀",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "LT.lt",
   "Fact.out",
   "instOfNatNat",
   "Nat",
   "Fact",
   "instLTNat"],
  "name": "IsRegularNumber.proof_1",
  "constType": "∀ (n : ℕ) [hn : Fact (0 < n)], 0 < n",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Monoid.toSemigroup",
   "Exists",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "instHPow",
   "HAdd.hAdd",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Dvd.dvd",
   "Not",
   "semigroupDvd",
   "Nat"],
  "name": "multiplicity.Finite",
  "constType": "{α : Type u_1} → [inst : Monoid α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "RingHom.instRingHomClass",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Units.instInv",
   "DivInvMonoid.Pow",
   "Semifield.toCommGroupWithZero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "algebraRat",
   "MulZeroClass.toMul",
   "AddGroupWithOne.toAddGroup",
   "NumberField.RingOfIntegers.val",
   "RingHomClass.toMonoidWithZeroHomClass",
   "Field",
   "IsPrimitiveRoot.unit'",
   "map_mul",
   "MonoidHom.id",
   "InvOneClass.toInv",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "AlgEquiv.instEquivLike",
   "HPow.hPow",
   "Or",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "AlgEquiv.instFunLike",
   "MonoidWithZero.toMulZeroOneClass",
   "CommRing.toCommMonoid",
   "RingHomClass.toMonoidHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "MonoidWithZero.toZero",
   "Field.toDivisionRing",
   "DivisionMonoid.toDivInvOneMonoid",
   "Int",
   "NumberField.RingOfIntegers.instAlgebra_1",
   "Inv.inv",
   "NonUnitalAlgHomClass.instLinearMapClass",
   "AlgEquiv",
   "Set",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AlgEquivClass.toAlgHomClass",
   "AddMonoid.toAddZeroClass",
   "algebraInt",
   "RingHom.id",
   "RingHomClass.toNonUnitalRingHomClass",
   "galConj_zeta_runity",
   "map_intCast",
   "RingHomClass.toAddMonoidHomClass",
   "intGal_apply_coe",
   "Eq.rec",
   "AddGroup.toAddCancelMonoid",
   "inv_zpow",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "CommGroupWithZero.toDivisionCommMonoid",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "NonUnitalAlgSemiHomClass.toMulHomClass",
   "algebraMap",
   "Field.toSemifield",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AlgHom",
   "Monoid.toMulOneClass",
   "IsCyclotomicExtension",
   "Units",
   "CommRing.toCommSemiring",
   "Or.inl",
   "DivisionMonoid.toDivInvMonoid",
   "Semifield.toDivisionSemiring",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "PNat",
   "Module.toDistribMulAction",
   "FltRegular.NumberTheory.Cyclotomic.CaseI._auxLemma.3",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "Semifield.toCommSemiring",
   "AddGroup.toSubtractionMonoid",
   "NonUnitalRingHomClass.toMulHomClass",
   "AlgHomClass.toRingHomClass",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "Ring.toIntCast",
   "HPow",
   "DivisionRing.toDivInvMonoid",
   "Eq.trans",
   "DivisionSemiring.toGroupWithZero",
   "NumberField.Units.coe_zpow",
   "GroupWithZero.toDivInvMonoid",
   "EuclideanDomain.toCommRing",
   "MulZeroOneClass.toMulZeroClass",
   "RingHom.instFunLike",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "SemilinearMapClass.toAddHomClass",
   "AlgHom.instNonUnitalAlgHomClassOfAlgHomClass",
   "NonAssocRing.toIntCast",
   "AddCancelMonoid.toIsCancelAdd",
   "Int.cast",
   "Field.toEuclideanDomain",
   "DivInvOneMonoid.toInvOneClass",
   "CommRing.toRing",
   "Singleton.singleton",
   "zpow_neg",
   "Algebra.id",
   "map_zpow₀",
   "CancelMonoidWithZero.toMonoidWithZero",
   "congrArg",
   "FltRegular.NumberTheory.Cyclotomic.CaseI._auxLemma.1",
   "Units.instDivInvMonoid",
   "CommGroup.toDivisionCommMonoid",
   "RingHom",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "CommRing.toNonUnitalCommRing",
   "NumberField.RingOfIntegers.instCommRing",
   "FltRegular.NumberTheory.Cyclotomic.CaseI._auxLemma.2",
   "AlgHomClass.toAlgHom",
   "intGal",
   "Ring.toNonAssocRing",
   "AlgEquiv.instAlgEquivClass",
   "Zero.toOfNat0",
   "PNat.val",
   "Rat.commRing",
   "Set.instSingletonSet",
   "AlgHom.algHomClass",
   "instHPow",
   "Int.instNegInt",
   "DFunLike.coe",
   "Eq.symm",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "IsCancelAdd.toIsLeftCancelAdd",
   "Algebra.toModule",
   "instHAdd",
   "Rat.commSemiring",
   "IsDomain.toCancelMonoidWithZero",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "map_add",
   "Field.isDomain",
   "DivisionSemiring.toSemiring",
   "NumberField.RingOfIntegers.ext",
   "CharZero",
   "Units.instCommGroupUnits",
   "Units.val",
   "AlgHom.funLike",
   "HMul.hMul",
   "galConj",
   "NegZeroClass.toZero",
   "NumberField.RingOfIntegers",
   "Int.instCommSemiring",
   "map_units_inv"],
  "name": "FltRegular.CaseI.exists_int_sum_eq_zero'_aux",
  "constType":
  "∀ {p : ℕ+} {K : Type u_1} [inst : Field K] [inst_1 : CharZero K] [inst_2 : IsCyclotomicExtension {p} ℚ K] {ζ : K}\n  (hζ : IsPrimitiveRoot ζ ↑p) (x y i : ℤ),\n  (intGal ↑(galConj K p)) (↑x + ↑y * ↑(hζ.unit' ^ i)) = ↑x + ↑y * ↑(hζ.unit' ^ (-i))",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "InvolutiveNeg.toNeg",
   "propext",
   "HasDistribNeg.toInvolutiveNeg",
   "dvd_neg",
   "Neg.neg",
   "Dvd.dvd",
   "HasDistribNeg",
   "semigroupDvd",
   "Semigroup",
   "Eq"],
  "name": "FltRegular.NumberTheory.KummersLemma.KummersLemma._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} [inst : Semigroup α] [inst_1 : HasDistribNeg α] {a b : α}, (a ∣ -b) = (a ∣ b)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "LE", "LE.le", "Eq"],
  "name": "le_of_le_of_eq",
  "constType":
  "∀ {α : Type u} {a b c : α} [inst : LE α], a ≤ b → b = c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_43",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_44._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "Distrib.toAdd",
   "instHMul",
   "CommSemiring.toSemiring",
   "Exists",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "CommSemiring",
   "HMul.hMul",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq"],
  "name": "IsCoprime",
  "constType": "{R : Type u} → [inst : CommSemiring R] → R → R → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddGroup",
   "AddGroup.toSubtractionMonoid.proof_1",
   "SubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid.proof_2",
   "SubtractionMonoid.mk"],
  "name": "AddGroup.toSubtractionMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → SubtractionMonoid G",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "SMulZeroClass",
  "constType":
  "Type u_10 → (A : Type u_11) → [inst : Zero A] → Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "One",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "zero_le",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "ZeroLEOneClass.mk",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "canonicallyOrderedAddCommMonoid.toZeroLeOneClass",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : One α], ZeroLEOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm", "Iff", "Fin.val", "Nat", "Fin.val_inj", "Fin", "Eq"],
  "name": "Fin.ext_iff",
  "constType": "∀ {n : ℕ} {a b : Fin n}, a = b ↔ ↑a = ↑b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CancelMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references": ["Nat"],
  "name": "Nat.AtLeastTwo",
  "constType": "ℕ → Prop",
  "constCategory": "Other"},
 {"references": ["MulOneClass", "Mul"],
  "name": "MulOneClass.toMul",
  "constType": "{M : Type u} → [self : MulOneClass M] → Mul M",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "SubNegMonoid.toNeg",
   "FltRegular.MayAssume.Lemmas._auxLemma.1",
   "Or.resolve_right",
   "AddGroupWithOne.toAddGroup",
   "Mathlib.Meta.NormNum.isInt_add",
   "pow_one",
   "Semiring.toNatCast",
   "SubNegMonoid.toSub",
   "Nat.Prime",
   "Nat.cast",
   "IsDomain.to_noZeroDivisors",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.cast_neg",
   "Int.instSub",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "instHSub",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.instRing",
   "ZMod.pow_card",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Mathlib.Tactic.Ring.neg_zero",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instNatAtLeastTwo",
   "congr",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Field.toDivisionRing",
   "Int",
   "Mathlib.Tactic.Ring.add_overlap_pf",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Semiring.toMonoidWithZero",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Int.rawCast",
   "Eq.refl",
   "Mathlib.Tactic.Ring.sub_congr",
   "AddMonoid.toAddZeroClass",
   "ZMod.natCast_zmod_eq_zero_iff_dvd",
   "Mathlib.Tactic.Ring.sub_pf",
   "AddMonoidWithOne.toNatCast",
   "Int.instAddMonoid",
   "AddMonoid.toAddSemigroup",
   "Monoid.toNatPow",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Or.inr",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instMul",
   "Field.toSemifield",
   "Neg.neg",
   "One.toOfNat1",
   "Int.cast_sub",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "ZMod.instIsDomain",
   "CommRing.toCommSemiring",
   "Or.inl",
   "instNatCastInt",
   "Fact.mk",
   "letFun",
   "Nat.dvd_prime",
   "Semifield.toDivisionSemiring",
   "Ring.toAddCommGroup",
   "FltRegular.MayAssume.Lemmas._auxLemma.2",
   "Mathlib.Tactic.Ring.atom_pf",
   "Mathlib.Tactic.RingNF.int_rawCast_neg",
   "Int.cast_pow",
   "AddGroupWithOne.toSub",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "Int.cast_add",
   "Int.instAdd",
   "Eq",
   "ZMod.instField",
   "FltRegular.MayAssume.Lemmas._auxLemma.3",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Ring.toNeg",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Int.cast_mul",
   "Nat.instDvd",
   "Nat",
   "Eq.trans",
   "Mathlib.Tactic.RingNF.nat_rawCast_1",
   "Ne",
   "congr_arg",
   "Int.instHPowNat",
   "Int.instDvd",
   "Int.ModEq",
   "Nat.rawCast",
   "Mathlib.Tactic.RingNF.mul_neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "ZMod",
   "Int.cast_ofNat",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "NonAssocRing.toIntCast",
   "of_eq_true",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "sub_eq_zero",
   "add_zero",
   "congrArg",
   "Int.ofNat",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "AddGroupWithOne.toIntCast",
   "CommRing.toNonUnitalCommRing",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "Nat.Prime.ne_one",
   "Zero.toOfNat0",
   "instHPow",
   "Nat.prime_three",
   "Ring.toSub",
   "MulZeroClass.toZero",
   "Int.instNegInt",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "instOfNatAtLeastTwo",
   "id",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "False",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "AddGroupWithOne.toNeg",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "Nat.instCommSemiring",
   "SubNegMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "ZMod.intCast_zmod_eq_zero_iff_dvd",
   "Int.instCommSemiring",
   "NegZeroClass.toZero",
   "ZMod.commRing"],
  "name": "FltRegular.p_dvd_c_of_ab_of_anegc",
  "constType":
  "∀ {p : ℕ} {a b c : ℤ}, Nat.Prime p → p ≠ 3 → a ^ p + b ^ p = c ^ p → a ≡ b [ZMOD ↑p] → b ≡ -c [ZMOD ↑p] → ↑p ∣ c",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring", "Algebra", "Ring", "Ring.toSemiring", "CommRing"],
  "name": "Algebra.IsSeparable",
  "constType":
  "(F : Type u_1) → (K : Type u_2) → [inst : CommRing F] → [inst_1 : Ring K] → [inst : Algebra F K] → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "Nontrivial",
  "constType": "Type u_3 → Prop",
  "constCategory": "Other"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "RingHom",
   "OreLocalization.instZero",
   "IsScalarTower.algebraMap_eq",
   "IsDomain",
   "RingHom.comp",
   "Semiring.toMonoidWithZero",
   "FractionRing.field",
   "AddCommMonoid.toAddMonoid",
   "NoZeroSMulDivisors.of_algebraMap_injective",
   "CommRing",
   "nonZeroDivisors",
   "Eq",
   "FractionRing.instNontrivial",
   "Monoid.toMulAction",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "IsDomain.to_noZeroDivisors",
   "MonoidWithZero.toMonoid",
   "OreLocalization.oreSetComm",
   "AddMonoid.toZero",
   "OreLocalization.instSemiring",
   "Algebra",
   "IsDomain.toNontrivial",
   "CommMonoid.toMonoid",
   "CommSemiring.toCommMonoidWithZero",
   "DFunLike.coe",
   "Algebra.toSMul",
   "MulActionWithZero.toMulAction",
   "OreLocalization.instCommRing",
   "id",
   "NoZeroSMulDivisors",
   "IsScalarTower.right",
   "OreLocalization.instIsScalarTower",
   "IsFractionRing.instNoZeroSMulDivisorsOfNoZeroDivisors",
   "Algebra.toModule",
   "algebraMap",
   "OreLocalization.instRing",
   "NoZeroSMulDivisors.algebraMap_injective",
   "Localization.isLocalization",
   "Module.toMulActionWithZero",
   "Ring.toSemiring",
   "OreLocalization.instSMulOfIsScalarTower",
   "RingHom.instFunLike",
   "OreLocalization.instAlgebra",
   "CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "Field.isDomain",
   "MulAction.toSMul",
   "FractionRing",
   "Function.Injective",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Function.Injective.comp",
   "CommRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Algebra.id",
   "congrArg"],
  "name": "FractionRing.instNoZeroSMulDivisors",
  "constType":
  "∀ (R : Type u_1) [inst : CommRing R] (A : Type u_4) [inst_1 : CommRing A] [inst_2 : IsDomain A] [inst_3 : Algebra R A]\n  [inst_4 : NoZeroSMulDivisors R A], NoZeroSMulDivisors R (FractionRing A)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CanonicallyOrderedAddCommMonoid",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Multiset",
   "Multiset.mem_map",
   "Eq",
   "Multiset.instMembership"],
  "name": "FltRegular.NumberTheory.KummersLemma.Field._auxLemma.7",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {f : α → β} {b : β} {s : Multiset α}, (b ∈ Multiset.map f s) = ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Subtype.val",
   "IsLocalization.mk'",
   "Set",
   "IsLocalization.mk'_eq_zero_iff",
   "IsLocalization",
   "Set.instMembership",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "SetLike.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "CommSemiring",
   "Algebra",
   "HMul.hMul",
   "Submonoid",
   "CommSemiring.toCommMonoidWithZero",
   "Submonoid.instSetLike",
   "Subtype",
   "SetLike.coe"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.14",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] (x : R) (s : ↥M),\n  (IsLocalization.mk' S x s = 0) = ∃ m, ↑m * x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_6",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_1"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "Exists",
   "OfNat.ofNat",
   "instAddNat",
   "propext",
   "instHAdd",
   "HAdd.hAdd",
   "instOfNatNat",
   "Fin.exists_succAbove_eq_iff",
   "Nat",
   "Fin.succAbove",
   "Fin",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.20",
  "constType":
  "∀ {n : ℕ} {x y : Fin (n + 1)}, (∃ z, x.succAbove z = y) = (y ≠ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Quot.liftOn",
   "Setoid.r",
   "DecidableEq",
   "List.dedup",
   "List",
   "List.isSetoid",
   "Multiset",
   "Multiset.dedup.proof_1",
   "Multiset.ofList"],
  "name": "Multiset.dedup",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → Multiset α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "SDiff.mk",
   "DecidableEq",
   "Multiset",
   "HSub.hSub",
   "Finset",
   "Finset.val",
   "Finset.mk",
   "SDiff",
   "Multiset.instSub",
   "Finset.instSDiff.proof_1"],
  "name": "Finset.instSDiff",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → SDiff (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_3",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Neg"],
  "name": "Neg.neg",
  "constType": "{α : Type u} → [self : Neg α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "mul_add",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "HMul.hMul",
   "CommSemiring.toCommMonoidWithZero",
   "add_zero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.mul_add",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₁ b₂ c₁ c₂ d : R},\n  a * b₁ = c₁ → a * b₂ = c₂ → c₁ + 0 + c₂ = d → a * (b₁ + b₂) = d",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Ideal.instNormalizedGCDMonoid.proof_4",
   "NormalizationMonoid",
   "Ideal.cancelCommMonoidWithZero",
   "Ideal.instNormalizedGCDMonoid.proof_3",
   "Inf.inf",
   "Ideal.instNormalizedGCDMonoid.proof_1",
   "NormalizedGCDMonoid",
   "GCDMonoid.mk",
   "Submodule.instInf",
   "Ideal.instNormalizedGCDMonoid.proof_6",
   "CommRing",
   "Ideal.normalizationMonoid",
   "Ideal.instIdemCommSemiring",
   "IsDedekindDomain",
   "IdemCommSemiring.toSemilatticeSup",
   "Ideal.instNormalizedGCDMonoid.proof_8",
   "Ideal.instNormalizedGCDMonoid.proof_2",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "SemilatticeSup.toSup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Ideal.instNormalizedGCDMonoid.proof_5",
   "Sup.sup",
   "NormalizedGCDMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal",
   "Ideal.instNormalizedGCDMonoid.proof_7",
   "Semiring.toModule"],
  "name": "Ideal.instNormalizedGCDMonoid",
  "constType":
  "{A : Type u_2} → [inst : CommRing A] → [inst_1 : IsDedekindDomain A] → NormalizedGCDMonoid (Ideal A)",
  "constCategory": "Definition"},
 {"references":
  ["MulHomClass",
   "NonUnitalAlgSemiHomClass",
   "NonUnitalNonAssocSemiring",
   "outParam",
   "Monoid",
   "FunLike",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidHom",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "DistribMulAction"],
  "name": "NonUnitalAlgSemiHomClass.toMulHomClass",
  "constType":
  "∀ {F : Type u_1} {R : outParam (Type u_2)} {S : outParam (Type u_3)} [inst : Monoid R] [inst_1 : Monoid S]\n  {φ : outParam (R →* S)} {A : outParam (Type u_4)} {B : outParam (Type u_5)} [inst_2 : NonUnitalNonAssocSemiring A]\n  [inst_3 : NonUnitalNonAssocSemiring B] [inst_4 : DistribMulAction R A] [inst_5 : DistribMulAction S B]\n  [inst_6 : FunLike F A B] [self : NonUnitalAlgSemiHomClass F φ A B], MulHomClass F A B",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.cons",
  "constType": "{α : Type u} → α → List α → List α",
  "constCategory": "Other"},
 {"references": ["Monoid", "Semigroup"],
  "name": "Monoid.toSemigroup",
  "constType": "{M : Type u} → [self : Monoid M] → Semigroup M",
  "constCategory": "Definition"},
 {"references":
  ["SubNegMonoid",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegZeroMonoid",
   "SubNegZeroMonoid.mk",
   "SubtractionMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid.proof_1"],
  "name": "SubtractionMonoid.toSubNegZeroMonoid",
  "constType":
  "{α : Type u_1} → [inst : SubtractionMonoid α] → SubNegZeroMonoid α",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "LinearOrderedSemiring"],
  "name": "LinearOrderedSemiring.toStrictOrderedSemiring",
  "constType":
  "{α : Type u} → [self : LinearOrderedSemiring α] → StrictOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Int.decLe",
   "OfNat.ofNat",
   "Lean.Omega.Coeffs.dot",
   "HAdd.hAdd",
   "Int.eq_iff_le_and_ge",
   "Eq.refl",
   "Lean.Omega.Coeffs",
   "Lean.Omega.Int.add_le_zero_iff_le_neg'",
   "Int.instAdd",
   "Subsingleton.elim",
   "Eq",
   "Decidable.decide",
   "Lean.Omega.UpperBound.sat",
   "Eq.mpr",
   "Lean.Omega.Int.add_nonnneg_iff_neg_le'",
   "Lean.Omega.Constraint.mk",
   "Bool.true",
   "Eq.rec",
   "Decidable",
   "Lean.Omega.LowerBound.sat",
   "Int.instNegInt",
   "Option.some",
   "instOfNat",
   "Eq.trans",
   "Lean.Omega.Constraint.lowerBound",
   "id",
   "instDecidableEqBool",
   "decide_eq_true_eq",
   "instHAdd",
   "Neg.neg",
   "instDecidableAnd",
   "Lean.Omega.Constraint.upperBound",
   "LE.le",
   "and_comm",
   "And",
   "Eq.ndrec",
   "propext",
   "and",
   "Eq.mp",
   "congr",
   "Bool.and_eq_true",
   "Bool",
   "Lean.Omega.Constraint.sat'",
   "congrArg",
   "Int",
   "Bool.decide_and",
   "instSubsingletonDecidable",
   "Int.instLEInt"],
  "name": "Lean.Omega.Constraint.addEquality_sat",
  "constType":
  "∀ {c : ℤ} {x y : Lean.Omega.Coeffs},\n  c + x.dot y = 0 → { lowerBound := some (-c), upperBound := some (-c) }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroup.toAddCancelMonoid.proof_3",
   "AddMonoid.nsmul",
   "AddGroup.toAddCancelMonoid.proof_1",
   "AddGroup.toAddCancelMonoid.proof_6",
   "AddGroup",
   "AddGroup.toAddCancelMonoid.proof_5",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "AddCancelMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddLeftCancelMonoid.mk",
   "AddCancelMonoid.mk",
   "AddGroup.toAddCancelMonoid.proof_2",
   "AddGroup.toSubNegMonoid",
   "AddLeftCancelSemigroup.mk",
   "AddGroup.toAddCancelMonoid.proof_4"],
  "name": "AddGroup.toAddCancelMonoid",
  "constType": "{G : Type u_1} → [inst : AddGroup G] → AddCancelMonoid G",
  "constCategory": "Definition"},
 {"references": ["PUnit.unit", "Unit"],
  "name": "Unit.unit",
  "constType": "Unit",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "NoZeroDivisors",
   "instHMul",
   "mul_eq_zero",
   "Or",
   "OfNat.ofNat",
   "propext",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "FltRegular.NumberTheory.QuotientTrace._auxLemma.5",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, (a * b = 0) = (a = 0 ∨ b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "FltRegular.CaseI.two_lt",
   "Subtype.val",
   "Eq.refl",
   "Exists.intro",
   "instLTNat",
   "True",
   "instDecidableEqNat",
   "ite",
   "Eq",
   "Decidable.decide",
   "Nat.Prime",
   "instLENat",
   "eq_false'",
   "instOfNatNat",
   "Nat",
   "Int.instSub",
   "Eq.trans",
   "instOfNat",
   "absurd",
   "if_false",
   "Fin.mk",
   "eq_self",
   "instHSub",
   "Ne",
   "Nat.Prime.pos",
   "False",
   "Fin.val",
   "of_decide_eq_false",
   "HSub.hSub",
   "LE.le",
   "ite_congr",
   "instDecidableFalse",
   "eq_false",
   "False.elim",
   "of_eq_true",
   "Nat.noConfusion",
   "LT.lt",
   "letFun",
   "Eq.mp",
   "Not",
   "Bool",
   "congrArg",
   "Int",
   "FltRegular.CaseI.f0k₂",
   "Subtype.mk",
   "Fin"],
  "name": "FltRegular.CaseI.auxf0k₂",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p), 5 ≤ p → ∀ (a b : ℤ), ∃ i, FltRegular.CaseI.f0k₂ a b ↑i = 0",
  "constCategory": "Theorem"},
 {"references": ["Eq.refl", "Eq"],
  "name": "rfl",
  "constType": "∀ {α : Sort u} {a : α}, a = a",
  "constCategory": "Definition"},
 {"references":
  ["NonAssocSemiring.mul_one",
   "MulZeroOneClass.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "NonAssocSemiring.toOne",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonAssocSemiring.one_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "MulOneClass.mk",
   "NonAssocSemiring",
   "MulZeroOneClass"],
  "name": "NonAssocSemiring.toMulZeroOneClass",
  "constType": "{α : Type u} → [self : NonAssocSemiring α] → MulZeroOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["CyclotomicField.classGroupFinite",
   "OfNat.ofNat",
   "Rat.instField",
   "Rat",
   "NumberField.RingOfIntegers.instCommRing",
   "Fintype.card",
   "instLTNat",
   "CyclotomicField",
   "ClassGroup",
   "CyclotomicField.instField",
   "IsRegularNumber.proof_1",
   "IsRegularNumber.proof_2",
   "LT.lt",
   "Nat.Coprime",
   "instOfNatNat",
   "Nat",
   "Fact",
   "NumberField.RingOfIntegers",
   "Subtype.mk"],
  "name": "IsRegularNumber",
  "constType": "(n : ℕ) → [hn : Fact (0 < n)] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "eq_false",
   "Nat.AtLeastTwo",
   "False",
   "OfNat.one_ne_ofNat",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "CharZero",
   "One.toOfNat1",
   "Nat",
   "instOfNatAtLeastTwo",
   "Eq"],
  "name": "Mathlib.Algebra.CharZero.Defs._auxLemma.10",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] (n : ℕ) [inst_2 : n.AtLeastTwo],\n  (1 = OfNat.ofNat n) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "AddZeroClass.toAdd",
   "Submodule",
   "AddSubsemigroup.mk",
   "Semiring",
   "Top.top",
   "AddSubmonoid.toAddSubsemigroup",
   "Set",
   "AddSubmonoid.instTop",
   "AddCommMonoid.toAddMonoid",
   "Set.instMembership",
   "Submodule.instTop.proof_2",
   "AddMonoid.toAddZeroClass",
   "Set.univ",
   "AddSubmonoid",
   "trivial",
   "Top",
   "Submodule.instTop.proof_1",
   "Submodule.mk",
   "AddSubmonoid.mk",
   "Module",
   "AddSubsemigroup.carrier",
   "Top.mk",
   "AddCommMonoid"],
  "name": "Submodule.instTop",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Top (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["Multiset.countP", "DecidableEq", "Multiset", "Nat", "Eq"],
  "name": "Multiset.count",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → α → Multiset α → ℕ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___unexpand_CyclotomicField_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "NonUnitalCommRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_3",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_1",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_2",
   "NonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_6",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_5",
   "AddCommMonoid.mk",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalCommSemiring.mk",
   "NonUnitalCommRing.toNonUnitalCommSemiring.proof_4",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalCommRing.toNonUnitalCommSemiring",
  "constType":
  "{α : Type u} → [s : NonUnitalCommRing α] → NonUnitalCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Units",
   "Units.isUnit",
   "eq_true",
   "Monoid",
   "Units.val",
   "IsUnit",
   "True",
   "Eq"],
  "name": "Mathlib.Algebra.Group.Units._auxLemma.29",
  "constType": "∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ), IsUnit ↑u = True",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.add_comm",
   "SubtractionCommMonoid",
   "SubtractionMonoid.neg_eq_of_add",
   "AddGroup.toSubtractionMonoid",
   "AddCommGroup.toAddGroup",
   "SubtractionMonoid.neg_neg",
   "SubtractionMonoid",
   "AddCommGroup",
   "SubtractionCommMonoid.mk",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.neg_add_rev",
   "SubtractionMonoid.mk"],
  "name": "AddCommGroup.toDivisionAddCommMonoid",
  "constType":
  "{G : Type u_1} → [inst : AddCommGroup G] → SubtractionCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_7"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toSemigroup", "inferInstance", "Int.instMonoid", "Int", "Semigroup"],
  "name": "Int.instSemigroup",
  "constType": "Semigroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_toFinset",
   "DecidableEq",
   "propext",
   "Finset",
   "Multiset",
   "Multiset.toFinset",
   "Eq.symm",
   "Eq",
   "Multiset.instMembership",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.8",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, (a ∈ s) = (a ∈ s.toFinset)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "RingHom",
   "NumberField.inst_ringOfIntegersAlgebra.proof_1",
   "MulZeroOneClass.toMulOneClass",
   "DivisionRing.toRing",
   "Semifield.toCommSemiring",
   "NumberField.RingOfIntegers.instCommRing",
   "Subalgebra",
   "NumberField.inst_ringOfIntegersAlgebra.proof_2",
   "NonAssocSemiring.toMulZeroOneClass",
   "algebraInt",
   "RingHom.mk",
   "Subalgebra.instSetLike",
   "integralClosure",
   "SetLike.instMembership",
   "Semiring.toNonAssocSemiring",
   "NumberField.inst_ringOfIntegersAlgebra.proof_5",
   "Field",
   "Algebra",
   "OneHom.mk",
   "MonoidHom.mk",
   "DFunLike.coe",
   "NumberField.inst_ringOfIntegersAlgebra.proof_3",
   "RingHom.toAlgebra",
   "Membership.mem",
   "MulOneClass.toOne",
   "algebraMap",
   "Field.toSemifield",
   "EuclideanDomain.toCommRing",
   "RingHom.instFunLike",
   "CommRing.toCommSemiring",
   "DivisionSemiring.toSemiring",
   "Int.instCommRing",
   "Field.toEuclideanDomain",
   "Semifield.toDivisionSemiring",
   "Algebra.id",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Int",
   "NumberField.inst_ringOfIntegersAlgebra.proof_4",
   "NumberField.RingOfIntegers.instAlgebra_1",
   "Subtype.mk"],
  "name": "NumberField.inst_ringOfIntegersAlgebra",
  "constType":
  "(K : Type u_1) →\n  (L : Type u_2) →\n    [inst : Field K] →\n      [inst_1 : Field L] →\n        [inst_2 : Algebra K L] → Algebra (NumberField.RingOfIntegers K) (NumberField.RingOfIntegers L)",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "Iff",
   "Nat.cast_injective",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "Nat",
   "Function.Injective.eq_iff",
   "Eq"],
  "name": "Nat.cast_inj",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references": ["WithTop", "Nat"],
  "name": "ENat",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_27",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_26"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_28._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Ideal.map",
   "PartialOrder.toPreorder",
   "Semiring",
   "RingHomClass",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set.instHasSubset",
   "HasSubset.Subset",
   "Submodule.completeLattice",
   "Ideal.span",
   "Ideal.comap",
   "LE.le",
   "Preorder.toLE",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "FunLike",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Iff.trans",
   "Set.image_subset_iff",
   "Ideal.span_le",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DFunLike.coe",
   "Set.image",
   "Ideal",
   "Submodule.setLike",
   "Semiring.toModule",
   "SetLike.coe"],
  "name": "Ideal.map_le_iff_le_comap",
  "constType":
  "∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : FunLike F R S]\n  [rc : RingHomClass F R S] {f : F} {I : Ideal R} {K : Ideal S}, Ideal.map f I ≤ K ↔ I ≤ Ideal.comap f K",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Zero.toOfNat0",
   "OfNat.ofNat",
   "propext",
   "AddMonoid.toZero",
   "Finset.sum",
   "Finset",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "Finset.sum_eq_zero_iff",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Finset.instMembership",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.21",
  "constType":
  "∀ {ι : Type u_1} {M : Type u_4} [inst : CanonicallyOrderedAddCommMonoid M] {f : ι → M} {s : Finset ι},\n  (∑ x ∈ s, f x = 0) = ∀ x ∈ s, f x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Int.ofNat",
   "Int.cast_natCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "Mathlib.Meta.NormNum.IsNat.to_isInt.match_1",
   "True",
   "Eq",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "instNatCastInt",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_isInt",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsNat a n → Mathlib.Meta.NormNum.IsInt a (Int.ofNat n)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroOneClass.toMulOneClass",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Semiring.toMonoidWithZero",
   "le_rfl",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "nonZeroDivisors",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Field",
   "Algebra",
   "Semiring.toModule",
   "IsFractionRing",
   "FractionalIdeal.coeIdeal",
   "Submodule.instBot",
   "Bot.bot",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Field.toSemifield",
   "EuclideanDomain.toCommRing",
   "FractionalIdeal.instZero",
   "DivisionSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "Submonoid.instCompleteLattice",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toEuclideanDomain",
   "Submonoid",
   "FractionalIdeal",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal",
   "FractionalIdeal.coeIdeal_eq_zero'"],
  "name": "FractionalIdeal.coeIdeal_eq_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommRing R] {K : Type u_3} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : Ideal R}, ↑I = 0 ↔ I = ⊥",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Multiset.range",
   "List.mem_range",
   "LT.lt",
   "Multiset",
   "Nat",
   "instLTNat",
   "Multiset.instMembership"],
  "name": "Multiset.mem_range",
  "constType": "∀ {m n : ℕ}, m ∈ Multiset.range n ↔ m < n",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Int.instAddGroup",
   "LinearOrderedAddCommGroup.toOrderedAddCommGroup",
   "OrderedAddCommGroup.toPartialOrder",
   "PartialOrder.toPreorder",
   "Int.abs_eq_natAbs.match_1",
   "Int.linearOrderedAddCommGroup",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "abs",
   "abs_of_nonneg",
   "abs_of_nonpos",
   "Eq",
   "Zero.toOfNat0",
   "Nat.cast",
   "instNatCastInt",
   "Int.instCovariantClassAddLE",
   "Int.negSucc",
   "Int.negSucc_lt_zero",
   "le_of_lt",
   "Nat",
   "NegZeroClass.toZero",
   "Int.ofNat_zero_le",
   "Int",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instLatticeInt",
   "Int.natAbs"],
  "name": "Int.abs_eq_natAbs",
  "constType": "∀ (a : ℤ), |a| = ↑a.natAbs",
  "constCategory": "Theorem"},
 {"references": ["propext", "eq_self_iff_true", "True", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclotomicUnits._auxLemma.1",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_20",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_21._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["NeZero.charZero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Rat.instField",
   "CyclotomicField.instCharZero",
   "Ring.toAddGroupWithOne",
   "IsCyclotomicExtension.numberField",
   "Set.fintypeSingleton",
   "CyclotomicField.isCyclotomicExtension",
   "Set",
   "Rat",
   "NormedCommRing.toNormedRing",
   "NormedField.toNormedCommRing",
   "NeZero.pnat",
   "algebraRat",
   "CyclotomicField",
   "PNat.val",
   "CyclotomicField.instField",
   "Rat.instCharZero",
   "Set.instSingletonSet",
   "Set.Elem",
   "NumberField",
   "Singleton.singleton",
   "Field.toDivisionRing",
   "Rat.instNormedField",
   "Finite.of_fintype",
   "NormedRing.toRing",
   "PNat",
   "Rat.numberField"],
  "name": "safe",
  "constType": "∀ {p : ℕ+}, NumberField (CyclotomicField p ℚ)",
  "constCategory": "Definition"},
 {"references":
  ["AddCommMagma.add_comm",
   "AddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "Eq"],
  "name": "add_comm",
  "constType":
  "∀ {G : Type u_1} [inst : AddCommMagma G] (a b : G), a + b = b + a",
  "constCategory": "Theorem"},
 {"references": ["GroupWithZero", "Inv"],
  "name": "GroupWithZero.toInv",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → Inv G₀",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro", "Or", "False", "Or.inr", "false_or.match_1", "propext", "Eq"],
  "name": "false_or",
  "constType": "∀ (p : Prop), (False ∨ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "StrictOrderedCommSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "StrictOrderedSemiring.toOrderedSemiring",
   "OrderedSemiring.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "OrderedCommSemiring.mk",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "OrderedSemiring.mul_le_mul_of_nonneg_left",
   "OrderedCommSemiring",
   "StrictOrderedCommSemiring.mul_comm",
   "OrderedSemiring.mul_le_mul_of_nonneg_right",
   "StrictOrderedSemiring.toSemiring",
   "StrictOrderedCommSemiring.toOrderedCommSemiring.proof_1"],
  "name": "StrictOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{α : Type u} → [inst : StrictOrderedCommSemiring α] → OrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Submodule",
   "Algebra.toModule",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "FractionalIdeal.instSetLike.proof_1",
   "CommRing.toCommSemiring",
   "SetLike",
   "Semiring.toNonAssocSemiring",
   "SetLike.mk",
   "Algebra",
   "Submonoid",
   "FractionalIdeal",
   "FractionalIdeal.coeToSubmodule",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.setLike",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "SetLike.coe"],
  "name": "FractionalIdeal.instSetLike",
  "constType":
  "{R : Type u_1} →\n  [inst : CommRing R] →\n    {S : Submonoid R} →\n      {P : Type u_2} → [inst_1 : CommRing P] → [inst_2 : Algebra R P] → SetLike (FractionalIdeal S P) P",
  "constCategory": "Definition"},
 {"references":
  ["DecidableEq", "Finset", "Finset.val", "Multiset.toFinset", "Multiset.bind"],
  "name": "Finset.biUnion",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : DecidableEq β] → Finset α → (α → Finset β) → Finset β",
  "constCategory": "Definition"},
 {"references": ["Monad", "Bind"],
  "name": "Monad.toBind",
  "constType": "{m : Type u → Type v} → [self : Monad m] → Bind m",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "NoZeroDivisors",
   "instHMul",
   "mul_eq_zero",
   "Or",
   "OfNat.ofNat",
   "propext",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "FltRegular.CaseII.Statement._auxLemma.4",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, (a * b = 0) = (a = 0 ∨ b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Prime",
   "instFactLtNatOfNatOfPrime_fltRegular",
   "IsRegularNumber",
   "Nat",
   "Fact"],
  "name": "IsRegularPrime",
  "constType": "(p : ℕ) → [inst : Fact (Nat.Prime p)] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Lean.Name.num._override",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Iff.symm",
   "Nat.prime_iff_prime_int",
   "Nat.Prime",
   "Prime",
   "Iff",
   "Nat.cast",
   "instNatCastInt",
   "Int.associated_natAbs",
   "Associated.prime_iff",
   "Iff.trans",
   "CommSemiring.toCommMonoidWithZero",
   "Int.instCommSemiring",
   "Int",
   "Int.natAbs"],
  "name": "Int.prime_iff_natAbs_prime",
  "constType": "∀ {k : ℤ}, Prime k ↔ Nat.Prime k.natAbs",
  "constCategory": "Theorem"},
 {"references":
  ["not_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.2",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Substring",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Nat.Prime.one_lt",
   "OfNat.ofNat",
   "Nat.Prime",
   "Nat.pred",
   "LT.lt",
   "Nat.lt_pred_iff",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "instLTNat",
   "Iff.mpr"],
  "name": "Nat.Prime.pred_pos",
  "constType": "∀ {p : ℕ}, Nat.Prime p → 0 < p.pred",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "eq_false",
   "OfNat.ofNat",
   "NeZero",
   "False",
   "zero_ne_one",
   "One",
   "One.toOfNat1",
   "Eq"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.13",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], (0 = 1) = False",
  "constCategory": "Theorem"},
 {"references":
  ["eq_true",
   "Semiring",
   "linearIndependent_empty_type",
   "Module",
   "IsEmpty",
   "True",
   "Eq",
   "LinearIndependent",
   "AddCommMonoid"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.1",
  "constType":
  "∀ {ι : Type u'} {R : Type u_2} {M : Type u_4} {v : ι → M} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : IsEmpty ι], LinearIndependent R v = True",
  "constCategory": "Theorem"},
 {"references":
  ["Finsupp.single",
   "Finsupp",
   "Finsupp.instFunLike",
   "PartialOrder.toPreorder",
   "Finsupp.instLEFinsupp",
   "AddCommMonoid.toAddMonoid",
   "Finsupp.single_le_iff",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "propext",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "DFunLike.coe",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.10",
  "constType":
  "∀ {ι : Type u_1} {α : Type u_2} [inst : CanonicallyOrderedAddCommMonoid α] {i : ι} {x : α} {f : ι →₀ α},\n  (Finsupp.single i x ≤ f) = (x ≤ f i)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name._impl",
   "String.hash",
   "Lean.Name.str._impl",
   "String",
   "Lean.Name",
   "mixHash",
   "unsafeCast",
   "Lean.Name.hash"],
  "name": "Lean.Name.str._override",
  "constType": "Lean.Name → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "Nat.instCommSemiring", "CommSemiring", "Nat"],
  "name": "Mathlib.Tactic.Ring.instCommSemiringNat",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["OneHom.toFun",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "Semiring",
   "CommSemiring",
   "AlgHom.funLike.proof_1",
   "AlgHom.toRingHom",
   "Algebra",
   "RingHom.toMonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "AlgHom",
   "DFunLike.mk"],
  "name": "AlgHom.funLike",
  "constType":
  "{R : Type u} →\n  {A : Type v} →\n    {B : Type w} →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A] →\n          [inst_2 : Semiring B] → [inst_3 : Algebra R A] → [inst_4 : Algebra R B] → FunLike (A →ₐ[R] B) A B",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Semigroup.toMul",
   "Semiring.mk",
   "Monoid.toSemigroup",
   "Monoid.toOne",
   "CommSemiring.mk",
   "Nat.instCommSemiring.proof_3",
   "Nat.instCommSemiring.proof_6",
   "CommMonoid.mul_comm",
   "Nat.instCommSemiring.proof_1",
   "Nat.pow_zero",
   "NatCast.mk",
   "Nat.instCommSemiring.proof_2",
   "NonUnitalNonAssocSemiring.mk",
   "Nat.mul_zero",
   "Nat.instAddCommMonoid",
   "Nat.right_distrib",
   "Nat.instMonoid",
   "CommMonoid",
   "instHPow",
   "Nat.instCommSemiring.proof_5",
   "CommSemiring",
   "Nat.instCommMonoid",
   "NonUnitalSemiring.mk",
   "Nat.zero_mul",
   "Monoid.toNatPow",
   "Nat",
   "CommMonoid.toMonoid",
   "Nat.left_distrib",
   "Nat.instCommSemiring.proof_4"],
  "name": "Nat.instCommSemiring",
  "constType": "CommSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddGroupWithOne.toIntCast",
   "AddGroup.toSubtractionMonoid",
   "Fin.ext",
   "Fin.is_lt",
   "ZMod.val_cast_of_lt",
   "ZMod.val_natCast",
   "True",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Nat.Prime",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "ZMod.val",
   "Ring.toIntCast",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "instOfNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Fin.mk",
   "Fin.isLt",
   "id",
   "eq_self",
   "Int.cast_natCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Nat.Prime.pos",
   "Ring.toAddGroupWithOne",
   "Fin.val",
   "Int.ModEq",
   "ZMod.val_zero",
   "SubNegZeroMonoid.toNegZeroClass",
   "ZMod",
   "Int.cast_zero",
   "Fin.val_mk",
   "CommRing.toCommSemiring",
   "instHMod",
   "of_eq_true",
   "instNatCastInt",
   "propext",
   "Int.cast",
   "Eq.mp",
   "letFun",
   "HMod.hMod",
   "CommRing.toRing",
   "NegZeroClass.toZero",
   "congrArg",
   "Nat.instMod",
   "Int",
   "ZMod.intCast_eq_intCast_iff",
   "Fin",
   "ZMod.commRing"],
  "name": "FltRegular.CaseI.aux_cong1k₁",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p) {k : Fin p}, ↑↑k ≡ 0 [ZMOD ↑p] → k = ⟨0, ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "AddGroup"],
  "name": "AddGroup.toSubNegMonoid",
  "constType": "{A : Type u} → [self : AddGroup A] → SubNegMonoid A",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_10",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_9"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Finset.instSingleton",
   "Singleton.singleton",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.13",
  "constType": "∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "MulZeroClass",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Submodule.instBot",
   "Bot.bot",
   "OfNat.ofNat",
   "Semiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "Ideal.span",
   "Eq",
   "Zero.toOfNat0",
   "Set.instSingletonSet",
   "Semiring.toNonAssocSemiring",
   "Ideal.span_singleton_eq_bot",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Ideal",
   "Semiring.toModule"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.4",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] {x : α}, (Ideal.span {x} = ⊥) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Rat.commGroupWithZero",
   "CommGroupWithZero.zpow_neg'",
   "CommGroupWithZero.zpow",
   "CommGroupWithZero",
   "CommRing",
   "CommGroupWithZero.zpow_succ'",
   "Rat.instField.proof_4",
   "CommGroupWithZero.div_eq_mul_inv",
   "NNRat",
   "Rat.commRing",
   "CommGroupWithZero.toDiv",
   "Field",
   "Rat.cast",
   "Rat.instField.proof_3",
   "Rat.instField.proof_1",
   "CommGroupWithZero.zpow_zero'",
   "instRatCastRat",
   "CommGroupWithZero.mul_inv_cancel",
   "CommGroupWithZero.toInv",
   "Field.mk",
   "Rat",
   "CommGroupWithZero.inv_zero",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "CommGroupWithZero.toNontrivial",
   "instHMul",
   "Rat.instNNRatCast",
   "HMul.hMul",
   "CommRing.toRing",
   "NNRat.cast",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Rat.instField.proof_2"],
  "name": "Rat.instField",
  "constType": "Field ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "LT.lt",
   "Nat",
   "Int.ofNat_lt",
   "Int",
   "instLTNat",
   "Int.instLTInt",
   "Iff.mpr"],
  "name": "Lean.Omega.Int.ofNat_lt_of_lt",
  "constType": "∀ {x y : ℕ}, x < y → ↑x < ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "Eq.mpr",
   "Int.sub_self",
   "HSub.hSub",
   "Eq.refl",
   "congrArg",
   "Int.instSub",
   "instOfNat",
   "Int",
   "id",
   "Eq"],
  "name": "Int.sub_eq_zero_of_eq",
  "constType": "∀ {a b : ℤ}, a = b → a - b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddCommMonoid.add_comm",
   "AddCommSemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddCommSemigroup.mk",
   "AddCommMonoid"],
  "name": "AddCommMonoid.toAddCommSemigroup",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddCommSemigroup M",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.symbol",
  "constType": "String → Lean.ParserDescr",
  "constCategory": "Other"},
 {"references": ["Monoid", "CommMonoid"],
  "name": "CommMonoid.toMonoid",
  "constType": "{M : Type u} → [self : CommMonoid M] → Monoid M",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.mkStr2",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termR_1._closed_2",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termR_1._closed_1"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termR_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Ring", "Sub"],
  "name": "Ring.toSub",
  "constType": "{R : Type u} → [self : Ring R] → Sub R",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "algebraRat",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "Semiring.toNatCast",
   "SubNegMonoid.toSub",
   "Nat.Prime",
   "Nat.cast",
   "Field",
   "map_mul",
   "MonoidHom.id",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "AlgEquiv.instEquivLike",
   "HPow.hPow",
   "instHSub",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "AlgEquiv.instFunLike",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "Field.toDivisionRing",
   "Int",
   "Submodule.setLike",
   "NonUnitalAlgHomClass.instLinearMapClass",
   "AddZeroClass.toAdd",
   "AlgEquiv",
   "Exists",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "AlgEquivClass.toAlgHomClass",
   "semigroupDvd",
   "AddMonoid.toAddZeroClass",
   "algebraInt",
   "RingHom.id",
   "map_intCast",
   "Monoid.toNatPow",
   "Semiring.toModule",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "NonUnitalAlgSemiHomClass.toMulHomClass",
   "Field.toSemifield",
   "AlgHom",
   "Monoid.toMulOneClass",
   "IsCyclotomicExtension",
   "CommRing.toCommSemiring",
   "Fact.mk",
   "letFun",
   "Semifield.toDivisionSemiring",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal.mem_span_singleton",
   "map_natCast",
   "PNat",
   "Module.toDistribMulAction",
   "HAdd.hAdd",
   "dvd_mul_right",
   "sub_eq_iff_eq_add",
   "Ideal.span",
   "AlgHomClass.toRingHomClass",
   "Exists.casesOn",
   "SetLike.instMembership",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "AddCommGroup.intModule",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "IsCyclotomicExtension.ring_of_integers'",
   "Nat",
   "exists_int_sub_pow_prime_dvd",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "SemilinearMapClass.toAddHomClass",
   "AlgHom.instNonUnitalAlgHomClassOfAlgHomClass",
   "NonAssocRing.toIntCast",
   "Field.toEuclideanDomain",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "Singleton.singleton",
   "Fact",
   "congrArg",
   "Ideal",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "NumberField.RingOfIntegers.instCommRing",
   "AlgHomClass.toAlgHom",
   "CommSemiring.toNonUnitalCommSemiring",
   "intGal",
   "Ring.toNonAssocRing",
   "AlgEquiv.instAlgEquivClass",
   "PNat.val",
   "Rat.commRing",
   "Set.instSingletonSet",
   "AlgHom.algHomClass",
   "instHPow",
   "Ring.toSub",
   "AddCommGroup.toAddGroup",
   "add_sub_add_right_eq_sub",
   "DFunLike.coe",
   "Eq.symm",
   "id",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Algebra.toModule",
   "Rat.commSemiring",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "Dvd.dvd",
   "map_add",
   "AddGroup.toSubNegMonoid",
   "DivisionSemiring.toSemiring",
   "mul_sub",
   "CharZero",
   "AlgHom.funLike",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "galConj",
   "Int.instCommSemiring",
   "NumberField.RingOfIntegers"],
  "name": "FltRegular.CaseI.pow_sub_intGalConj_mem",
  "constType":
  "∀ {p : ℕ+} {K : Type u_1} [inst : Field K] [inst_1 : CharZero K] [inst_2 : IsCyclotomicExtension {p} ℚ K],\n  Nat.Prime ↑p → ∀ (α : NumberField.RingOfIntegers K), α ^ ↑p - (intGal ↑(galConj K p)) (α ^ ↑p) ∈ Ideal.span {↑↑p}",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "outParam",
  "constType": "Sort u → Sort u",
  "constCategory": "Definition"},
 {"references": ["ite_eq_left_iff", "propext", "Decidable", "Not", "ite", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.2",
  "constType":
  "∀ {α : Sort u_1} {a b : α} {P : Prop} [inst : Decidable P], ((if P then a else b) = a) = (¬P → b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "Finsupp",
   "OfNat.ofNat",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "EmptyCollection.emptyCollection",
   "MvPolynomial",
   "MvPolynomial.support_eq_empty",
   "Eq",
   "Zero.toOfNat0",
   "MvPolynomial.commSemiring",
   "MvPolynomial.support",
   "propext",
   "CommSemiring",
   "Finset",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "Finset.instEmptyCollection"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.16",
  "constType":
  "∀ {R : Type u} {σ : Type u_1} [inst : CommSemiring R] {p : MvPolynomial σ R}, (p = 0) = (p.support = ∅)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Membership",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["Fact"],
  "name": "Fact.out",
  "constType": "∀ {p : Prop} [self : Fact p], p",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "CommSemiring", "Algebra"],
  "name": "Subalgebra",
  "constType":
  "(R : Type u) → (A : Type v) → [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst : Algebra R A] → Type v",
  "constCategory": "Other"},
 {"references":
  ["Subtype.ext_iff", "propext", "Subtype.val", "Eq.symm", "Subtype", "Eq"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.8",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, (↑a1 = ↑a2) = (a1 = a2)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq.match_1",
   "Int",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
  "constType":
  "∀ {α : Type u} {a : α} {n : ℤ} [inst : Ring α], Mathlib.Meta.NormNum.IsInt a n → a = n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.card",
   "Multiset",
   "Finset",
   "Finset.val",
   "AddCommMonoid.toAddMonoid",
   "Nat.instAddMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "Nat",
   "DFunLike.coe",
   "AddMonoidHom.instFunLike",
   "AddMonoidHom",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.card",
  "constType": "{α : Type u_1} → Finset α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "mul_neg",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "neg_pow",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "pow_sub_pow_eq_prod_sub_zeta_runity_mul",
   "pow_one",
   "Iff.mpr",
   "Finset.instMembership",
   "Eq",
   "Odd.pos",
   "Semiring.toNonAssocSemiring",
   "Ring.toNeg",
   "MonoidWithZero.toMonoid",
   "HasDistribNeg.toInvolutiveNeg",
   "Finset.prod_congr",
   "Nat",
   "Odd",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "instHSub",
   "MulOneClass.toOne",
   "Nat.instSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "neg_one_pow_eq_pow_mod_two",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "CommRing.toCommMonoid",
   "Eq.mp",
   "CommRing.toRing",
   "sub_neg_eq_add",
   "congrArg",
   "AddZeroClass.toAdd",
   "Nat.odd_iff",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommRing.toNonUnitalCommRing",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Nat.instNontrivial",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "one_mul",
   "instHPow",
   "InvolutiveNeg.toNeg",
   "Finset",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "neg_mul",
   "Membership.mem",
   "NonUnitalNonAssocRing.toMul",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "Polynomial.nthRootsFinset",
   "Semiring.toOne",
   "CommRing.toCommSemiring",
   "instHMod",
   "SubtractionMonoid.toSubNegMonoid",
   "Finset.prod",
   "letFun",
   "Nat.instCanonicallyOrderedCommSemiring",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "HMod.hMod",
   "Ring.toAddCommGroup",
   "Nat.instMod"],
  "name": "pow_add_pow_eq_prod_add_zeta_runity_mul",
  "constType":
  "∀ {K : Type u_1} [inst : CommRing K] [inst_1 : IsDomain K] {ζ : K} {n : ℕ},\n  n % 2 = 1 → IsPrimitiveRoot ζ n → ∀ (x y : K), x ^ n + y ^ n = ∏ ζ ∈ Polynomial.nthRootsFinset n K, (x + ζ * y)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Singleton",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "OfNat.ofNat",
   "AddZeroClass.add_zero",
   "instHAdd",
   "HAdd.hAdd",
   "AddZeroClass",
   "Eq"],
  "name": "add_zero",
  "constType": "∀ {M : Type u} [inst : AddZeroClass M] (a : M), a + 0 = a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "EStateM.instMonad",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Bind.bind",
   "Nat",
   "Lean.Name.anonymous",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "instMonadExceptOfMonadExceptOf",
   "Lean.Syntax.atom",
   "ReaderT.instMonadExceptOf",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "EStateM.instMonadExceptOfOfBacktrackable",
   "Lean.MacroScope",
   "Lean.MonadRef.mkInfoFromRefPos",
   "ReaderT.instApplicativeOfMonad",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkNum",
   "letFun",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "ReaderT.instMonad",
   "Lean.Name"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "PNat.ne_zero",
   "instOfNatNat",
   "Nat",
   "Eq",
   "PNat"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.34",
  "constType": "∀ (n : ℕ+), (↑n = 0) = False",
  "constCategory": "Theorem"},
 {"references": ["SMul", "Monoid", "MulAction"],
  "name": "MulAction.toSMul",
  "constType":
  "{α : Type u_11} → {β : Type u_12} → [inst : Monoid α] → [self : MulAction α β] → SMul α β",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "DivInvMonoid.Pow",
   "inv_inj",
   "Int.negSucc_mul_negSucc",
   "Eq",
   "DivisionMonoid",
   "Eq.mpr",
   "pow_mul",
   "Nat.cast",
   "instHPow",
   "Monoid.toNatPow",
   "Int.instNegInt",
   "instOfNatNat",
   "InvolutiveInv.toInv",
   "Nat",
   "DivisionMonoid.toInvolutiveInv",
   "InvOneClass.toInv",
   "Eq.symm",
   "Nat.succ",
   "id",
   "zpow_negSucc",
   "HPow.hPow",
   "inv_pow",
   "instAddNat",
   "Int.instMul",
   "instHAdd",
   "Neg.neg",
   "inv_inv",
   "Int.ofNat_mul_negSucc",
   "DivInvMonoid.toMonoid",
   "zpow_natCast",
   "Int.negSucc_mul_ofNat",
   "DivInvMonoid.toInv",
   "instHMul",
   "instNatCastInt",
   "propext",
   "DivInvOneMonoid.toInvOneClass",
   "Int.negSucc",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "zpow_neg",
   "instMulNat",
   "DivisionMonoid.toDivInvOneMonoid",
   "zpow_mul.match_1",
   "congrArg",
   "Int",
   "Inv.inv"],
  "name": "zpow_mul",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionMonoid α] (a : α) (m n : ℤ), a ^ (m * n) = (a ^ m) ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommSemigroup.toAddCommMagma",
   "RingHom",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "AddHomClass",
   "SemilinearMapClass",
   "Semiring",
   "Module",
   "AddCommMagma.toAdd",
   "AddCommMonoid.toAddCommSemigroup",
   "AddCommMonoid"],
  "name": "SemilinearMapClass.toAddHomClass",
  "constType":
  "∀ {F : Type u_17} {R : outParam (Type u_18)} {S : outParam (Type u_19)} [inst : Semiring R] [inst_1 : Semiring S]\n  {σ : outParam (R →+* S)} {M : outParam (Type u_20)} {M₂ : outParam (Type u_21)} [inst_2 : AddCommMonoid M]\n  [inst_3 : AddCommMonoid M₂] [inst_4 : Module R M] [inst_5 : Module S M₂] [inst_6 : FunLike F M M₂]\n  [self : SemilinearMapClass F σ M M₂], AddHomClass F M M₂",
  "constCategory": "Theorem"},
 {"references": ["DistribLattice", "Lattice"],
  "name": "DistribLattice.toLattice",
  "constType": "{α : Type u_1} → [self : DistribLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HSub.hSub",
   "AddCommMonoid.toAddMonoid",
   "Sub",
   "AddCommMagma.toAdd",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "tsub_eq_zero_iff_le",
   "OrderedSub",
   "propext",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.9",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b : α},\n  (a - b = 0) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Monad",
   "Monad.toApplicative",
   "Bool.false",
   "Lean.MonadRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bind.bind",
   "Pure.pure",
   "Lean.MonadRef.getRef",
   "Lean.Syntax",
   "Monad.toBind",
   "Applicative.toPure"],
  "name": "Lean.MonadRef.mkInfoFromRefPos",
  "constType":
  "{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadRef m] → m Lean.SourceInfo",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "true_and",
   "Mathlib.Data.Subtype._auxLemma.2",
   "Subtype.val",
   "Set.toFinset",
   "Init.PropLemmas._auxLemma.33",
   "Set",
   "Eq.refl",
   "True",
   "iff_self",
   "Finset.instMembership",
   "Eq",
   "Iff.of_eq",
   "exists_prop_congr",
   "Fintype",
   "Iff",
   "Set.Elem",
   "Finset",
   "Function.Embedding",
   "DFunLike.coe",
   "Eq.trans",
   "Subtype",
   "Membership.mem",
   "funext",
   "Init.PropLemmas._auxLemma.19",
   "Mathlib.Data.Finset.Image._auxLemma.1",
   "Function.Embedding.subtype",
   "Set.instMembership",
   "Mathlib.Data.Fintype.Basic._auxLemma.1",
   "Finset.map",
   "Finset.univ",
   "And",
   "of_eq_true",
   "propext",
   "congrArg",
   "Function.instFunLikeEmbedding",
   "Subtype.mk"],
  "name": "Set.mem_toFinset",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, a ∈ s.toFinset ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "CommSemiring",
   "Eq.refl",
   "Eq.symm",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.add_congr",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a a' b b' c : R}, a = a' → b = b' → a' + b' = c → a + b = c",
  "constCategory": "Theorem"},
 {"references": ["SMul"],
  "name": "IsScalarTower",
  "constType":
  "(M : Type u_11) → (N : Type u_12) → (α : Type u_13) → [inst : SMul M N] → [inst : SMul N α] → [inst : SMul M α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "OfNat.ofNat",
   "le_iff_exists_nonneg_add",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "AddSubmonoid.closure",
   "SetLike.instMembership",
   "Preorder.toLE",
   "Eq",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Star.star",
   "AddSubmonoid.instSetLike",
   "StarOrderedRing.mk",
   "AddSubmonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Init.Core._auxLemma.6",
   "instHMul",
   "And",
   "IsLeftCancelAdd.contravariant_add_le_of_contravariant_add_lt",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "congr",
   "StarAddMonoid.toInvolutiveStar",
   "Int.instStarRing",
   "MonoidWithZero.toZero",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Exists",
   "Int.instAddGroup",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "LinearOrderedRing.toStrictOrderedRing",
   "Int.instSemiring",
   "CommRing.toNonUnitalCommRing",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "Semiring.toMonoidWithZero",
   "GE.ge",
   "Mathlib.Algebra.Order.Monoid.Submonoid._auxLemma.2",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "iff_self",
   "Set.range",
   "Zero.toOfNat0",
   "InvolutiveStar.toStar",
   "Int.instAddMonoid",
   "Int.instCovariantClassAddLE",
   "AddMonoid.toZero",
   "AddGroup.toAddCancelMonoid",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Int.addSubmonoid_closure_range_mul_self",
   "TrivialStar.star_trivial",
   "Membership.mem",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "AddSubmonoid.nonneg",
   "funext",
   "IsCancelAdd.toIsLeftCancelAdd",
   "StarOrderedRing",
   "instHAdd",
   "AddGroup.existsAddOfLE",
   "Int.instTrivialStar",
   "NonUnitalNonAssocSemiring.toMul",
   "LE.le",
   "StarRing.toStarAddMonoid",
   "Int.instCommRing",
   "Int.instLinearOrderedCommRing",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid"],
  "name": "Int.instStarOrderedRing",
  "constType": "StarOrderedRing ℤ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Part", "Nat"],
  "name": "PartENat",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "Semiring",
   "algebraMap",
   "NonUnitalNonAssocSemiring.toMul",
   "RingHom.instFunLike",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra.smul_def'",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "DFunLike.coe",
   "Algebra.toSMul"],
  "name": "Algebra.smul_def",
  "constType":
  "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  r • x = (algebraMap R A) r * x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Finite",
  "constType": "Sort u_1 → Prop",
  "constCategory": "Other"},
 {"references":
  ["OfNat.ofNat",
   "Int.instDecidableEq",
   "Finset.instInsert",
   "HAdd.hAdd",
   "IsRegularPrime",
   "Insert.insert",
   "Finset.gcd",
   "Int.instAdd",
   "Eq",
   "Nat.Prime",
   "instLENat",
   "Nat.cast",
   "Finset",
   "instOfNatNat",
   "Nat",
   "instOfNat",
   "id",
   "HPow.hPow",
   "Ne",
   "Int.instHPowNat",
   "Int.instDvd",
   "Int.instMul",
   "instHAdd",
   "Int.instNormalizedGCDMonoid",
   "Int.ModEq",
   "Finset.instSingleton",
   "Dvd.dvd",
   "Int.instCancelCommMonoidWithZero",
   "LE.le",
   "instHMul",
   "instNatCastInt",
   "HMul.hMul",
   "Singleton.singleton",
   "Not",
   "Fact",
   "Int"],
  "name": "FltRegular.CaseI.SlightlyEasier",
  "constType": "Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_10",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.ParserDescr.node",
   "Lean.Name.mkNum",
   "instOfNatNat",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termP._@.FltRegular.CaseI.Statement._hyg.15",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "OreLocalization.OreSet",
   "CommMonoidWithZero.toZero",
   "MulZeroOneClass.toMulOneClass",
   "OreLocalization.instCommMonoid",
   "OreLocalization.instRing",
   "Semiring.toMonoidWithZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing.mk",
   "CommRing",
   "CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "CommMonoid",
   "MonoidWithZero.toMonoid",
   "OreLocalization",
   "Ring",
   "MonoidWithZero.toMulActionWithZero",
   "CommRing.toRing",
   "Submonoid",
   "inferInstanceAs",
   "OreLocalization.instCommRing.proof_1",
   "CommSemiring.toCommMonoidWithZero",
   "MulActionWithZero.toMulAction"],
  "name": "OreLocalization.instCommRing",
  "constType":
  "{R : Type u_1} →\n  [inst : CommRing R] → {S : Submonoid R} → [inst_1 : OreLocalization.OreSet S] → CommRing (OreLocalization S R)",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "Exists",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "Trans.trans",
   "Eq.refl",
   "Exists.intro",
   "Nontrivial.mk",
   "CanonicallyOrderedCommSemiring.toOne",
   "instLTNat",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "zero_ne_one",
   "ZMod.val",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "id",
   "NeZero.succ",
   "Ne",
   "ZMod.val_one",
   "congr_arg",
   "ZMod.val_zero",
   "One.toOfNat1",
   "ZMod",
   "Semiring.toOne",
   "CommRing.toCommSemiring",
   "Nat.zero",
   "LT.lt",
   "Nat.instCanonicallyOrderedCommSemiring",
   "instTransEq",
   "Nontrivial",
   "Fact",
   "congrArg",
   "ZMod.commRing"],
  "name": "ZMod.nontrivial",
  "constType": "∀ (n : ℕ) [inst : Fact (1 < n)], Nontrivial (ZMod n)",
  "constCategory": "Definition"},
 {"references": ["OrderedAddCommMonoid", "PartialOrder"],
  "name": "OrderedAddCommMonoid.toPartialOrder",
  "constType":
  "{α : Type u_3} → [self : OrderedAddCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["propext", "GE.ge", "ge_iff_le", "LE", "LE.le", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.22",
  "constType": "∀ {α : Type u} [inst : LE α] {x y : α}, (x ≥ y) = (y ≤ x)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Mul",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Nat.Prime",
   "Nat.instSemiring",
   "Semiring.toMonoidWithZero",
   "instOfNatNat",
   "Nat",
   "Irreducible.ne_zero"],
  "name": "Nat.Prime.ne_zero",
  "constType": "∀ {n : ℕ}, Nat.Prime n → n ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Nat.card_eq_zero_of_infinite",
   "OfNat.ofNat",
   "Set.finite_or_infinite",
   "Set.infinite_coe_iff",
   "Set",
   "Set.toFinset",
   "Eq.refl",
   "Iff.mpr",
   "Set.toFinite",
   "Eq",
   "Eq.mpr",
   "Fintype",
   "Nat.card_eq_fintype_card",
   "Nat.cast",
   "Set.Infinite.encard_eq",
   "Set.toFinset_card",
   "Set.Elem",
   "Set.encard",
   "Finset",
   "instOfNatNat",
   "Nat",
   "ENat.toNat_top",
   "Set.toFinite_toFinset",
   "Set.Infinite",
   "id",
   "instENatCanonicallyOrderedCommSemiring",
   "Or",
   "Infinite",
   "Top.top",
   "Set.ncard.eq_1",
   "Fintype.card",
   "instENatTop",
   "Or.casesOn",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "ENat.toNat_coe",
   "Set.Finite",
   "ENat",
   "letFun",
   "Set.Finite.fintype",
   "Set.ncard",
   "ENat.toNat",
   "Nat.card",
   "congrArg",
   "Finite.of_fintype",
   "Set.Finite.toFinset",
   "Set.Finite.encard_eq_coe_toFinset_card"],
  "name": "Set.Nat.card_coe_set_eq",
  "constType": "∀ {α : Type u_1} (s : Set α), Nat.card ↑s = s.ncard",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Ring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "Decidable.casesOn",
   "Nat.pred",
   "Decidable",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.decEq",
   "Int",
   "Int.neg",
   "Eq"],
  "name": "FltRegular.CaseI.f0k₁._cstage1",
  "constType": "ℤ → ℕ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Tactic.Zify.natCast_eq",
   "Nat.cast",
   "instNatCastInt",
   "propext",
   "Nat",
   "Int",
   "Eq"],
  "name": "Mathlib.Tactic.Zify._auxLemma.1",
  "constType": "∀ (a b : ℕ), (a = b) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "And",
   "Exists",
   "propext",
   "Multiset",
   "Multiset.mem_map",
   "Eq",
   "Multiset.instMembership"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.19",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {f : α → β} {b : β} {s : Multiset α}, (b ∈ Multiset.map f s) = ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references": ["Iff", "Classical.propDecidable", "Not", "Decidable.not_not"],
  "name": "Classical.not_not",
  "constType": "∀ {a : Prop}, ¬¬a ↔ a",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalRing"],
  "name": "NonUnitalRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u_1} → [self : NonUnitalRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["AddMonoid"],
  "name": "AddUnits",
  "constType": "(α : Type u) → [inst : AddMonoid α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_8",
   "_obj",
   "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_4",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["add_lt_add_iff_right",
   "Function.swap",
   "propext",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "Add",
   "ContravariantClass",
   "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.23",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : ContravariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b c : α},\n  (b + a < c + a) = (b < c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Set.preimage",
   "Iff.rfl",
   "Set",
   "Set.instMembership"],
  "name": "Set.mem_preimage",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {s : Set β} {a : α}, a ∈ f ⁻¹' s ↔ f a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "AddGroupWithOne.toIntCast",
   "AddGroup.toSubtractionMonoid",
   "Int.cast_eq_zero",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "CharZero",
   "propext",
   "Int.cast",
   "AddGroupWithOne",
   "NegZeroClass.toZero",
   "Int",
   "instOfNat",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CaseI._auxLemma.3",
  "constType":
  "∀ {α : Type u_3} [inst : AddGroupWithOne α] [inst_1 : CharZero α] {n : ℤ}, (↑n = 0) = (n = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.natCast_ne_zero",
   "OfNat.ofNat",
   "Mathlib.Data.Nat.Prime.Basic._auxLemma.6",
   "And.left",
   "implies_congr",
   "instLTNat",
   "Iff.mpr",
   "MulZeroClass.toMul",
   "Eq",
   "And.right",
   "Nat.Prime",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "Nat.instDvd",
   "Nat",
   "Eq.trans",
   "instOfNat",
   "Nat.isUnit_iff",
   "Nat.cast_one",
   "Int.isUnit_iff_natAbs_eq",
   "Ne",
   "Or",
   "Nat.Prime.pos",
   "Int.instDvd",
   "Int.instRing",
   "Nat.prime_iff",
   "Mathlib.Algebra.Associated.Basic._auxLemma.2",
   "MulZeroOneClass.toMulZeroClass",
   "SemigroupWithZero.toSemigroup",
   "Iff.intro",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "And",
   "Prime",
   "False.elim",
   "AddMonoidWithOne.toOne",
   "Int.dvd_natAbs",
   "Nat.instMonoid",
   "propext",
   "LT.lt",
   "Eq.mp",
   "congr",
   "Not",
   "And.intro",
   "congrArg",
   "Int",
   "Int.natCast_dvd_natCast",
   "CommMonoidWithZero.toZero",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "Int.natCast_ne_zero_iff_pos",
   "semigroupDvd",
   "Zero.toOfNat0",
   "Nat.Prime.ne_one",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "CommMonoidWithZero.toMonoidWithZero",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "False",
   "Int.instMul",
   "LinearOrderedCommMonoidWithZero.toCommMonoidWithZero",
   "One.toOfNat1",
   "Dvd.dvd",
   "Int.instMonoid",
   "mt",
   "instNatCastInt",
   "Nat.Prime.dvd_mul",
   "HMul.hMul",
   "IsUnit",
   "Int.ofNat_mul",
   "instMulNat",
   "Int.natAbs_mul",
   "Int.instCommSemiring",
   "Int.natAbs"],
  "name": "Nat.prime_iff_prime_int",
  "constType": "∀ {p : ℕ}, Nat.Prime p ↔ Prime ↑p",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result"],
  "name": "EStateM",
  "constType": "Type u → Type u → Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Set.instMembership",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.1",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Add"],
  "name": "IsLeftCancelAdd",
  "constType": "(G : Type u) → [inst : Add G] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Zero.toOfNat0",
   "NoZeroDivisors",
   "instHMul",
   "mul_eq_zero",
   "Or",
   "OfNat.ofNat",
   "propext",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "FltRegular.CaseII.AuxLemmas._auxLemma.3",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, (a * b = 0) = (a = 0 ∨ b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_5",
   "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_2",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "propext",
   "Int.cast",
   "Int.ModEq",
   "Ring.toIntCast",
   "CommRing.toRing",
   "Nat",
   "Eq.symm",
   "Int",
   "ZMod.intCast_eq_intCast_iff",
   "ZMod",
   "ZMod.commRing",
   "Eq"],
  "name": "FltRegular.MayAssume.Lemmas._auxLemma.2",
  "constType": "∀ (a b : ℤ) (c : ℕ), (a ≡ b [ZMOD ↑c]) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.Name.num._override",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "FunLike",
   "AddHomClass",
   "AddMonoidHomClass",
   "AddZeroClass"],
  "name": "AddMonoidHomClass.toAddHomClass",
  "constType":
  "∀ {F : Type u_10} {M : Type u_11} {N : Type u_12} [inst : AddZeroClass M] [inst_1 : AddZeroClass N]\n  [inst_2 : FunLike F M N] [self : AddMonoidHomClass F M N], AddHomClass F M N",
  "constCategory": "Theorem"},
 {"references": ["Prod"],
  "name": "Prod.mk",
  "constType": "{α : Type u} → {β : Type v} → α → β → α × β",
  "constCategory": "Other"},
 {"references":
  ["instHSMul",
   "Finset.sum",
   "AddMonoidHom.instAddMonoidHomClass",
   "AddCommMonoid.toAddMonoid",
   "DistribSMul",
   "AddMonoid.toAddZeroClass",
   "map_sum",
   "Eq",
   "SMulZeroClass.toSMul",
   "DistribSMul.toAddMonoidHom",
   "DistribSMul.toSMulZeroClass",
   "AddMonoid.toZero",
   "Finset",
   "HSMul.hSMul",
   "AddMonoidHom",
   "AddMonoidHom.instFunLike",
   "AddCommMonoid"],
  "name": "Finset.smul_sum",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : AddCommMonoid β] [inst_1 : DistribSMul α β] {r : α} {f : γ → β}\n  {s : Finset γ}, r • ∑ x ∈ s, f x = ∑ x ∈ s, r • f x",
  "constCategory": "Theorem"},
 {"references": ["PNat.val", "propext", "PNat.coe_inj", "Nat", "Eq", "PNat"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.8",
  "constType": "∀ {m n : ℕ+}, (↑m = ↑n) = (m = n)",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "GCDMonoid",
   "MulZeroClass.zero_mul",
   "semigroupDvd",
   "GCDMonoid.gcd_dvd_right",
   "zero_dvd_iff",
   "SemigroupWithZero.toZero",
   "gcd_eq_zero_iff.match_3",
   "CancelCommMonoidWithZero",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "gcd_eq_zero_iff.match_1",
   "GCDMonoid.gcd",
   "Eq.mpr",
   "Iff",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "MulZeroClass.toZero",
   "Eq.symm",
   "GCDMonoid.dvd_gcd",
   "gcd_eq_zero_iff.match_2",
   "CommMonoidWithZero.toMonoidWithZero",
   "id",
   "dvd_refl",
   "GCDMonoid.gcd_dvd_left",
   "Dvd.dvd",
   "MulZeroOneClass.toMulZeroClass",
   "SemigroupWithZero.toSemigroup",
   "Iff.intro",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "propext",
   "Eq.mp",
   "HMul.hMul",
   "And.intro",
   "congrArg"],
  "name": "gcd_eq_zero_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : GCDMonoid α] (a b : α), gcd a b = 0 ↔ a = 0 ∧ b = 0",
  "constCategory": "Theorem"},
 {"references": ["One", "InvOneClass"],
  "name": "InvOneClass.toOne",
  "constType": "{G : Type u_2} → [self : InvOneClass G] → One G",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "Set",
   "Algebra",
   "CommRing",
   "PNat"],
  "name": "IsCyclotomicExtension",
  "constType":
  "Set ℕ+ → (A : Type u) → (B : Type v) → [inst : CommRing A] → [inst_1 : CommRing B] → [inst : Algebra A B] → Prop",
  "constCategory": "Other"},
 {"references":
  ["PNat.val",
   "Membership.mem",
   "IsCyclotomicExtension",
   "CommRing.toCommMonoid",
   "Exists",
   "CommSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "IsPrimitiveRoot",
   "Set",
   "Algebra",
   "Set.instMembership",
   "CommRing",
   "PNat"],
  "name": "IsCyclotomicExtension.exists_prim_root",
  "constType":
  "∀ {S : Set ℕ+} (A : Type u) {B : Type v} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [self : IsCyclotomicExtension S A B] {n : ℕ+}, n ∈ S → ∃ r, IsPrimitiveRoot r ↑n",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Eq.symm", "Eq"],
  "name": "Ne.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a ≠ b → b ≠ a",
  "constCategory": "Theorem"},
 {"references": ["Lattice", "ConditionallyCompleteLattice"],
  "name": "ConditionallyCompleteLattice.toLattice",
  "constType":
  "{α : Type u_5} → [self : ConditionallyCompleteLattice α] → Lattice α",
  "constCategory": "Definition"},
 {"references": ["Lean.TSyntax", "Lean.SyntaxNodeKinds", "Lean.Syntax"],
  "name": "Lean.TSyntax.mk",
  "constType": "{ks : Lean.SyntaxNodeKinds} → Lean.Syntax → Lean.TSyntax ks",
  "constCategory": "Other"},
 {"references": ["Int.mul", "Mul", "Int", "Mul.mk"],
  "name": "Int.instMul",
  "constType": "Mul ℤ",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_14",
   "_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_5",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.range",
   "propext",
   "LT.lt",
   "Multiset",
   "Nat",
   "instLTNat",
   "Eq",
   "Multiset.mem_range",
   "Multiset.instMembership"],
  "name": "FltRegular.NumberTheory.KummersLemma.Field._auxLemma.8",
  "constType": "∀ {m n : ℕ}, (m ∈ Multiset.range n) = (m < n)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "EStateM.instMonad",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Bind.bind",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "instMonadExceptOfMonadExceptOf",
   "Lean.Syntax.atom",
   "Lean.Syntax.node5",
   "ReaderT.instMonadExceptOf",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "EStateM.instMonadExceptOfOfBacktrackable",
   "Lean.MacroScope",
   "Lean.MonadRef.mkInfoFromRefPos",
   "ReaderT.instApplicativeOfMonad",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkNum",
   "letFun",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "ReaderT.instMonad",
   "Lean.Name"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Finset.instInsert",
   "Int.instDecidableEq",
   "HAdd.hAdd",
   "IsRegularPrime",
   "Insert.insert",
   "Finset.gcd",
   "Int.instAdd",
   "Eq",
   "Nat.Prime",
   "instLENat",
   "Nat.cast",
   "Finset",
   "instOfNatNat",
   "Nat",
   "instOfNat",
   "id",
   "FltRegular.caseI_easier",
   "HPow.hPow",
   "Ne",
   "Int.instHPowNat",
   "Int.instDvd",
   "Int.instMul",
   "instHAdd",
   "Int.instNormalizedGCDMonoid",
   "Int.ModEq",
   "Finset.instSingleton",
   "Dvd.dvd",
   "LE.le",
   "Int.instCancelCommMonoidWithZero",
   "instHMul",
   "FltRegular.CaseI.may_assume",
   "instNatCastInt",
   "HMul.hMul",
   "Not",
   "Singleton.singleton",
   "Fact",
   "Int"],
  "name": "FltRegular.caseI",
  "constType":
  "∀ {a b c : ℤ} {p : ℕ} [inst : Fact (Nat.Prime p)], IsRegularPrime p → ¬↑p ∣ a * b * c → a ^ p + b ^ p ≠ c ^ p",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_3",
   "_obj",
   "String.toSubstring'"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Membership.mem",
   "Exists",
   "CommSemiring.toSemiring",
   "instHAdd",
   "HAdd.hAdd",
   "Set",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.completeLattice",
   "Ideal.span",
   "NonUnitalNonAssocSemiring.toMul",
   "SetLike.instMembership",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "instHMul",
   "And",
   "Set.instSingletonSet",
   "Semiring.toNonAssocSemiring",
   "SemilatticeSup.toSup",
   "CompleteLattice.toConditionallyCompleteLattice",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "Singleton.singleton",
   "Sup.sup",
   "Ideal.mem_span_singleton_sup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Lattice.toSemilatticeSup",
   "Ideal",
   "Submodule.setLike",
   "Semiring.toModule"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.6",
  "constType":
  "∀ {S : Type u_1} [inst : CommSemiring S] {x y : S} {I : Ideal S}, (x ∈ Ideal.span {y} ⊔ I) = ∃ a, ∃ b ∈ I, a * y + b = x",
  "constCategory": "Theorem"},
 {"references": ["outParam", "SProd"],
  "name": "SProd.sprod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : SProd α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references":
  ["Int.add_le_add_left",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "CovariantClass.mk",
   "LE.le",
   "Int",
   "Int.instLEInt",
   "Int.instAdd"],
  "name": "Int.instCovariantClassAddLE",
  "constType": "CovariantClass ℤ ℤ (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Zero"],
  "name": "NeZero",
  "constType": "{R : Type u_1} → [inst : Zero R] → R → Prop",
  "constCategory": "Other"},
 {"references": ["Multiset.Mem", "Multiset", "Membership.mk", "Membership"],
  "name": "Multiset.instMembership",
  "constType": "{α : Type u_1} → Membership α (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["ZeroLEOneClass",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "lt_add_one",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "Eq",
   "PartialOrder",
   "AddMonoidWithOne",
   "Eq.mpr",
   "NeZero",
   "one_add_one_eq_two",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "Preorder.toLT",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "LT.lt",
   "CovariantClass",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "congrArg",
   "id",
   "instOfNatAtLeastTwo"],
  "name": "one_lt_two",
  "constType":
  "∀ {α : Type u_1} [inst : AddMonoidWithOne α] [inst_1 : PartialOrder α] [inst_2 : ZeroLEOneClass α] [inst_3 : NeZero 1]\n  [inst_4 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1], 1 < 2",
  "constCategory": "Theorem"},
 {"references":
  ["setOf",
   "Submodule",
   "Semiring",
   "Set",
   "Set.instHasSubset",
   "Submodule.instInfSet",
   "InfSet.sInf",
   "HasSubset.Subset",
   "Module",
   "Submodule.setLike",
   "SetLike.coe",
   "AddCommMonoid"],
  "name": "Submodule.span",
  "constType":
  "(R : Type u_1) →\n  {M : Type u_4} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Set M → Submodule R M",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___unexpand_CyclotomicField_1._closed_1",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___unexpand_CyclotomicField_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddMonoid.toZero",
   "AddMonoid.zero_add",
   "AddZeroClass.mk",
   "AddZeroClass",
   "AddMonoid.add_zero",
   "AddMonoid"],
  "name": "AddMonoid.toAddZeroClass",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddZeroClass M",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.quotientRel",
   "Submodule",
   "Quotient.mk''",
   "Submodule.hasQuotient",
   "Ring",
   "AddCommGroup.toAddCommMonoid",
   "HasQuotient.Quotient",
   "Module",
   "AddCommGroup",
   "Ring.toSemiring"],
  "name": "Submodule.Quotient.mk",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} → [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → {p : Submodule R M} → M → M ⧸ p",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_12",
   "Lean.Name.str._override",
   "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_6"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["CommMonoidWithZero", "CancelCommMonoidWithZero"],
  "name": "CancelCommMonoidWithZero.toCommMonoidWithZero",
  "constType":
  "{M₀ : Type u_4} → [self : CancelCommMonoidWithZero M₀] → CommMonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "StrictOrderedSemiring",
   "LinearOrderedSemiring.toStrictOrderedSemiring",
   "Nat",
   "Nat.instLinearOrderedSemiring"],
  "name": "Nat.instStrictOrderedSemiring",
  "constType": "StrictOrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["propext",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "CovariantClass",
   "LT",
   "add_lt_add_iff_left",
   "Add",
   "ContravariantClass",
   "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.24",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b c : α},\n  (a + b < a + c) = (b < c)",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "isUnit_of_dvd_one",
   "HAdd.hAdd",
   "Eq.refl",
   "semigroupDvd",
   "Eq",
   "Nat.recAux",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "MonoidWithZero.toSemigroupWithZero",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "CommMonoid.toMonoid",
   "absurd",
   "CommMonoidWithZero.toMonoidWithZero",
   "HPow.hPow",
   "Prime.dvd_or_dvd",
   "Or",
   "Or.inr",
   "instAddNat",
   "instHAdd",
   "CommMonoidWithZero.toCommMonoid",
   "Dvd.dvd",
   "One.toOfNat1",
   "pow_succ'",
   "Or.casesOn",
   "Monoid.toMulOneClass",
   "CommMonoidWithZero",
   "pow_zero",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Prime",
   "Prime.not_unit",
   "Or.inl",
   "letFun",
   "Eq.mp",
   "HMul.hMul",
   "Not",
   "IsUnit",
   "congrArg"],
  "name": "Prime.dvd_of_dvd_pow",
  "constType":
  "∀ {α : Type u_1} [inst : CommMonoidWithZero α] {p : α}, Prime p → ∀ {a : α} {n : ℕ}, p ∣ a ^ n → p ∣ a",
  "constCategory": "Theorem"},
 {"references": ["propext", "Not", "not_imp_self", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.20",
  "constType": "∀ {a : Prop}, (¬a → a) = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Int",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["Set.encard", "Set", "Nat", "ENat.toNat"],
  "name": "Set.ncard",
  "constType": "{α : Type u_1} → Set α → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Monoid.toOne",
   "eq_top_iff",
   "Iff.rfl",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "Semiring.toMonoidWithZero",
   "Submodule.completeLattice",
   "Submodule.instTop",
   "CommSemiring.toNonUnitalCommSemiring",
   "Ideal.span",
   "semigroupDvd",
   "Preorder.toLE",
   "Eq",
   "OrderTop.toTop",
   "Semiring.toNonAssocSemiring",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Iff",
   "MonoidWithZero.toMonoid",
   "CommSemiring",
   "isUnit_iff_dvd_one",
   "Ideal.span_singleton_one",
   "CommSemiring.toCommMonoid",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "CommMonoid.toMonoid",
   "Eq.symm",
   "Semiring.toModule",
   "id",
   "Monoid.toSemigroup",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "Top.top",
   "Dvd.dvd",
   "One.toOfNat1",
   "LE.le",
   "Semiring.toOne",
   "SemigroupWithZero.toSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Singleton.singleton",
   "IsUnit",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "Ideal",
   "Submodule.instOrderTop",
   "Ideal.span_singleton_le_span_singleton"],
  "name": "Ideal.span_singleton_eq_top",
  "constType":
  "∀ {α : Type u} [inst : CommSemiring α] {x : α}, Ideal.span {x} = ⊤ ↔ IsUnit x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Iff",
   "Iff.rfl",
   "Set",
   "Singleton.singleton",
   "Set.instMembership",
   "Eq"],
  "name": "Set.mem_singleton_iff",
  "constType": "∀ {α : Type u} {a b : α}, a ∈ {b} ↔ a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "Multiset.mem_cons",
   "Iff",
   "Finset",
   "Finset.cons",
   "Finset.val",
   "Not",
   "Eq",
   "Finset.instMembership"],
  "name": "Finset.mem_cons",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {a b : α} {h : a ∉ s}, b ∈ Finset.cons a s h ↔ b = a ∨ b ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "CommMonoid",
   "IsPrimitiveRoot",
   "propext",
   "One.toOfNat1",
   "instOfNatNat",
   "CommMonoid.toMonoid",
   "Nat",
   "IsPrimitiveRoot.one_right_iff",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.13",
  "constType":
  "∀ {M : Type u_1} [inst : CommMonoid M] {ζ : M}, IsPrimitiveRoot ζ 1 = (ζ = 1)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "WfDvdMonoid.wellFounded_dvdNotUnit",
   "Set.range_nonempty",
   "HAdd.hAdd",
   "MulZeroClass.mul_zero",
   "Exists.casesOn",
   "MulZeroClass.toMul",
   "CommMonoid.toCommSemigroup",
   "Classical.byContradiction",
   "Eq",
   "CancelCommMonoidWithZero.toIsLeftCancelMulZero",
   "multiplicity.Finite",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "HPow.hPow",
   "Ne",
   "CommMonoidWithZero.toCommMonoid",
   "Set.instMembership",
   "CommMagma.toMul",
   "MulZeroOneClass.toMulZeroClass",
   "SemigroupWithZero.toSemigroup",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "of_eq_true",
   "propext",
   "Eq.mp",
   "instInhabitedNat",
   "congr",
   "FltRegular.CaseII.AuxLemmas._auxLemma.2",
   "Not",
   "And.intro",
   "congrArg",
   "Classical.choose_spec",
   "CommMonoidWithZero.toZero",
   "Exists",
   "Classical.choose",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "FltRegular.CaseII.AuxLemmas._auxLemma.1",
   "Set",
   "WellFounded.has_min",
   "Eq.refl",
   "MulZeroClass.zero_mul",
   "semigroupDvd",
   "Exists.intro",
   "rfl",
   "True",
   "CancelCommMonoidWithZero",
   "Set.range",
   "Zero.toOfNat0",
   "mul_comm",
   "Classical.not_exists_not",
   "instHPow",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Eq.symm",
   "multiplicity.Finite.eq_1",
   "CommMonoidWithZero.toMonoidWithZero",
   "id",
   "eq_self",
   "DvdNotUnit",
   "Membership.mem",
   "Monoid.toSemigroup",
   "WfDvdMonoid",
   "False",
   "instAddNat",
   "instHAdd",
   "instNonemptyOfInhabited",
   "Dvd.dvd",
   "Monoid.toMulOneClass",
   "Function.Injective.eq_iff",
   "Eq.ndrec",
   "CommSemigroup.toCommMagma",
   "mul_right_injective₀",
   "HMul.hMul",
   "IsUnit"],
  "name": "WfDvdMonoid.multiplicity_finite",
  "constType":
  "∀ {M : Type u_2} [inst : CancelCommMonoidWithZero M] [inst_1 : WfDvdMonoid M] {x y : M},\n  ¬IsUnit x → y ≠ 0 → multiplicity.Finite x y",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.instLocallyFiniteOrder.proof_6",
   "instHSub",
   "Nat.instLocallyFiniteOrder.proof_1",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Lattice.toSemilatticeInf",
   "List.range'",
   "instSubNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "SemilatticeInf.toPartialOrder",
   "LocallyFiniteOrder",
   "instDistribLatticeNat",
   "LocallyFiniteOrder.mk",
   "Nat.instLocallyFiniteOrder.proof_7",
   "DistribLattice.toLattice",
   "Nat.instLocallyFiniteOrder.proof_3",
   "Nat.instLocallyFiniteOrder.proof_4",
   "Nat.instLocallyFiniteOrder.proof_8",
   "Nat.instLocallyFiniteOrder.proof_2",
   "instOfNatNat",
   "Nat",
   "Finset.mk",
   "Multiset.ofList",
   "Nat.instLocallyFiniteOrder.proof_5"],
  "name": "Nat.instLocallyFiniteOrder",
  "constType": "LocallyFiniteOrder ℕ",
  "constCategory": "Definition"},
 {"references":
  ["AlgEquiv.instFunLike.proof_1",
   "AlgEquiv",
   "FunLike",
   "Semiring",
   "CommSemiring",
   "Algebra",
   "EquivLike.toFunLike",
   "DFunLike.coe",
   "DFunLike.mk",
   "AlgEquiv.instEquivLike"],
  "name": "AlgEquiv.instFunLike",
  "constType":
  "{R : Type uR} →\n  {A₁ : Type uA₁} →\n    {A₂ : Type uA₂} →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A₁] →\n          [inst_2 : Semiring A₂] → [inst_3 : Algebra R A₁] → [inst_4 : Algebra R A₂] → FunLike (A₁ ≃ₐ[R] A₂) A₁ A₂",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "_obj"],
  "name": "FltRegular.f._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["SDiff"],
  "name": "SDiff.sdiff",
  "constType": "{α : Type u} → [self : SDiff α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.brecOn",
   "Nat.below",
   "List.cons",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "optParam",
   "PProd",
   "PProd.fst",
   "Nat.rec",
   "List",
   "List.range'.match_1",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "Nat.succ"],
  "name": "List.range'",
  "constType": "ℕ → ℕ → optParam ℕ 1 → List ℕ",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg",
   "MulOneClass.toMul",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHSMul",
   "MulZeroOneClass.toMulOneClass",
   "Distrib.rightDistribClass",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "natCast_zsmul",
   "Eq.mpr",
   "Nat.cast",
   "negSucc_zsmul",
   "HSMul.hSMul",
   "nsmul_eq_mul",
   "HasDistribNeg.toInvolutiveNeg",
   "Nat",
   "NonAssocRing.toNonAssocSemiring",
   "Eq.trans",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "MulOneClass.toOne",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "SubNegMonoid.SMulInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "NonAssocRing.toIntCast",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Int.cast",
   "Int.negSucc",
   "congr",
   "congrArg",
   "Int",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonAssocRing",
   "NonAssocRing.toAddCommGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "Eq.refl",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "add_mul",
   "one_mul",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "AddMonoid.toAddSemigroup",
   "Nat.cast_succ",
   "instOfNatNat",
   "Int.cast_negSucc",
   "neg_mul",
   "Nat.succ",
   "id",
   "eq_self",
   "zsmul_eq_mul.match_1",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.cast_natCast",
   "instAddNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddGroup.toSubNegMonoid",
   "AddMonoid.toNatSMul",
   "instNatCastInt",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "NonAssocSemiring.toNatCast",
   "HMul.hMul",
   "neg_add_rev"],
  "name": "zsmul_eq_mul",
  "constType":
  "∀ {α : Type u_3} [inst : NonAssocRing α] (a : α) (n : ℤ), n • a = ↑n * a",
  "constCategory": "Theorem"},
 {"references":
  ["SubsemiringClass",
   "SetLike",
   "MulZeroOneClass.toMulOneClass",
   "SubmonoidClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring"],
  "name": "SubsemiringClass.toSubmonoidClass",
  "constType":
  "∀ {S : Type u_1} {R : Type u} [inst : NonAssocSemiring R] [inst_1 : SetLike S R] [self : SubsemiringClass S R],\n  SubmonoidClass S R",
  "constCategory": "Theorem"},
 {"references": ["MulOneClass", "MonoidHom"],
  "name": "Monoid.End",
  "constType": "(M : Type u_4) → [inst : MulOneClass M] → Type u_4",
  "constCategory": "Definition"},
 {"references": ["InvOneClass", "Inv"],
  "name": "InvOneClass.toInv",
  "constType": "{G : Type u_2} → [self : InvOneClass G] → Inv G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "PUnit",
  "constType": "Sort u",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "instAddNat",
   "MulOneClass.toOne",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "One.toOfNat1",
   "pow_zero",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "Eq.mpr",
   "one_mul",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "pow_succ",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "id"],
  "name": "pow_one",
  "constType": "∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddGroup",
   "AddGroupWithOne.zsmul_succ'",
   "AddGroupWithOne.toSub",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroup.mk",
   "AddGroupWithOne.toNeg",
   "AddGroupWithOne",
   "AddGroupWithOne.zsmul",
   "AddGroupWithOne.zsmul_zero'",
   "AddGroupWithOne.zsmul_neg'",
   "SubNegMonoid.mk",
   "AddGroupWithOne.add_left_neg",
   "AddGroupWithOne.sub_eq_add_neg"],
  "name": "AddGroupWithOne.toAddGroup",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddGroup R",
  "constCategory": "Definition"},
 {"references":
  ["DivisionRing",
   "AddGroupWithOne.toAddMonoidWithOne",
   "DivisionRing.toDivisionSemiring",
   "SMul.mk",
   "Rat.cast_commute",
   "Ring.toAddGroupWithOne",
   "instHSMul",
   "Rat.castHom",
   "DivisionRing.toRing",
   "Rat.commSemiring",
   "Rat.instDistribSMul",
   "AddMonoidWithOne.toAddMonoid",
   "Rat",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "SMulZeroClass.toSMul",
   "DivisionSemiring.toSemiring",
   "CharZero",
   "DistribSMul.toSMulZeroClass",
   "Algebra",
   "Rat.smul_def",
   "HSMul.hSMul",
   "Algebra.mk",
   "MonoidWithZero.toZero"],
  "name": "algebraRat",
  "constType":
  "{α : Type u_1} → [inst : DivisionRing α] → [inst_1 : CharZero α] → Algebra ℚ α",
  "constCategory": "Definition"},
 {"references": ["forall_const", "propext", "Nonempty", "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.14",
  "constType": "∀ {b : Prop} (α : Sort u_1) [i : Nonempty α], (α → b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "CommGroupWithZero",
   "Semifield.toCommSemiring",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "Semifield.mul_inv_cancel",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semifield",
   "Semifield.toInv",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "Semifield.toNontrivial",
   "CommMonoidWithZero.mk",
   "CommMonoid.mk",
   "Semigroup.mk",
   "CommGroupWithZero.mk",
   "Semiring.mul_one",
   "NonUnitalNonAssocSemiring.toMul",
   "Semifield.zpow",
   "Semifield.zpow_neg'",
   "Semiring.toOne",
   "Semifield.zpow_zero'",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semifield.toDiv",
   "Semifield.inv_zero"],
  "name": "Semifield.toCommGroupWithZero",
  "constType": "{α : Type u_4} → [self : Semifield α] → CommGroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.le_sInf'",
   "AddZeroClass.toAdd",
   "Submodule.completeLattice.proof_5",
   "_private.Mathlib.Algebra.Module.Submodule.Lattice.0.Submodule.sInf_le'",
   "AddSubsemigroup.mk",
   "PartialOrder.toPreorder",
   "Submodule",
   "Inf.inf",
   "Set",
   "CompleteLattice.mk",
   "InfSet.sInf",
   "SupSet.mk",
   "AddCommMonoid.toAddMonoid",
   "Submodule.completeLattice.proof_11",
   "Lattice.mk",
   "OrderBot",
   "Submodule.completeLattice.proof_2",
   "AddMonoid.toAddZeroClass",
   "Sup.mk",
   "Submodule.completeLattice.proof_6",
   "Submodule.completeLattice.proof_13",
   "Preorder.toLE",
   "OrderTop.toTop",
   "inferInstance",
   "Inf.mk",
   "Submodule.completeLattice.proof_9",
   "Submodule.completeLattice.proof_1",
   "Submodule.completeLattice.proof_4",
   "AddSubmonoid.mk",
   "Lattice.toSemilatticeSup",
   "Module",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Membership.mem",
   "setOf",
   "Semiring",
   "SemilatticeSup.mk",
   "Submodule.completeLattice.proof_8",
   "Set.instMembership",
   "Submodule.instInf",
   "LE.le",
   "Submodule.completeLattice.proof_12",
   "SetLike.instPartialOrder",
   "And",
   "CompleteLattice",
   "Submodule.instOrderBot",
   "Submodule.completeLattice.proof_10",
   "Submodule.completeLattice.proof_3",
   "OrderBot.toBot",
   "Submodule.mk",
   "Submodule.instInfSet",
   "Set.iInter",
   "OrderTop",
   "Submodule.completeLattice.proof_7",
   "Submodule.instOrderTop",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Submodule.completeLattice",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_3} →\n    [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → CompleteLattice (Submodule R M)",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulOneClass.toOne",
   "neg_one_mul",
   "HasDistribNeg",
   "Neg.neg",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Commute.neg_one_left",
   "Eq",
   "instHMul",
   "InvolutiveNeg.toNeg",
   "instHPow",
   "Eq.rec",
   "HasDistribNeg.toInvolutiveNeg",
   "Commute.mul_pow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "Nat"],
  "name": "neg_pow",
  "constType":
  "∀ {R : Type x} [inst : Monoid R] [inst_1 : HasDistribNeg R] (a : R) (n : ℕ), (-a) ^ n = (-1) ^ n * a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "And",
   "Ne",
   "Nat.Prime",
   "OfNat.ofNat",
   "Nat.minFac_dvd",
   "Nat.minFac_prime",
   "Dvd.dvd",
   "instOfNatNat",
   "And.intro",
   "Nat.instDvd",
   "Exists.intro",
   "Nat.minFac",
   "Nat"],
  "name": "Nat.exists_prime_and_dvd",
  "constType": "∀ {n : ℕ}, n ≠ 1 → ∃ p, Nat.Prime p ∧ p ∣ n",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddCommMonoid.add_comm",
   "NonAssocSemiring.natCast_zero",
   "NonAssocSemiring.toOne",
   "NonAssocSemiring.toNatCast",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "NonAssocSemiring.natCast_succ",
   "AddCommMonoidWithOne.mk",
   "NonAssocSemiring"],
  "name": "NonAssocSemiring.toAddCommMonoidWithOne",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → AddCommMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocRing.toHasDistribNeg.proof_2",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "SubNegMonoid.toNeg",
   "HasDistribNeg.mk",
   "HasDistribNeg",
   "AddCommGroup.toAddGroup",
   "Neg.neg",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_1",
   "AddGroup.toSubNegMonoid",
   "InvolutiveNeg.mk",
   "NonUnitalNonAssocRing.toHasDistribNeg.proof_3",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Neg.mk"],
  "name": "NonUnitalNonAssocRing.toHasDistribNeg",
  "constType":
  "{α : Type u} → [inst : NonUnitalNonAssocRing α] → HasDistribNeg α",
  "constCategory": "Definition"},
 {"references": ["Semiring", "NonUnitalSemiring"],
  "name": "Semiring.toNonUnitalSemiring",
  "constType": "{α : Type u} → [self : Semiring α] → NonUnitalSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHAdd",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "SubtractionMonoid",
   "SubtractionMonoid.neg_add_rev",
   "Eq"],
  "name": "neg_add_rev",
  "constType":
  "∀ {G : Type u_1} [inst : SubtractionMonoid G] (a b : G), -(a + b) = -b + -a",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "instHMul",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocRing",
   "mul_sub_left_distrib",
   "HSub.hSub",
   "HMul.hMul",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "Eq"],
  "name": "mul_sub",
  "constType":
  "∀ {α : Type u} [inst : NonUnitalNonAssocRing α] (a b c : α), a * (b - c) = a * b - a * c",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "instSubNat",
   "instAddNat",
   "Nat.sub_le",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Nat.lt_succ_of_le",
   "instLTNat",
   "Eq",
   "Nat.sub_lt.match_1",
   "LT.lt",
   "Eq.rec",
   "letFun",
   "Nat.lt_irrefl",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.succ_sub_succ_eq_sub",
   "Nat.succ",
   "absurd"],
  "name": "Nat.sub_lt",
  "constType": "∀ {n m : ℕ}, 0 < n → 0 < m → n - m < n",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.instLocallyFiniteOrder",
   "OfNat.ofNat",
   "Nat.instStrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "instAddNat",
   "StrictOrderedSemiring.toPartialOrder",
   "instHAdd",
   "Finset.Ico",
   "HAdd.hAdd",
   "Finset",
   "Nat.decidable_dvd",
   "Finset.filter",
   "instOfNatNat",
   "Dvd.dvd",
   "Nat.instDvd",
   "Nat"],
  "name": "Nat.divisors",
  "constType": "ℕ → Finset ℕ",
  "constCategory": "Definition"},
 {"references":
  ["IsDomain.toIsCancelMulZero",
   "DivisionSemiring.toSemiring",
   "DivisionRing.toDivisionSemiring",
   "IsDomain.mk",
   "IsDomain",
   "Field",
   "Field.toSemifield",
   "IsDomain.toNontrivial",
   "Semifield.toDivisionSemiring",
   "Field.toDivisionRing",
   "DivisionRing.isDomain"],
  "name": "Field.isDomain",
  "constType": "∀ {K : Type u_3} [inst : Field K], IsDomain K",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr2",
  "constType": "String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Submodule.smul_mem",
   "Semiring",
   "HMul.hMul",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Ideal",
   "Submodule.setLike",
   "SetLike.instMembership",
   "Semiring.toModule"],
  "name": "Ideal.mul_mem_left",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] (I : Ideal α) (a : α) {b : α}, b ∈ I → a * b ∈ I",
  "constCategory": "Theorem"},
 {"references": ["CommSemigroup", "Semigroup"],
  "name": "CommSemigroup.toSemigroup",
  "constType": "{G : Type u} → [self : CommSemigroup G] → Semigroup G",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_23._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddSubsemigroup.mk",
   "Set.preimage",
   "Semiring",
   "RingHomClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Semiring.toNonAssocSemiring",
   "Ideal.comap.proof_2",
   "FunLike",
   "Ideal.comap.proof_1",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Ideal.comap.proof_3",
   "Submodule.mk",
   "AddSubmonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DFunLike.coe",
   "Ideal",
   "Submodule.setLike",
   "Semiring.toModule",
   "SetLike.coe"],
  "name": "Ideal.comap",
  "constType":
  "{R : Type u} →\n  {S : Type v} →\n    {F : Type u_1} →\n      [inst : Semiring R] →\n        [inst_1 : Semiring S] → [inst_2 : FunLike F R S] → [rc : RingHomClass F R S] → F → Ideal S → Ideal R",
  "constCategory": "Definition"},
 {"references":
  ["Int.instNormalizedGCDMonoid.proof_2",
   "inferInstance",
   "NormalizationMonoid",
   "GCDMonoid",
   "Int.instNormalizedGCDMonoid.proof_1",
   "NormalizedGCDMonoid",
   "NormalizedGCDMonoid.mk",
   "Int.instCancelCommMonoidWithZero",
   "Int",
   "Int.instGCDMonoid",
   "Int.normalizationMonoid"],
  "name": "Int.instNormalizedGCDMonoid",
  "constType": "NormalizedGCDMonoid ℤ",
  "constCategory": "Definition"},
 {"references": ["Union"],
  "name": "Union.union",
  "constType": "{α : Type u} → [self : Union α] → α → α → α",
  "constCategory": "Definition"},
 {"references": ["IsCancelAdd", "Add", "IsLeftCancelAdd"],
  "name": "IsCancelAdd.toIsLeftCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsLeftCancelAdd G",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedCommMonoid.toOrderedCommMonoid",
   "PartialOrder.toPreorder",
   "propext",
   "LinearOrderedCommMonoidWithZero.toZero",
   "OrderedCommMonoid.toPartialOrder",
   "LinearOrderedCommMonoidWithZero",
   "le_zero_iff",
   "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclotomicUnits._auxLemma.4",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedCommMonoidWithZero α] {a : α}, (a ≤ 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "instHDiv",
   "Eq.mpr",
   "Int.ediv_mul_cancel",
   "Int.instDvd",
   "Int.instMul",
   "Eq.refl",
   "HMul.hMul",
   "Dvd.dvd",
   "Int.instDiv",
   "HDiv.hDiv",
   "congrArg",
   "Int",
   "Int.mul_comm",
   "id",
   "Eq"],
  "name": "Int.mul_ediv_cancel'",
  "constType": "∀ {a b : ℤ}, a ∣ b → a * (b / a) = b",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionRing.toDivisionSemiring",
   "Rat.instField",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "DivisionRing.toRing",
   "Algebra.toModule",
   "Rat.commSemiring",
   "FiniteDimensional.finiteDimensional_self",
   "Rat",
   "Eq.refl",
   "Field.toSemifield",
   "algebraRat",
   "Rat.instCharZero",
   "inferInstance",
   "DivisionSemiring.toSemiring",
   "Eq.mpr",
   "Rat.instDivisionRing",
   "Rat.addCommGroup",
   "CharZero",
   "NumberField",
   "Semifield.toDivisionSemiring",
   "Ring.toAddCommGroup",
   "NumberField.mk",
   "Field.toDivisionRing",
   "Semiring.toModule",
   "FiniteDimensional"],
  "name": "Rat.numberField",
  "constType": "NumberField ℚ",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Or",
   "NonUnitalNonAssocRing.toMul",
   "OfNat.ofNat",
   "Semiring.toMonoidWithZero",
   "Neg.neg",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "Ring.toNonAssocRing",
   "Eq",
   "Semiring.toOne",
   "NoZeroDivisors",
   "Ring.toNeg",
   "MonoidWithZero.toMonoid",
   "propext",
   "instHPow",
   "Ring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "sq_eq_one_iff",
   "MonoidWithZero.toZero",
   "Nat"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.3",
  "constType":
  "∀ {R : Type x} [inst : Ring R] {a : R} [inst_1 : NoZeroDivisors R], (a ^ 2 = 1) = (a = 1 ∨ a = -1)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toCommMonoidWithZero.proof_2",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommMonoid",
   "AddMonoid.toZero",
   "CommSemiring",
   "inferInstanceAs",
   "AddCommMonoid.toAddMonoid",
   "CommMonoidWithZero.mk",
   "CommSemiring.toCommMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "CommMonoidWithZero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring.toCommMonoidWithZero.proof_1"],
  "name": "CommSemiring.toCommMonoidWithZero",
  "constType": "{α : Type u} → [inst : CommSemiring α] → CommMonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.isOfKind",
   "Lean.Name.num",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "EStateM.Result.error",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___unexpand_CyclotomicField_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatNat",
  "constType": "(n : ℕ) → OfNat ℕ n",
  "constCategory": "Definition"},
 {"references": ["GCDMonoid", "CancelCommMonoidWithZero"],
  "name": "GCDMonoid.lcm",
  "constType":
  "{α : Type u_2} → [inst : CancelCommMonoidWithZero α] → [self : GCDMonoid α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.map", "DecidableEq", "Finset", "Finset.val", "Multiset.toFinset"],
  "name": "Finset.image",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : DecidableEq β] → (α → β) → Finset α → Finset β",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_5",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["eq_false", "False", "Eq"],
  "name": "eq_false'",
  "constType": "∀ {p : Prop}, (p → False) → p = False",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CancelCommMonoidWithZero",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["LinearOrder.toLattice",
   "DistribLattice",
   "LinearOrder",
   "instDistribLatticeOfLinearOrder.proof_1",
   "DistribLattice.mk",
   "inferInstanceAs",
   "Lattice"],
  "name": "instDistribLatticeOfLinearOrder",
  "constType": "{α : Type u} → [inst : LinearOrder α] → DistribLattice α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "SubtractionMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "instLENat",
   "Mathlib.Tactic.Zify.natCast_le",
   "instNatCastInt",
   "propext",
   "Nat",
   "Int",
   "LE.le",
   "Int.instLEInt",
   "Eq"],
  "name": "Mathlib.Tactic.Zify._auxLemma.2",
  "constType": "∀ (a b : ℕ), (a ≤ b) = (↑a ≤ ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "Semigroup",
   "dvd_mul_of_dvd_left"],
  "name": "Dvd.dvd.mul_right",
  "constType":
  "∀ {α : Type u_1} [inst : Semigroup α] {a b : α}, a ∣ b → ∀ (c : α), a ∣ b * c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.num",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_8",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_16"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_17._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "AddSemigroup.toAdd",
   "Semiring",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "Even",
   "One.toOfNat1",
   "Exists.intro",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Eq",
   "Semiring.toNatCast",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "one_add_one_eq_two",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "id",
   "instOfNatAtLeastTwo"],
  "name": "even_two",
  "constType": "∀ {α : Type u_2} [inst : Semiring α], Even 2",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "Singleton.singleton",
   "Insert.insert",
   "Eq.symm",
   "LawfulSingleton",
   "EmptyCollection",
   "LawfulSingleton.insert_emptyc_eq",
   "Singleton",
   "Insert",
   "Eq"],
  "name": "FltRegular.CaseII.Statement._auxLemma.11",
  "constType":
  "∀ {α : Type u} {β : Type v} [inst : EmptyCollection β] [inst_1 : Insert α β] [inst_2 : Singleton α β]\n  [self : LawfulSingleton α β] (x : α), {x} = insert x ∅",
  "constCategory": "Theorem"},
 {"references":
  ["instHSMul",
   "DistribSMul.toSMulZeroClass",
   "Finset.smul_sum",
   "Finset.sum",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Finset",
   "AddCommMonoid.toAddMonoid",
   "DistribSMul",
   "AddMonoid.toAddZeroClass",
   "Eq.symm",
   "Eq",
   "SMulZeroClass.toSMul",
   "AddCommMonoid"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.17",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {γ : Type u_3} [inst : AddCommMonoid β] [inst_1 : DistribSMul α β] {r : α} {f : γ → β}\n  {s : Finset γ}, ∑ x ∈ s, r • f x = r • ∑ x ∈ s, f x",
  "constCategory": "Theorem"},
 {"references": ["propext", "eq_self_iff_true", "True", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.6",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.nodup",
   "And",
   "Iff",
   "DecidableEq",
   "Multiset.mem_sub_of_nodup",
   "Finset",
   "Finset.val",
   "Not",
   "SDiff.sdiff",
   "Finset.instSDiff",
   "Finset.instMembership"],
  "name": "Finset.mem_sdiff",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, a ∈ s \\ t ↔ a ∈ s ∧ a ∉ t",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_5",
   "Lean.Name.str._override",
   "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_2"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Prime.irreducible",
   "Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "IsPrimitiveRoot",
   "a_eta_zero_dvd_p_pow",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "NonUnitalCommSemiring.toCommSemigroup",
   "Ideal.span",
   "NormalizedGCDMonoid.toGCDMonoid",
   "algebraRat",
   "pow_one",
   "Ideal.instIdemCommSemiring",
   "Iff.mpr",
   "MulZeroClass.toMul",
   "Finset.instMembership",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "Field",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "Nat",
   "Subtype",
   "HPow.hPow",
   "instHSub",
   "NumberField.RingOfIntegers.instIsDedekindDomain",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "root_div_zeta_sub_one_dvd_gcd",
   "NumberField.to_charZero",
   "CommMagma.toMul",
   "EuclideanDomain.toCommRing",
   "MulZeroOneClass.toMulZeroClass",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "NumberField.RingOfIntegers.instIsDomain",
   "propext",
   "Field.toEuclideanDomain",
   "Eq.mp",
   "NumberField.inst_ringOfIntegersAlgebra",
   "NumberField",
   "CommRing.toRing",
   "dvd_gcd_mul_iff_dvd_mul",
   "Singleton.singleton",
   "Not",
   "Algebra.id",
   "congrArg",
   "Fact",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ideal",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Submodule.idemSemiring",
   "PNat.Prime",
   "Set",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "Submodule.instIdemCommSemiring",
   "CommSemiring.toNonUnitalCommSemiring",
   "semigroupDvd",
   "Irreducible.gcd_eq_one_iff",
   "NonAssocSemiring.toMulZeroOneClass",
   "p_ne_zero",
   "rfl",
   "mul_comm",
   "PNat.val",
   "GCDMonoid.gcd",
   "Set.instSingletonSet",
   "Rat.commRing",
   "one_mul",
   "instLENat",
   "instHPow",
   "Finset",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "zeta_sub_one_dvd_root",
   "id",
   "CommMonoidWithZero.toMonoidWithZero",
   "Membership.mem",
   "NeZero.succ",
   "Ideal.cancelCommMonoidWithZero",
   "instAddNat",
   "instHAdd",
   "Ideal.instNormalizedGCDMonoid",
   "pow_dvd_pow_iff",
   "Rat",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Dvd.dvd",
   "Ring.toSemiring",
   "not_p_div_a_zero",
   "LE.le",
   "p_dvd_a_iff",
   "Polynomial.nthRootsFinset",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "Prime.not_unit",
   "CommSemigroup.toCommMagma",
   "IsPrimitiveRoot.prime_span_sub_one",
   "Units.val",
   "letFun",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IdemSemiring.toSemiring",
   "NumberField.RingOfIntegers",
   "a_eta_zero_dvd_p_pow_spec",
   "IdemCommSemiring.toCommSemiring",
   "PNat"],
  "name": "one_le_m",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [hpri : Fact p.Prime] [inst : Field K] [inst_1 : NumberField K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K],\n  p ≠ 2 →\n    ∀ {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p) {x y z : NumberField.RingOfIntegers K} {ε : (NumberField.RingOfIntegers K)ˣ}\n      {m : ℕ},\n      x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p → ¬↑hζ.unit' - 1 ∣ y → ¬↑hζ.unit' - 1 ∣ z → 1 ≤ m",
  "constCategory": "Theorem"},
 {"references": ["trivial", "Eq.rec", "Eq.symm", "True", "Eq"],
  "name": "of_eq_true",
  "constType": "∀ {p : Prop}, p = True → p",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Finset.Image._auxLemma.23",
   "Exists",
   "funext",
   "Mathlib.Data.Finset.Image._auxLemma.38",
   "eq_comm",
   "Finset.instSingleton",
   "Mathlib.Data.Finset.Image._auxLemma.37",
   "Finset.instMembership",
   "Eq",
   "And",
   "Eq.mpr",
   "Iff",
   "DecidableEq",
   "Finset.ext",
   "Finset.image",
   "Finset",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "Finset.image_singleton",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] (f : α → β) (a : α), Finset.image f {a} = {f a}",
  "constCategory": "Theorem"},
 {"references": ["True"],
  "name": "True.intro",
  "constType": "True",
  "constCategory": "Other"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_left",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬a → b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Nat.pred",
   "Int.instNegInt",
   "Neg.neg",
   "instOfNatNat",
   "Nat",
   "instOfNat",
   "Int",
   "instDecidableEqNat",
   "Eq",
   "ite"],
  "name": "FltRegular.CaseI.f0k₁",
  "constType": "ℤ → ℕ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "CancelMonoidWithZero",
   "OfNat.ofNat",
   "IsCancelMulZero.toIsRightCancelMulZero",
   "Function.Injective.eq_iff",
   "MulZeroOneClass.toMulZeroClass",
   "CancelMonoidWithZero.toIsCancelMulZero",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Iff",
   "HMul.hMul",
   "mul_left_injective₀",
   "MonoidWithZero.toZero",
   "CancelMonoidWithZero.toMonoidWithZero"],
  "name": "mul_left_inj'",
  "constType":
  "∀ {M₀ : Type u_1} [inst : CancelMonoidWithZero M₀] {a b c : M₀}, c ≠ 0 → (a * c = b * c ↔ a = b)",
  "constCategory": "Theorem"},
 {"references": ["EmptyCollection", "Singleton", "Insert"],
  "name": "LawfulSingleton",
  "constType":
  "(α : Type u) → (β : Type v) → [inst : EmptyCollection β] → [inst : Insert α β] → [inst : Singleton α β] → Prop",
  "constCategory": "Other"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "eq_false",
   "False",
   "PNat.ne_zero",
   "instOfNatNat",
   "Nat",
   "Eq",
   "PNat"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.5",
  "constType": "∀ (n : ℕ+), (↑n = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "EStateM.instMonad",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Bind.bind",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Applicative.toPure",
   "instDecidableEqBool",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "instMonadExceptOfMonadExceptOf",
   "Lean.Syntax.atom",
   "Lean.Syntax.node5",
   "ReaderT.instMonadExceptOf",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "EStateM.instMonadExceptOfOfBacktrackable",
   "Lean.MacroScope",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "ReaderT.instApplicativeOfMonad",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkNum",
   "letFun",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "ReaderT.instMonad",
   "Lean.Name"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["HasSubset"],
  "name": "HasSubset.Subset",
  "constType": "{α : Type u} → [self : HasSubset α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Finsupp",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "CommSemiring",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "AddMonoidAlgebra"],
  "name": "MvPolynomial",
  "constType":
  "Type u_1 → (R : Type u_2) → [inst : CommSemiring R] → Type (max u_1 u_2)",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "instHSub",
   "AddZeroClass.toAdd",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "HSub.hSub",
   "Neg.neg",
   "sub_eq_add_neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Ring.toNonAssocRing",
   "AddGroupWithOne.toAddGroup",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "SubNegMonoid.toSub",
   "Ring.toNeg",
   "Ring.toSub",
   "Ring",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm"],
  "name": "Mathlib.Tactic.RingNF.add_neg",
  "constType": "∀ {R : Type u_2} [inst : Ring R] (a b : R), a + -b = a - b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Iff.rfl",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "propext",
   "Nat.cast_inj",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.symm",
   "id"],
  "name": "Nat.cast_eq_zero",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, ↑n = 0 ↔ n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.num",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Eq.refl",
   "One.toOfNat1",
   "AddMonoid.toAddZeroClass",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "AddMonoidWithOne",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Nat.cast_succ",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ",
   "id"],
  "name": "Nat.cast_one",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references": ["NormedRing", "Ring"],
  "name": "NormedRing.toRing",
  "constType": "{α : Type u_5} → [self : NormedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.trans",
  "constType": "∀ {α : Sort u} {a b c : α}, a = b → b = c → a = c",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "Monoid.toSemigroup",
   "instHDiv",
   "MulOneClass.toMul",
   "div_eq_mul_inv",
   "DivInvMonoid",
   "Eq.refl",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivInvMonoid.toInv",
   "instHMul",
   "mul_assoc",
   "Eq.mpr",
   "HMul.hMul",
   "HDiv.hDiv",
   "congrArg",
   "DivInvMonoid.toDiv",
   "Inv.inv",
   "id"],
  "name": "mul_div_assoc",
  "constType":
  "∀ {G : Type u_3} [inst : DivInvMonoid G] (a b c : G), a * b / c = a * (b / c)",
  "constCategory": "Theorem"},
 {"references":
  ["EquivLike.coe",
   "EquivLike",
   "FunLike",
   "EquivLike.toFunLike.proof_1",
   "DFunLike.mk"],
  "name": "EquivLike.toFunLike",
  "constType":
  "{E : Sort u_1} → {α : Sort u_3} → {β : Sort u_4} → [iE : EquivLike E α β] → FunLike E α β",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_5",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_14"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "true_and_iff", "True", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.11",
  "constType": "∀ (p : Prop), (True ∧ p) = p",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "SetLike",
  "constType": "Type u_1 → outParam (Type u_2) → Type (max u_1 u_2)",
  "constCategory": "Other"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "zpowRec",
   "Monoid.mk",
   "ZMod.instInv",
   "npowRec",
   "NNRatCast.mk",
   "ZMod.instField.proof_6",
   "Semiring.toNatCast",
   "ZMod.instField.proof_13",
   "NNRat",
   "Nat.Prime",
   "Semiring.npow",
   "ZMod.instField.proof_8",
   "Div.mk",
   "Field",
   "Ring.toIntCast",
   "ZMod.instField.proof_4",
   "Rat.cast",
   "Nat",
   "Semigroup.mk",
   "ZMod.inv_zero",
   "NNRat.castRec",
   "Rat.castRec",
   "RatCast.mk",
   "_private.Mathlib.Data.ZMod.Basic.0.ZMod.mul_inv_cancel_aux",
   "Field.mk",
   "Rat",
   "ZMod.instField.proof_1",
   "ZMod.instField.proof_9",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "DivInvMonoid.div'",
   "ZMod.instField.proof_5",
   "ZMod",
   "ZMod.instField.proof_12",
   "Semiring.toOne",
   "instHMul",
   "ZMod.instField.proof_14",
   "ZMod.instField.proof_10",
   "ZMod.instField.proof_11",
   "ZMod.instField.proof_2",
   "HMul.hMul",
   "CommRing.toRing",
   "ZMod.instField.proof_3",
   "ZMod.instField.proof_7",
   "NNRat.cast",
   "Fact",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "ZMod.commRing"],
  "name": "ZMod.instField",
  "constType": "(p : ℕ) → [inst : Fact (Nat.Prime p)] → Field (ZMod p)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.instMembership",
   "Multiset.instMembership"],
  "name": "Finset.mem_val",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, a ∈ s.val ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "List.instMembership",
   "Multiset.count",
   "List.isSetoid",
   "Mathlib.Data.Multiset.Basic._auxLemma.5",
   "Multiset.Nodup",
   "Multiset.coe_count",
   "implies_congr",
   "instBEqOfDecidableEq",
   "Multiset.instMembership",
   "Eq",
   "Setoid.r",
   "Eq.mpr",
   "List.Nodup",
   "Iff",
   "DecidableEq",
   "forall_congr",
   "List",
   "List.nodup_iff_count_eq_one",
   "Mathlib.Data.Multiset.Nodup._auxLemma.1",
   "Multiset",
   "congr",
   "instOfNatNat",
   "Multiset.ofList",
   "Quot.induction_on",
   "Nat",
   "congrArg",
   "List.count",
   "id",
   "Quot.mk"],
  "name": "Multiset.nodup_iff_count_eq_one",
  "constType":
  "∀ {α : Type u_1} {s : Multiset α} [inst : DecidableEq α], s.Nodup ↔ ∀ a ∈ s, Multiset.count a s = 1",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Nat.add_assoc",
   "Nat.add_comm",
   "OfNat.ofNat",
   "Int.cast_add.match_1",
   "AddGroupWithOne.toSub",
   "SubNegMonoid.toNeg",
   "AddGroupWithOne.toIntCast",
   "HAdd.hAdd",
   "eq_neg_add_iff_add_eq",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "sub_eq_iff_eq_add",
   "sub_eq_add_neg",
   "AddMonoid.toAddZeroClass",
   "AddGroupWithOne.toAddGroup",
   "Int.instAdd",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "AddGroupWithOne",
   "instOfNatNat",
   "Int.cast_negSucc",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "instHSub",
   "add_assoc",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.cast_natCast",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Nat.cast_add",
   "instNatCastInt",
   "of_eq_true",
   "Nat.add_right_comm",
   "SubtractionMonoid.toSubNegMonoid",
   "propext",
   "Int.cast",
   "Int.negSucc",
   "letFun",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "NegZeroClass.toNeg",
   "congrArg",
   "Int",
   "neg_add_rev",
   "Int.subNatNat",
   "Int.cast_subNatNat"],
  "name": "Int.cast_add",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℤ), ↑(m + n) = ↑m + ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "Dvd.intro",
   "rfl",
   "Semigroup"],
  "name": "dvd_mul_right",
  "constType": "∀ {α : Type u_1} [inst : Semigroup α] (a b : α), a ∣ a * b",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "CanonicallyOrderedCommSemiring.toOne",
   "Exists.casesOn",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "algebraRat",
   "ClassGroup",
   "Eq",
   "Fintype",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "And.casesOn",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "instHSub",
   "Ne",
   "exists_solution'",
   "instOfNatPNatOfNeZeroNat",
   "OrderedSemiring.zeroLEOneClass",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NumberField.to_charZero",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Nat.instOrderedSemiring",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "CommRing.toCommMonoid",
   "And",
   "Nat.zero",
   "NumberField.RingOfIntegers.instIsDomain",
   "Nat.le_induction",
   "one_le_m",
   "Field.toEuclideanDomain",
   "NumberField",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Fact",
   "Field.toDivisionRing",
   "Exists",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "Nat.instStrictOrderedSemiring",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "PNat.Prime",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "semigroupDvd",
   "Zero.toOfNat0",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instLENat",
   "instHPow",
   "Ring.toSub",
   "Monoid.toNatPow",
   "zero_lt_one",
   "instOfNatNat",
   "NeZero.succ",
   "NonUnitalNonAssocRing.toMul",
   "False",
   "instAddNat",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "Fintype.card",
   "Dvd.dvd",
   "One.toOfNat1",
   "LT.lt.not_le",
   "LE.le",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "Units.val",
   "Nat.instCanonicallyOrderedCommSemiring",
   "HMul.hMul",
   "Nat.Coprime",
   "NonUnitalSemiring.toSemigroupWithZero",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "FltRegular.not_exists_solution",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [hpri : Fact p.Prime] [inst : Field K] [inst_1 : NumberField K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K],\n  p ≠ 2 →\n    ∀ [inst_3 : Fintype (ClassGroup (NumberField.RingOfIntegers K))],\n      (↑p).Coprime (Fintype.card (ClassGroup (NumberField.RingOfIntegers K))) →\n        ∀ {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p) {m : ℕ},\n          1 ≤ m →\n            ¬∃ x' y' z' ε₃,\n                ¬↑hζ.unit' - 1 ∣ y' ∧ ¬↑hζ.unit' - 1 ∣ z' ∧ x' ^ ↑p + y' ^ ↑p = ↑ε₃ * ((↑hζ.unit' - 1) ^ m * z') ^ ↑p",
  "constCategory": "Theorem"},
 {"references": ["HSMul", "HSMul.mk", "SMul", "SMul.smul"],
  "name": "instHSMul",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : SMul α β] → HSMul α β β",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_31",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_1"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_32._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Zero", "One", "LE"],
  "name": "ZeroLEOneClass",
  "constType":
  "(α : Type u_2) → [inst : Zero α] → [inst : One α] → [inst : LE α] → Prop",
  "constCategory": "Other"},
 {"references": ["Subtype"],
  "name": "Subtype.mk",
  "constType": "{α : Sort u} → {p : α → Prop} → (val : α) → p val → Subtype p",
  "constCategory": "Other"},
 {"references":
  ["Units",
   "Units.instOne",
   "OfNat.ofNat",
   "NormalizationMonoid",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "MonoidWithZero.toMonoid",
   "NormalizationMonoid.mk",
   "normalizationMonoidOfUniqueUnits.proof_2",
   "One.toOfNat1",
   "normalizationMonoidOfUniqueUnits.proof_3",
   "CancelCommMonoidWithZero",
   "normalizationMonoidOfUniqueUnits.proof_1",
   "CommMonoidWithZero.toMonoidWithZero",
   "Unique"],
  "name": "normalizationMonoidOfUniqueUnits",
  "constType":
  "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → [inst_1 : Unique αˣ] → NormalizationMonoid α",
  "constCategory": "Definition"},
 {"references": ["NegZeroClass", "Neg"],
  "name": "NegZeroClass.toNeg",
  "constType": "{G : Type u_2} → [self : NegZeroClass G] → Neg G",
  "constCategory": "Definition"},
 {"references":
  ["ReaderT.instApplicativeOfMonad",
   "Monad",
   "ReaderT",
   "ReaderT.bind",
   "Monad.mk",
   "Bind.mk"],
  "name": "ReaderT.instMonad",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → Monad (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "PartENat.instLE",
   "Monoid.toSemigroup",
   "Monoid",
   "PartENat",
   "Dvd.dvd",
   "semigroupDvd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "LE.le",
   "Iff.intro",
   "Iff",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "instHPow",
   "PartENat.instAddCommMonoidWithOne",
   "multiplicity.pow_dvd_of_le_multiplicity",
   "Monoid.toNatPow",
   "multiplicity.le_multiplicity_of_pow_dvd",
   "multiplicity",
   "Nat",
   "DecidableRel"],
  "name": "multiplicity.pow_dvd_iff_le_multiplicity",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] [inst_1 : DecidableRel fun x x_1 => x ∣ x_1] {a b : α} {k : ℕ},\n  a ^ k ∣ b ↔ ↑k ≤ multiplicity a b",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "DivisionSemiring",
   "Semifield.toCommSemiring",
   "Semifield.mul_inv_cancel",
   "Semifield",
   "Semifield.toInv",
   "Semifield.zpow",
   "Semifield.zpow_neg'",
   "Semifield.nnqsmul",
   "Semifield.nnqsmul_def",
   "Semifield.toNNRatCast",
   "Semifield.zpow_zero'",
   "DivisionSemiring.mk",
   "Semifield.toNontrivial",
   "Semifield.zpow_succ'",
   "Semifield.div_eq_mul_inv",
   "Semifield.nnratCast_def",
   "Semifield.toDiv",
   "Semifield.inv_zero"],
  "name": "Semifield.toDivisionSemiring",
  "constType": "{α : Type u_4} → [self : Semifield α] → DivisionSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableFalse",
   "False",
   "instDecidableNot",
   "Bool.true",
   "of_decide_eq_true",
   "Eq.refl",
   "Not",
   "Bool",
   "instDecidableIff",
   "instDecidableTrue",
   "instDecidableEqOfIff",
   "True",
   "Eq"],
  "name": "not_true_eq_false",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "Membership.mem",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "Finset.dvd_gcd_iff",
   "MonoidWithZero.toSemigroupWithZero",
   "Finset",
   "Dvd.dvd",
   "semigroupDvd",
   "NormalizedGCDMonoid",
   "dvd_rfl",
   "Finset.gcd",
   "CancelCommMonoidWithZero",
   "CommMonoidWithZero.toMonoidWithZero",
   "Finset.instMembership"],
  "name": "Finset.gcd_dvd",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : CancelCommMonoidWithZero α] [inst_1 : NormalizedGCDMonoid α] {s : Finset β}\n  {f : β → α} {b : β}, b ∈ s → s.gcd f ∣ f b",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "rfl",
   "instLTNat",
   "Subtype.mk",
   "Eq"],
  "name": "PNat.mk_coe",
  "constType": "∀ (n : ℕ) (h : 0 < n), ↑⟨n, h⟩ = n",
  "constCategory": "Theorem"},
 {"references": ["DivisionMonoid", "DivInvMonoid"],
  "name": "DivisionMonoid.toDivInvMonoid",
  "constType": "{G : Type u} → [self : DivisionMonoid G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulZeroClass.zero_mul",
   "NonUnitalNonAssocSemiring.toMul",
   "MulZeroClass.toMul",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.zero_mul",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R] (b : R), 0 * b = 0",
  "constCategory": "Theorem"},
 {"references": ["ite_eq_left_iff", "propext", "Decidable", "Not", "ite", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.15",
  "constType":
  "∀ {α : Sort u_1} {a b : α} {P : Prop} [inst : Decidable P], ((if P then a else b) = a) = (¬P → b = a)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "Membership.mem",
   "OfNat.ofNat",
   "Subtype.ext_iff",
   "Subtype.val",
   "Set",
   "Set.instMembership",
   "SetLike.instMembership",
   "Eq",
   "ZeroMemClass",
   "Iff.symm",
   "Zero.toOfNat0",
   "SetLike",
   "Iff",
   "ZeroMemClass.zero",
   "Subtype",
   "SetLike.coe"],
  "name": "ZeroMemClass.coe_eq_zero",
  "constType":
  "∀ {A : Type u_4} {M₁ : Type u_5} [inst : SetLike A M₁] [inst_1 : Zero M₁] [hA : ZeroMemClass A M₁] {S' : A} {x : ↥S'},\n  ↑x = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero",
   "Zero.toOfNat0",
   "Polynomial.ofFinsupp",
   "Polynomial",
   "OfNat.ofNat",
   "AddMonoidAlgebra.semiring",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "Zero.mk",
   "Nat.instAddMonoid",
   "MonoidWithZero.toZero",
   "Nat",
   "AddMonoidAlgebra"],
  "name": "Polynomial.zero",
  "constType": "{R : Type u} → [inst : Semiring R] → Zero (Polynomial R)",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Units.instInv",
   "DivInvMonoid.Pow",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "algebraRat",
   "Semiring.toNatCast",
   "SubNegMonoid.toSub",
   "Nat.Prime",
   "mul_assoc",
   "Nat.cast",
   "Set.Elem",
   "IsPrimitiveRoot.unit'",
   "Field",
   "map_mul",
   "MonoidHom.id",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "AlgEquiv.instEquivLike",
   "HPow.hPow",
   "instHSub",
   "instOfNatPNatOfNeZeroNat",
   "MulOneClass.toOne",
   "Units.instMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MonoidHom",
   "NumberField.to_charZero",
   "AlgEquiv.instFunLike",
   "CommRing.toCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toDivisionRing",
   "Int",
   "Finite.of_fintype",
   "Submodule.setLike",
   "Inv.inv",
   "Exists",
   "AlgEquiv",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "IsCyclotomicExtension.numberField",
   "Set",
   "Semiring.toMonoidWithZero",
   "AlgEquivClass.toAlgHomClass",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "algebraInt",
   "Monoid.toNatPow",
   "Semiring.toModule",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "NonUnitalAlgSemiHomClass.toMulHomClass",
   "Units.val_one",
   "Field.toSemifield",
   "One.toOfNat1",
   "Neg.neg",
   "DivInvMonoid.toMonoid",
   "AlgHom",
   "Monoid.toMulOneClass",
   "IsCyclotomicExtension",
   "Units",
   "CommRing.toCommSemiring",
   "Fact.mk",
   "letFun",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "PNat",
   "Module.toDistribMulAction",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "Ideal.span",
   "Units.val_mul",
   "Exists.casesOn",
   "SetLike.instMembership",
   "Eq",
   "FltRegular.CaseI.exists_int_sum_eq_zero'_aux",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Nat",
   "FltRegular.CaseI.coe_unitGalConj",
   "Ne",
   "Units.instMul",
   "Units.instOne",
   "Set.fintypeSingleton",
   "EuclideanDomain.toCommRing",
   "DivInvMonoid.toInv",
   "NonUnitalNonAssocSemiring.toDistrib",
   "unitGalConj",
   "SemigroupWithZero.toSemigroup",
   "AlgHom.instNonUnitalAlgHomClassOfAlgHomClass",
   "instHMul",
   "Int.cast",
   "Field.toEuclideanDomain",
   "CommRing.toRing",
   "Singleton.singleton",
   "unit_inv_conj_is_root_of_unity",
   "MonoidHom.instFunLike",
   "Fact",
   "congrArg",
   "Ideal",
   "Units.instDivInvMonoid",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "NumberField.RingOfIntegers.instCommRing",
   "inv_mul_self",
   "AlgHomClass.toAlgHom",
   "intGal",
   "AlgEquiv.instAlgEquivClass",
   "PNat.val",
   "FltRegular.CaseI.pow_sub_intGalConj_mem",
   "Rat.commRing",
   "Set.instSingletonSet",
   "one_mul",
   "AlgHom.algHomClass",
   "instHPow",
   "Ring.toSub",
   "instOfNatNat",
   "Int.instNegInt",
   "AddCommGroup.toAddGroup",
   "Units.instMulOneClass",
   "DFunLike.coe",
   "Eq.symm",
   "Rat.numberField",
   "id",
   "Membership.mem",
   "NeZero.succ",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Rat.instField",
   "Algebra.toModule",
   "instHAdd",
   "Rat.commSemiring",
   "Rat",
   "HSub.hSub",
   "AddGroup.toSubNegMonoid",
   "Ideal.mul_mem_left",
   "DivisionSemiring.toSemiring",
   "mul_sub",
   "CharZero",
   "Units.val",
   "AlgHom.funLike",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "galConj",
   "Group.toDivInvMonoid",
   "Units.instGroup",
   "NumberField.RingOfIntegers",
   "Int.instCommSemiring"],
  "name": "FltRegular.CaseI.exists_int_sum_eq_zero'",
  "constType":
  "∀ {p : ℕ+} {K : Type u_1} [inst : Field K] [inst_1 : CharZero K] [inst_2 : IsCyclotomicExtension {p} ℚ K] {ζ : K}\n  (hζ : IsPrimitiveRoot ζ ↑p),\n  p ≠ 2 →\n    Nat.Prime ↑p →\n      ∀ (x y i : ℤ) {u : (NumberField.RingOfIntegers K)ˣ} {α : NumberField.RingOfIntegers K},\n        ↑x + ↑y * ↑(hζ.unit' ^ i) = ↑u * α ^ ↑p →\n          ∃ k, ↑x + ↑y * ↑(hζ.unit' ^ i) - ↑((hζ.unit' ^ k) ^ 2) * (↑x + ↑y * ↑(hζ.unit' ^ (-i))) ∈ Ideal.span {↑↑p}",
  "constCategory": "Theorem"},
 {"references":
  ["SModEq.def",
   "Submodule",
   "propext",
   "Submodule.Quotient.mk",
   "Submodule.hasQuotient",
   "Ring",
   "AddCommGroup.toAddCommMonoid",
   "HasQuotient.Quotient",
   "Module",
   "AddCommGroup",
   "Eq.symm",
   "Ring.toSemiring",
   "SModEq",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.10",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] {M : Type u_3} [inst_1 : AddCommGroup M] [inst_2 : Module R M] {U : Submodule R M}\n  {x y : M}, (Submodule.Quotient.mk x = Submodule.Quotient.mk y) = (x ≡ y [SMOD U])",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_24._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Field.zpow_succ'",
   "Field.zpow_zero'",
   "Field.nnqsmul",
   "CommSemiring.mk",
   "Field.toSemifield.proof_1",
   "Field.toNontrivial",
   "Field.toInv",
   "Field.zpow",
   "Field.zpow_neg'",
   "Field.nnqsmul_def",
   "Field.toNNRatCast",
   "Ring.toSemiring",
   "Semifield",
   "Field.toCommRing",
   "Field.mul_inv_cancel",
   "Field",
   "CommRing.toRing",
   "Field.inv_zero",
   "Semifield.mk",
   "Field.toDiv",
   "Field.nnratCast_def",
   "Field.div_eq_mul_inv"],
  "name": "Field.toSemifield",
  "constType": "{α : Type u_1} → [inst : Field α] → Semifield α",
  "constCategory": "Definition"},
 {"references": ["List.cons", "List", "List.Mem"],
  "name": "List.Mem.tail",
  "constType":
  "∀ {α : Type u} {a : α} (b : α) {as : List α}, List.Mem a as → List.Mem a (b :: as)",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "Semigroup.toMul",
   "PartENat.instLE",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "algebraRat",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "pow_one",
   "Nat.cast",
   "Nat.lt_succ_self",
   "IsPrimitiveRoot.unit'",
   "Field",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "multiplicity.pow_multiplicity_dvd",
   "instHSub",
   "HPow.hPow",
   "instOfNatPNatOfNeZeroNat",
   "MulOneClass.toOne",
   "IsPrimitiveRoot.zeta_sub_one_prime'",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "IsDedekindDomain.toIsDedekindRing",
   "NumberField.to_charZero",
   "multiplicity.is_greatest'",
   "WfDvdMonoid.multiplicity_finite",
   "And",
   "CommRing.toCommMonoid",
   "NumberField.RingOfIntegers.instIsDomain",
   "propext",
   "NumberField",
   "multiplicity",
   "And.intro",
   "Field.toDivisionRing",
   "IsNoetherianRing.wfDvdMonoid",
   "CommMonoidWithZero.toZero",
   "Exists",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Set",
   "PNat.Prime",
   "Semiring.toMonoidWithZero",
   "semigroupDvd",
   "Exists.intro",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddMonoidWithOne.toNatCast",
   "PartENat.natCast_get",
   "Monoid.toNatPow",
   "Nat.succ",
   "Monoid.toSemigroup",
   "NonUnitalNonAssocRing.toMul",
   "IsDomain.toCancelCommMonoidWithZero",
   "Units.val_one",
   "One.toOfNat1",
   "LE.le",
   "PartENat.coe_le_coe",
   "Monoid.toMulOneClass",
   "IsCyclotomicExtension",
   "CommRing.toCommSemiring",
   "Units",
   "Prime.not_unit",
   "Eq.ndrec",
   "letFun",
   "multiplicity.pow_dvd_iff_le_multiplicity",
   "PNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "FltRegular.not_exists_solution",
   "Exists.casesOn",
   "ClassGroup",
   "Eq",
   "Fintype",
   "multiplicity.Finite",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "Part.get",
   "Nat",
   "And.casesOn",
   "Ne",
   "NumberField.RingOfIntegers.instIsDedekindDomain",
   "Units.instOne",
   "Classical.propDecidable",
   "PartENat",
   "EuclideanDomain.toCommRing",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Field.toEuclideanDomain",
   "Eq.mp",
   "CommRing.toRing",
   "Not",
   "Singleton.singleton",
   "pow_succ",
   "Fact",
   "congrArg",
   "CommRing.toNonUnitalCommRing",
   "NumberField.RingOfIntegers.instCommRing",
   "Zero.toOfNat0",
   "PNat.val",
   "Rat.commRing",
   "Set.instSingletonSet",
   "one_mul",
   "instLENat",
   "IsPrimitiveRoot.toInteger",
   "instHPow",
   "PartENat.instAddCommMonoidWithOne",
   "Ring.toSub",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "id",
   "NeZero.succ",
   "False",
   "instAddNat",
   "instHAdd",
   "HSub.hSub",
   "Rat",
   "Dvd.dvd",
   "Fintype.card",
   "IsDedekindRing.toIsNoetherian",
   "Semiring.toOne",
   "Units.val",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Nat.Coprime",
   "HMul.hMul",
   "NumberField.RingOfIntegers",
   "mul_dvd_mul_left"],
  "name": "FltRegular.not_exists_solution'",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [hpri : Fact p.Prime] [inst : Field K] [inst_1 : NumberField K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K],\n  p ≠ 2 →\n    ∀ [inst_3 : Fintype (ClassGroup (NumberField.RingOfIntegers K))],\n      (↑p).Coprime (Fintype.card (ClassGroup (NumberField.RingOfIntegers K))) →\n        ∀ {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p),\n          ¬∃ x y z, ¬↑hζ.unit' - 1 ∣ y ∧ ↑hζ.unit' - 1 ∣ z ∧ z ≠ 0 ∧ x ^ ↑p + y ^ ↑p = z ^ ↑p",
  "constCategory": "Theorem"},
 {"references": ["False", "propext", "Not", "not_true", "True", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.7",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set.mem_singleton_iff",
   "propext",
   "Set",
   "Singleton.singleton",
   "Set.instMembership",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.1",
  "constType": "∀ {α : Type u} {a b : α}, (a ∈ {b}) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["propext", "eq_self_iff_true", "True", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.7",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "mul_assoc",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Monoid.toNatPow",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Nat",
   "congrArg",
   "id"],
  "name": "Mathlib.Tactic.Ring.mul_pf_left",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₃ b c : R} (a₁ : R) (a₂ : ℕ), a₃ * b = c → a₁ ^ a₂ * a₃ * b = a₁ ^ a₂ * c",
  "constCategory": "Theorem"},
 {"references": ["CommGroup", "Group"],
  "name": "CommGroup.toGroup",
  "constType": "{G : Type u} → [self : CommGroup G] → Group G",
  "constCategory": "Definition"},
 {"references": ["False", "Decidable", "if_neg", "ite", "Eq", "id"],
  "name": "if_false",
  "constType":
  "∀ {α : Sort u_1} {x : Decidable False} (t e : α), (if False then t else e) = e",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Submodule.mem_sup",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "Exists",
   "Submodule",
   "Set",
   "HAdd.hAdd",
   "Submodule.completeLattice",
   "Exists.intro",
   "Ideal.span",
   "Exists.casesOn",
   "rfl",
   "Iff.mpr",
   "SetLike.instMembership",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Iff.mp",
   "SemilatticeSup.toSup",
   "Iff",
   "CompleteLattice.toConditionallyCompleteLattice",
   "CommSemiring",
   "Lattice.toSemilatticeSup",
   "And.casesOn",
   "AddCommMonoid.toAddCommSemigroup",
   "Semiring.toModule",
   "id",
   "Membership.mem",
   "instHAdd",
   "ConditionallyCompleteLattice.toLattice",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMagma.toAdd",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Iff.intro",
   "And",
   "instHMul",
   "Ideal.mem_span_singleton'",
   "Eq.ndrec",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "Sup.sup",
   "Singleton.singleton",
   "And.intro",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "Ideal",
   "Submodule.setLike"],
  "name": "Ideal.mem_span_singleton_sup",
  "constType":
  "∀ {S : Type u_1} [inst : CommSemiring S] {x y : S} {I : Ideal S}, x ∈ Ideal.span {y} ⊔ I ↔ ∃ a, ∃ b ∈ I, a * y + b = x",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "ZeroLEOneClass",
   "OfNat.ofNat",
   "NeZero",
   "LE.le.lt_of_ne",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "LT.lt",
   "NeZero.ne'",
   "zero_le_one",
   "One.toOfNat1",
   "Preorder.toLE",
   "PartialOrder"],
  "name": "zero_lt_one",
  "constType":
  "∀ {α : Type u_1} [inst : Zero α] [inst_1 : One α] [inst_2 : PartialOrder α] [inst_3 : ZeroLEOneClass α]\n  [inst_4 : NeZero 1], 0 < 1",
  "constCategory": "Theorem"},
 {"references": ["Monoid", "Pow.mk", "Nat", "Pow", "Monoid.npow"],
  "name": "Monoid.toNatPow",
  "constType": "{M : Type u_2} → [inst : Monoid M] → Pow M ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "DivisionRing.toRing",
   "Rat.commSemiring",
   "NumberField.RingOfIntegers.instCommRing",
   "Rat",
   "Field.toSemifield",
   "intGal",
   "algebraInt",
   "AlgHom",
   "algebraRat",
   "rfl",
   "Eq",
   "NumberField.RingOfIntegers.val",
   "CommRing.toCommSemiring",
   "DivisionSemiring.toSemiring",
   "CharZero",
   "AlgHom.funLike",
   "Field",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "DFunLike.coe",
   "Int.instCommSemiring",
   "Field.toDivisionRing",
   "NumberField.RingOfIntegers",
   "Int"],
  "name": "intGal_apply_coe",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] [inst_1 : CharZero K] (σ : K →ₐ[ℚ] K) (x : NumberField.RingOfIntegers K),\n  ↑((intGal σ) x) = σ ↑x",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.mem_product",
   "Membership.mem",
   "And",
   "Prod.snd",
   "Finset.instSProd",
   "propext",
   "SProd.sprod",
   "Finset",
   "Prod",
   "Prod.fst",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.26",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {t : Finset β} {p : α × β}, (p ∈ s ×ˢ t) = (p.1 ∈ s ∧ p.2 ∈ t)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHomClass.toAddMonoidHomClass",
   "RingHomClass.toMonoidHomClass",
   "NonUnitalRingHomClass.mk",
   "FunLike",
   "MulZeroOneClass.toMulOneClass",
   "MonoidHomClass.toMulHomClass",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "RingHomClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "NonUnitalRingHomClass"],
  "name": "RingHomClass.toNonUnitalRingHomClass",
  "constType":
  "∀ {F : Type u_1} {α : Type u_2} {β : Type u_3} [inst : FunLike F α β] {x : NonAssocSemiring α}\n  {x_1 : NonAssocSemiring β} [inst_1 : RingHomClass F α β], NonUnitalRingHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "eq_true",
   "even_two",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Even",
   "Nat",
   "True",
   "Eq",
   "Semiring.toNatCast",
   "instOfNatAtLeastTwo",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.12",
  "constType": "∀ {α : Type u_2} [inst : Semiring α], Even 2 = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.modEq_zero_iff_dvd",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "Ring.toAddGroupWithOne",
   "Iff.rfl",
   "AddMonoidWithOne.toAddMonoid",
   "Nat.ModEq",
   "Dvd.dvd",
   "Nat.cast_zero",
   "ZMod",
   "Eq",
   "Semiring.toNatCast",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "ZMod.natCast_eq_natCast_iff",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "propext",
   "AddMonoid.toZero",
   "CommRing.toRing",
   "instOfNatNat",
   "Nat.instDvd",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "congrArg",
   "id",
   "ZMod.commRing"],
  "name": "ZMod.natCast_zmod_eq_zero_iff_dvd",
  "constType": "∀ (a b : ℕ), ↑a = 0 ↔ b ∣ a",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_40._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.range",
   "propext",
   "LT.lt",
   "Finset",
   "Nat",
   "instLTNat",
   "Eq",
   "Finset.mem_range",
   "Finset.instMembership"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.154",
  "constType": "∀ {n m : ℕ}, (m ∈ Finset.range n) = (m < n)",
  "constCategory": "Theorem"},
 {"references": ["IsRightCancelAdd", "IsCancelAdd", "Add"],
  "name": "IsCancelAdd.toIsRightCancelAdd",
  "constType":
  "∀ {G : Type u} [inst : Add G] [self : IsCancelAdd G], IsRightCancelAdd G",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_1",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_15"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_16._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LE", "LE.le"],
  "name": "GE.ge",
  "constType": "{α : Type u} → [inst : LE α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_10",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_9"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Add", "AddZeroClass"],
  "name": "AddZeroClass.toAdd",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Add M",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "And",
   "Ne",
   "OfNat.ofNat",
   "Iff",
   "Int.instHPowNat",
   "and_iff_left",
   "Even",
   "Iff.trans",
   "instOfNatNat",
   "Nat",
   "Int.even_pow",
   "Int",
   "Int.instAdd"],
  "name": "Int.even_pow'",
  "constType": "∀ {m : ℤ} {n : ℕ}, n ≠ 0 → (Even (m ^ n) ↔ Even m)",
  "constCategory": "Theorem"},
 {"references":
  ["FermatLastTheoremFor",
   "List.cons",
   "OfNat.ofNat",
   "Int.instSemiring",
   "Nat.instSemiring",
   "Rat",
   "Eq.refl",
   "Rat.semiring",
   "fermatLastTheoremWith_nat_int_rat_tfae",
   "FermatLastTheoremWith",
   "List.TFAE.out",
   "Iff",
   "instOfNatNat",
   "List.nil",
   "Nat",
   "List.get?",
   "Int",
   "Option"],
  "name": "fermatLastTheoremFor_iff_int",
  "constType": "∀ {n : ℕ}, FermatLastTheoremFor n ↔ FermatLastTheoremWith ℤ n",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr",
   "String.toSubstring'",
   "Lean.MacroM",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Lean.Syntax.Preresolved",
   "Lean.addMacroScope",
   "Pure.pure",
   "Lean.Syntax.Preresolved.namespace",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "EStateM.instMonad",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "Lean.Syntax.ident",
   "List.nil",
   "Bind.bind",
   "Nat",
   "Lean.Name.anonymous",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "instMonadExceptOfMonadExceptOf",
   "Lean.Syntax.atom",
   "ReaderT.instMonadExceptOf",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "EStateM.instMonadExceptOfOfBacktrackable",
   "Lean.MacroScope",
   "Lean.MonadRef.mkInfoFromRefPos",
   "ReaderT.instApplicativeOfMonad",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkNum",
   "letFun",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "ReaderT.instMonad",
   "Lean.Name"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Nat.noConfusionType", "Eq.ndrec", "Eq.refl", "Nat", "Nat.casesOn", "Eq"],
  "name": "Nat.noConfusion",
  "constType":
  "{P : Sort u} → {v1 v2 : ℕ} → v1 = v2 → Nat.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["False", "Decidable.isFalse", "Decidable", "not_false"],
  "name": "instDecidableFalse",
  "constType": "Decidable False",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_5",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_10",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "DivisionRing.toRing",
   "CharZero",
   "Field",
   "NumberField",
   "Field.toDivisionRing"],
  "name": "NumberField.to_charZero",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] [self : NumberField K], CharZero K",
  "constCategory": "Theorem"},
 {"references": ["IsDedekindDomain", "IsDedekindRing", "CommRing"],
  "name": "IsDedekindDomain.toIsDedekindRing",
  "constType":
  "∀ {A : Type u_2} [inst : CommRing A] [self : IsDedekindDomain A], IsDedekindRing A",
  "constCategory": "Theorem"},
 {"references": ["NormedRing", "NormedCommRing"],
  "name": "NormedCommRing.toNormedRing",
  "constType": "{α : Type u_5} → [self : NormedCommRing α] → NormedRing α",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_3",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_2"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.withRef",
   "Lean.Syntax.matchesNull",
   "EStateM",
   "cond",
   "OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.Name.mkStr1",
   "Pure.pure",
   "Monad.toBind",
   "Eq",
   "ite",
   "Lean.TSyntax",
   "EStateM.instMonad",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node1",
   "Bool.true",
   "Unit.unit",
   "PUnit",
   "instOfNatNat",
   "List.nil",
   "Bind.bind",
   "Nat",
   "Lean.Name.anonymous",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.PrettyPrinter.instMonadQuotationUnexpandM",
   "Lean.Syntax.isOfKind",
   "List.cons",
   "Lean.Name.mkStr4",
   "Unit",
   "Lean.TSyntax.raw",
   "Lean.TSyntax.mk",
   "Lean.MonadQuotation.toMonadRef",
   "instMonadExceptOfMonadExceptOf",
   "Lean.Syntax.atom",
   "ReaderT.instMonadExceptOf",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "EStateM.instMonadExceptOfOfBacktrackable",
   "Lean.MacroScope",
   "Lean.MonadRef.mkInfoFromRefPos",
   "or",
   "ReaderT.instApplicativeOfMonad",
   "Lean.MonadQuotation.getMainModule",
   "Bool.false",
   "Lean.PrettyPrinter.UnexpandM",
   "letFun",
   "Lean.Name.mkNum",
   "Lean.SyntaxNodeKind",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "ReaderT.instMonad",
   "Lean.Name",
   "Lean.PrettyPrinter.Unexpander"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___unexpand_CyclotomicField_1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references": ["Prod"],
  "name": "Prod.snd",
  "constType": "{α : Type u} → {β : Type v} → α × β → β",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsNat.to_raw_eq.match_1",
   "AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat.rawCast",
   "Nat",
   "Eq"],
  "name": "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
  "constType":
  "∀ {α : Type u} {a : α} {n : ℕ} [inst : AddMonoidWithOne α], Mathlib.Meta.NormNum.IsNat a n → a = n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["Array.mkArray3",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node3",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedSemiring.mk",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "LinearOrderedCommSemiring.toMax",
   "LinearOrderedCommSemiring.toMin",
   "LinearOrderedSemiring",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "LinearOrderedCommSemiring.max_def",
   "LinearOrderedCommSemiring.decidableLT",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring"],
  "name": "LinearOrderedCommSemiring.toLinearOrderedSemiring",
  "constType":
  "{α : Type u_2} → [self : LinearOrderedCommSemiring α] → LinearOrderedSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Set.mem_singleton",
   "IsRegularPrime",
   "algebraRat",
   "AddGroupWithOne.toAddGroup",
   "Nat.Prime",
   "Nat.cast",
   "Iff",
   "IsPrimitiveRoot.unit'",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "instOfNat",
   "Subtype",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "instHSub",
   "instOfNatPNatOfNeZeroNat",
   "safe",
   "NormedCommRing.toNormedRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "CyclotomicField",
   "CommRing.toCommMonoid",
   "And",
   "NumberField.RingOfIntegers.instCharZero_1",
   "NumberField.RingOfIntegers.instIsDomain",
   "propext",
   "LT.lt",
   "congr",
   "And.intro",
   "Field.toDivisionRing",
   "Int",
   "Exists",
   "CommMonoidWithZero.toZero",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "semigroupDvd",
   "Exists.intro",
   "NeZero.pnat",
   "True",
   "CyclotomicField.instField",
   "AddMonoid.toAddSemigroup",
   "Monoid.toNatPow",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NeZero.charZero",
   "Ring.toAddGroupWithOne",
   "FltRegular.not_exists_solution'",
   "One.toOfNat1",
   "NormedField.toNormedCommRing",
   "SubNegZeroMonoid.toNegZeroClass",
   "zeta_sub_one_dvd_Int_iff",
   "IsCyclotomicExtension.exists_prim_root",
   "CommRing.toCommSemiring",
   "instNatCastInt",
   "letFun",
   "FltRegular.CaseII.Statement._auxLemma.1",
   "Rat.instNormedField",
   "Subtype.mk",
   "PNat",
   "CyclotomicField.instCharZero",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "PNat.coe_injective",
   "FltRegular.CaseII.Statement._auxLemma.2",
   "ne_eq",
   "AddGroup.toSubtractionMonoid",
   "Exists.casesOn",
   "instLTNat",
   "Int.instAdd",
   "ClassGroup",
   "Eq",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Nat",
   "And.casesOn",
   "Eq.trans",
   "NormedRing.toRing",
   "CyclotomicField.classGroupFinite",
   "Ne",
   "Nat.Prime.pos",
   "Int.instHPowNat",
   "Int.instDvd",
   "Int.cast_eq_zero",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "of_eq_true",
   "Field.toEuclideanDomain",
   "Int.cast",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Function.Injective.ne_iff",
   "congrArg",
   "Fact",
   "CommRing.toNonUnitalCommRing",
   "AddGroupWithOne.toIntCast",
   "NumberField.RingOfIntegers.instCommRing",
   "Fact.out",
   "PNat.val",
   "Zero.toOfNat0",
   "Rat.commRing",
   "Set.instSingletonSet",
   "instHPow",
   "Ring.toSub",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "id",
   "eq_self",
   "NeZero.succ",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Rat.instField",
   "funext",
   "False",
   "CyclotomicField.isCyclotomicExtension",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Rat",
   "HSub.hSub",
   "Dvd.dvd",
   "Fintype.card",
   "Ring.toSemiring",
   "Rat.instCharZero",
   "Semiring.toOne",
   "Units.val",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Nat.Coprime",
   "NumberField.RingOfIntegers",
   "NegZeroClass.toZero"],
  "name": "FltRegular.not_exists_Int_solution",
  "constType":
  "∀ {p : ℕ} [hpri : Fact (Nat.Prime p)],\n  IsRegularPrime p → p ≠ 2 → ¬∃ x y z, ¬↑p ∣ y ∧ ↑p ∣ z ∧ z ≠ 0 ∧ x ^ p + y ^ p = z ^ p",
  "constCategory": "Theorem"},
 {"references":
  ["MonoidHom.id.proof_1",
   "MulOneClass",
   "MonoidHom.id.proof_2",
   "MulOneClass.toOne",
   "OneHom.mk",
   "MonoidHom",
   "MonoidHom.mk"],
  "name": "MonoidHom.id",
  "constType": "(M : Type u_10) → [inst : MulOneClass M] → M →* M",
  "constCategory": "Definition"},
 {"references":
  ["Finset.univ",
   "Finset.range",
   "Fin.val",
   "Finset.sum",
   "Fin.fintype",
   "Nat",
   "Eq.symm",
   "Fin.sum_univ_eq_sum_range",
   "Fin",
   "Eq",
   "AddCommMonoid"],
  "name": "Finset.sum_range",
  "constType":
  "∀ {β : Type u_2} [inst : AddCommMonoid β] {n : ℕ} (f : ℕ → β), ∑ i ∈ Finset.range n, f i = ∑ i : Fin n, f ↑i",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat.lt.base", "Nat", "Nat.succ", "instLTNat"],
  "name": "Nat.lt_succ_self",
  "constType": "∀ (n : ℕ), n < n.succ",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "RingHom",
   "IsScalarTower.algebraMap_eq",
   "Semiring",
   "algebraMap",
   "RingHom.comp",
   "Eq.refl",
   "IsScalarTower",
   "RingHom.instFunLike",
   "Eq",
   "RingHom.comp_apply",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "DFunLike.coe",
   "Algebra.toSMul",
   "congrArg",
   "id"],
  "name": "IsScalarTower.algebraMap_apply",
  "constType":
  "∀ (R : Type u) (S : Type v) (A : Type w) [inst : CommSemiring R] [inst_1 : CommSemiring S] [inst_2 : Semiring A]\n  [inst_3 : Algebra R S] [inst_4 : Algebra S A] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R S A] (x : R),\n  (algebraMap R A) x = (algebraMap S A) ((algebraMap R S) x)",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat", "UInt8", "Bool.casesOn", "_obj", "Nat.decEq", "Int.neg"],
  "name": "FltRegular.CaseI.f1k₂._cstage2",
  "constType": "_obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocRing", "NonUnitalNonAssocCommRing"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocRing α",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNormedRing", "NonUnitalRing"],
  "name": "NonUnitalNormedRing.toNonUnitalRing",
  "constType":
  "{α : Type u_5} → [self : NonUnitalNormedRing α] → NonUnitalRing α",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Pow.mk", "Pow", "Int", "DivInvMonoid.zpow"],
  "name": "DivInvMonoid.Pow",
  "constType": "{M : Type u_2} → [inst : DivInvMonoid M] → Pow M ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Nat.brecOn",
   "Nat.below",
   "Nat.le",
   "Nat.le.step",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "Nat.le.refl",
   "LE.le",
   "Nat.succ_le_succ.match_1",
   "PProd",
   "Nat.rec",
   "PProd.fst",
   "instLENat",
   "PUnit",
   "instOfNatNat",
   "Nat",
   "Nat.succ"],
  "name": "Nat.succ_le_succ",
  "constType": "∀ {n m : ℕ}, n ≤ m → n.succ ≤ m.succ",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "Finsupp",
   "OfNat.ofNat",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "EmptyCollection.emptyCollection",
   "MvPolynomial",
   "Semiring.toMonoidWithZero",
   "Eq",
   "MvPolynomial.commSemiring",
   "Zero.toOfNat0",
   "Iff",
   "MvPolynomial.support",
   "Finsupp.support_eq_empty",
   "CommSemiring",
   "Finset",
   "LinearOrderedCommMonoidWithZero.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "MonoidWithZero.toZero",
   "Finset.instEmptyCollection"],
  "name": "MvPolynomial.support_eq_empty",
  "constType":
  "∀ {R : Type u} {σ : Type u_1} [inst : CommSemiring R] {p : MvPolynomial σ R}, p.support = ∅ ↔ p = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Fintype",
   "Set.Elem",
   "propext",
   "Set.toFinset",
   "Set",
   "Finset",
   "Set.instMembership",
   "Set.mem_toFinset",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} {s : Set α} [inst : Fintype ↑s] {a : α}, (a ∈ s.toFinset) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Module", "AddCommMonoid"],
  "name": "Module.Finite",
  "constType":
  "(R : Type u_1) → (M : Type u_4) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.num",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Units.val_inv",
   "Units",
   "Monoid",
   "Units.inv_val",
   "Units.val",
   "Units.inv",
   "Units.mk",
   "Inv",
   "Inv.mk"],
  "name": "Units.instInv",
  "constType": "{α : Type u} → [inst : Monoid α] → Inv αˣ",
  "constCategory": "Definition"},
 {"references":
  ["GCDMonoid.gcd",
   "Nat.cast",
   "instNatCastInt",
   "Int.coe_gcd",
   "Eq.symm",
   "Int.instCancelCommMonoidWithZero",
   "Int",
   "Int.instGCDMonoid",
   "Eq",
   "Int.gcd"],
  "name": "FltRegular.CaseII.Statement._auxLemma.9",
  "constType": "∀ (i j : ℤ), gcd i j = ↑(i.gcd j)",
  "constCategory": "Theorem"},
 {"references": ["FermatLastTheoremWith", "Nat.instSemiring", "Nat"],
  "name": "FermatLastTheoremFor",
  "constType": "ℕ → Prop",
  "constCategory": "Definition"},
 {"references": ["Mul", "Semigroup"],
  "name": "Semigroup.toMul",
  "constType": "{G : Type u} → [self : Semigroup G] → Mul G",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "ZMod.commRing.proof_12",
   "Semiring.mk",
   "OfNat.ofNat",
   "ZMod.commRing.proof_17",
   "CommRing.mk",
   "Int.instAdd",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Semiring.npow",
   "Ring.toIntCast",
   "Sub.sub",
   "ZMod.commRing.proof_1",
   "Nat",
   "Int.instSub",
   "Fin.instOfNatOfNeZeroNat",
   "instOfNat",
   "Add.mk",
   "ZMod.commRing.proof_13",
   "Fin.instNatCast",
   "ZMod.commRing.proof_14",
   "ZMod.commRing.proof_2",
   "ZMod.commRing.proof_16",
   "ZMod.commRing.proof_4",
   "ZMod.commRing.proof_18",
   "ZMod.commRing.proof_7",
   "ZMod.commRing.proof_22",
   "ZMod",
   "AddMonoid.mk",
   "Add.add",
   "IntCast.mk",
   "Int.cast",
   "CommRing.toRing",
   "Zero.mk",
   "Ring.mk",
   "ZMod.commRing.proof_15",
   "ZMod.commRing.proof_5",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Int",
   "Fin",
   "Neg.mk",
   "Mul.mk",
   "AddMonoid.nsmul",
   "ZMod.commRing.proof_8",
   "ZMod.commRing.proof_24",
   "ZMod.commRing.proof_3",
   "AddCommMonoid.toAddMonoid",
   "Fin.neg",
   "ZMod.commRing.proof_21",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "CommRing",
   "Sub.mk",
   "ZMod.commRing.proof_25",
   "Int.instNegInt",
   "ZMod.commRing.proof_9",
   "Fin.instSub",
   "ZMod.commRing.proof_6",
   "Nat.succ",
   "Fin.instCommRing",
   "NeZero.succ",
   "ZMod.commRing.proof_23",
   "ZMod.commRing.proof_10",
   "AddSemigroup.mk",
   "ZMod.commRing.proof_11",
   "Int.instMul",
   "One.mk",
   "Neg.neg",
   "Ring.toSemiring",
   "ZMod.commRing.proof_20",
   "Ring.zsmul",
   "Int.instCommRing",
   "instNatCastInt",
   "ZMod.commRing.proof_19",
   "NonUnitalSemiring.mk",
   "inferInstanceAs",
   "Fin.instAdd",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Fin.instMul",
   "Mul.mul",
   "Nat.casesOn"],
  "name": "ZMod.commRing",
  "constType": "(n : ℕ) → CommRing (ZMod n)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Dvd",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references": ["And", "and_assoc", "propext", "Eq"],
  "name": "FltRegular.CaseI.Statement._auxLemma.10",
  "constType": "∀ {a b c : Prop}, ((a ∧ b) ∧ c) = (a ∧ b ∧ c)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "RingHom",
   "CommSemiring.toSemiring",
   "FractionalIdeal.coeIdeal",
   "Exists",
   "MulZeroOneClass.toMulOneClass",
   "algebraMap",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.instFunLike",
   "CommRing",
   "SetLike.instMembership",
   "Eq",
   "And",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "IsLocalization.mem_coeSubmodule",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Algebra",
   "Submonoid",
   "FractionalIdeal",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "DFunLike.coe",
   "Ideal",
   "FractionalIdeal.instSetLike",
   "Semiring.toModule",
   "Submodule.setLike"],
  "name": "FractionalIdeal.mem_coeIdeal",
  "constType":
  "∀ {R : Type u_1} [inst : CommRing R] (S : Submonoid R) {P : Type u_2} [inst_1 : CommRing P] [inst_2 : Algebra R P]\n  {x : P} {I : Ideal R}, x ∈ ↑I ↔ ∃ x' ∈ I, (algebraMap R P) x' = x",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "DecidablePred",
   "And",
   "Iff",
   "Finset",
   "Finset.filter",
   "Finset.val",
   "Multiset.mem_filter",
   "Finset.instMembership"],
  "name": "Finset.mem_filter",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α} {a : α}, a ∈ Finset.filter p s ↔ a ∈ s ∧ p a",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Int.instDvd",
   "Dvd.dvd",
   "ZMod",
   "Eq",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "Nat.cast",
   "instNatCastInt",
   "propext",
   "Int.cast",
   "Ring.toIntCast",
   "ZMod.intCast_zmod_eq_zero_iff_dvd",
   "CommRing.toRing",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "Int",
   "ZMod.commRing"],
  "name": "FltRegular.CaseI.Statement._auxLemma.8",
  "constType": "∀ (a : ℤ) (b : ℕ), (↑b ∣ a) = (↑a = 0)",
  "constCategory": "Theorem"},
 {"references": ["SubNegMonoid", "SubtractionMonoid"],
  "name": "SubtractionMonoid.toSubNegMonoid",
  "constType": "{G : Type u} → [self : SubtractionMonoid G] → SubNegMonoid G",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["HMod.mk", "Mod.mod", "HMod", "Mod"],
  "name": "instHMod",
  "constType": "{α : Type u_1} → [inst : Mod α] → HMod α α α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["ite_eq_right_iff", "propext", "Decidable", "ite", "Eq"],
  "name": "FltRegular.CaseI.AuxLemmas._auxLemma.3",
  "constType":
  "∀ {α : Sort u_1} {a b : α} {P : Prop} [inst : Decidable P], ((if P then a else b) = b) = (P → a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "eq_self",
   "HPow.hPow",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "instHPow",
   "CommSemiring",
   "congr",
   "Monoid.toNatPow",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "add_zero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.single_pow",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a c : R} {b : ℕ}, a ^ b = c → (a + 0) ^ b = c + 0",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "Nat.le",
   "Iff",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "SetCoe.ext_iff",
   "Eq",
   "PNat"],
  "name": "PNat.coe_inj",
  "constType": "∀ {m n : ℕ+}, ↑m = ↑n ↔ m = n",
  "constCategory": "Theorem"},
 {"references": ["Finset.card", "Finset.univ", "Fintype", "Nat"],
  "name": "Fintype.card",
  "constType": "(α : Type u_4) → [inst : Fintype α] → ℕ",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "Neg"],
  "name": "AddGroupWithOne.toNeg",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → Neg R",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_1"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Rat",
  "constType": "Type",
  "constCategory": "Other"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.5",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_6",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_8",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "MulOneClass.one_mul",
   "One.toOfNat1",
   "Eq"],
  "name": "one_mul",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), 1 * a = a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "InvolutiveNeg",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "instHPow",
   "DivInvMonoid",
   "Monoid.toNatPow",
   "instOfNatNat",
   "DivInvMonoid.Pow",
   "Nat",
   "DivInvMonoid.toMonoid",
   "zpow_natCast",
   "instOfNat",
   "Int",
   "Eq"],
  "name": "zpow_ofNat",
  "constType":
  "∀ {G : Type u_1} [inst : DivInvMonoid G] (a : G) (n : ℕ), a ^ OfNat.ofNat n = a ^ OfNat.ofNat n",
  "constCategory": "Theorem"},
 {"references":
  ["Ideal.Quotient.commRing",
   "Ideal.Quotient.algebra",
   "RingHom",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "algebraMap",
   "Ideal.Quotient.mk",
   "Algebra.id",
   "HasQuotient.Quotient",
   "Eq.symm",
   "Ideal.instHasQuotient",
   "Ideal",
   "Ideal.Quotient.algebraMap_eq",
   "CommRing",
   "Eq"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.11",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] (I : Ideal R), Ideal.Quotient.mk I = algebraMap R (R ⧸ I)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "AlgHomClass",
   "AlgHom.mk",
   "MulZeroOneClass.toMulOneClass",
   "Semiring",
   "MulOneClass.toOne",
   "AlgHomClass.toAlgHom.proof_2",
   "RingHomClass.toRingHom",
   "AlgHomClass.toRingHomClass",
   "AlgHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.mk",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "AlgHomClass.toAlgHom.proof_1",
   "AlgHomClass.toAlgHom.proof_3",
   "CommSemiring",
   "Algebra",
   "AlgHomClass.toAlgHom.proof_4",
   "AlgHomClass.commutes",
   "OneHom.mk",
   "MonoidHom.mk",
   "DFunLike.coe"],
  "name": "AlgHomClass.toAlgHom",
  "constType":
  "{R : Type u_1} →\n  {A : Type u_2} →\n    {B : Type u_3} →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A] →\n          [inst_2 : Semiring B] →\n            [inst_3 : Algebra R A] →\n              [inst_4 : Algebra R B] →\n                {F : Type u_5} → [inst_5 : FunLike F A B] → [inst_6 : AlgHomClass F R A B] → F → A →ₐ[R] B",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "propext", "Exists.intro", "forall_exists_index", "Eq"],
  "name": "FltRegular.NumberTheory.Different._auxLemma.4",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (∃ x, p x) → Prop}, (∀ (h : ∃ x, p x), q h) = ∀ (x : α) (h : p x), q ⋯",
  "constCategory": "Theorem"},
 {"references": ["NonAssocSemiring"],
  "name": "RingHom",
  "constType":
  "(α : Type u_5) → (β : Type u_6) → [inst : NonAssocSemiring α] → [inst : NonAssocSemiring β] → Type (max u_5 u_6)",
  "constCategory": "Other"},
 {"references":
  ["Eq.mpr",
   "Nat.cast",
   "instNatCastInt",
   "Eq.refl",
   "Int.gcd_comm",
   "Int.gcd_assoc",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Int",
   "id",
   "Int.gcd",
   "Eq"],
  "name": "FltRegular.Int.gcd_left_comm",
  "constType": "∀ (a b c : ℤ), a.gcd ↑(b.gcd c) = b.gcd ↑(a.gcd c)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Monoid.toMulOneClass",
   "Eq",
   "instHMul",
   "instHPow",
   "Monoid.toNatPow",
   "HMul.hMul",
   "instOfNatNat",
   "pow_succ",
   "Nat",
   "Eq.symm"],
  "name": "FltRegular.CaseII.AuxLemmas._auxLemma.2",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (n : ℕ), a ^ n * a = a ^ (n + 1)",
  "constCategory": "Theorem"},
 {"references":
  ["Ideal.Quotient.commRing",
   "RingHom",
   "CommSemiring.toSemiring",
   "Ideal.Quotient.mk.proof_1",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "Ideal.Quotient.mk.proof_3",
   "Submodule.Quotient.mk",
   "Ideal.Quotient.mk.proof_4",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.mk",
   "CommRing",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "CommRing.toRing",
   "OneHom.mk",
   "Ring.toAddCommGroup",
   "Ideal.Quotient.mk.proof_2",
   "MonoidHom.mk",
   "HasQuotient.Quotient",
   "Ideal",
   "Ideal.instHasQuotient",
   "Semiring.toModule"],
  "name": "Ideal.Quotient.mk",
  "constType":
  "{R : Type u} → [inst : CommRing R] → (I : Ideal R) → R →+* R ⧸ I",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Rat.instField",
   "IsDomain",
   "NumberField.RingOfIntegers.instCommRing",
   "Rat",
   "Fact.out",
   "instLTNat",
   "CyclotomicField",
   "CyclotomicField.instField",
   "CommRing.toCommSemiring",
   "NumberField.RingOfIntegers.instIsDomain",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Fact",
   "NumberField.RingOfIntegers",
   "Subtype.mk"],
  "name": "IsRegularNumber.proof_2",
  "constType":
  "∀ (n : ℕ) [hn : Fact (0 < n)], IsDomain (NumberField.RingOfIntegers (CyclotomicField ⟨n, ⋯⟩ ℚ))",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "Neg.neg",
   "neg_add_cancel_left",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "congrArg",
   "NegZeroClass.toNeg",
   "sub_eq_neg_add",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "add_sub_cancel_left",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommGroup G] (a b : G), a + b - a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Zify.natCast_lt",
   "Nat.cast",
   "instNatCastInt",
   "propext",
   "LT.lt",
   "Nat",
   "Int",
   "instLTNat",
   "Int.instLTInt",
   "Eq"],
  "name": "Mathlib.Tactic.Zify._auxLemma.3",
  "constType": "∀ (a b : ℕ), (a < b) = (↑a < ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_1",
   "_obj",
   "Lean.Name.mkStr4",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_1",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_3",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_2"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "ZeroMemClass",
   "Zero",
   "ZeroMemClass.coe_eq_zero",
   "OfNat.ofNat",
   "SetLike",
   "Subtype.val",
   "propext",
   "Set",
   "Set.instMembership",
   "ZeroMemClass.zero",
   "SetLike.instMembership",
   "Subtype",
   "SetLike.coe",
   "Eq"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.5",
  "constType":
  "∀ {A : Type u_4} {M₁ : Type u_5} [inst : SetLike A M₁] [inst_1 : Zero M₁] [hA : ZeroMemClass A M₁] {S' : A} {x : ↥S'},\n  (↑x = 0) = (x = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Iff.intro",
   "NoZeroDivisors",
   "instHMul",
   "Or",
   "OfNat.ofNat",
   "Iff",
   "mul_eq_zero_of_left",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero",
   "mul_eq_zero_of_right",
   "Or.elim",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "mul_eq_zero",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, a * b = 0 ↔ a = 0 ∨ b = 0",
  "constCategory": "Theorem"},
 {"references": ["Exists", "Iff", "False", "Not", "exists_imp"],
  "name": "not_exists",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) ↔ ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references": ["Not", "Eq"],
  "name": "Ne",
  "constType": "{α : Sort u} → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "AddCommMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "Trans.trans",
   "AddLeftCancelMonoid.toAddMonoid",
   "Iff.rfl",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoid.toAddZeroClass",
   "AddLeftCancelSemigroup.toIsLeftCancelAdd",
   "AddLeftCancelMonoid",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "add_left_cancel_iff",
   "Eq.mpr",
   "Iff",
   "instTransIff_mathlib",
   "add_zero",
   "congrArg",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "id"],
  "name": "add_right_eq_self",
  "constType":
  "∀ {M : Type u} [inst : AddLeftCancelMonoid M] {a b : M}, a + b = a ↔ b = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "instHAdd",
   "Finset.sum",
   "HAdd.hAdd",
   "Finset.instSingleton",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "Finset.fold_singleton",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "Finset",
   "Singleton.singleton",
   "AddCommMagma.to_isCommutative",
   "AddSemigroup.to_isAssociative",
   "add_zero",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "AddCommMonoid"],
  "name": "Finset.sum_singleton",
  "constType":
  "∀ {α : Type u_3} {β : Type u_4} [inst : AddCommMonoid β] (f : α → β) (a : α), ∑ x ∈ {a}, f x = f a",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.isOfKind",
   "Lean.Name.num",
   "Unit",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "EStateM.Result.error",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.SourceInfo",
   "Lean.SourceInfo.fromRef",
   "Bool",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.PrettyPrinter.Unexpander",
   "Lean.Name.str"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___unexpand_CyclotomicField_1._cstage1",
  "constType": "Lean.PrettyPrinter.Unexpander",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Mathlib.Data.Finset.Image._auxLemma.23",
   "Mathlib.Data.Finset.Image._auxLemma.33",
   "True",
   "iff_self",
   "Finset.instMembership",
   "Eq",
   "And",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "Finset.ext",
   "Finset.image",
   "Finset",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "Finset.image_id",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} [inst : DecidableEq α], Finset.image id s = s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "add_assoc",
   "OfNat.ofNat",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "AddZeroClass.toZero",
   "add_right_neg",
   "Eq.mpr",
   "AddGroup",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "Eq.symm",
   "id"],
  "name": "add_neg_cancel_left",
  "constType":
  "∀ {G : Type u_1} [inst : AddGroup G] (a b : G), a + (-a + b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["Finsupp.instAddCommMonoid",
   "Finsupp",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "MvPolynomial",
   "CommSemiring",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "AddMonoidAlgebra.commSemiring",
   "Nat.instAddCommMonoid"],
  "name": "MvPolynomial.commSemiring",
  "constType":
  "{R : Type u} → {σ : Type u_1} → [inst : CommSemiring R] → CommSemiring (MvPolynomial σ R)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "implies_congr",
  "constType":
  "∀ {p₁ p₂ : Sort u} {q₁ q₂ : Sort v}, p₁ = p₂ → q₁ = q₂ → (p₁ → q₁) = (p₂ → q₂)",
  "constCategory": "Theorem"},
 {"references": ["not_or", "And", "Or", "propext", "Not", "Eq"],
  "name": "FltRegular.CaseII.AuxLemmas._auxLemma.4",
  "constType": "∀ {p q : Prop}, (¬(p ∨ q)) = (¬p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termR_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SMulZeroClass.mk",
   "AddGroup",
   "SMulWithZero",
   "Zero.ofOfNat0",
   "AddGroup.toSubtractionMonoid",
   "AddGroup.intSMulWithZero.proof_1",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubNegMonoid.SMulInt",
   "NegZeroClass.toZero",
   "SMulWithZero.mk",
   "AddGroup.toSubNegMonoid",
   "instOfNat",
   "Int",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "AddGroup.intSMulWithZero.proof_2"],
  "name": "AddGroup.intSMulWithZero",
  "constType": "{M : Type u_3} → [inst : AddGroup M] → SMulWithZero ℤ M",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "Lean.Macro.Context",
   "ReaderT",
   "Lean.Macro.State",
   "Lean.Macro.Exception"],
  "name": "Lean.MacroM",
  "constType": "Type → Type",
  "constCategory": "Definition"},
 {"references":
  ["Polynomial",
   "RingHom",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "RingHom.comp",
   "Eq.symm",
   "Polynomial.map_map",
   "Polynomial.map",
   "Eq"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.12",
  "constType":
  "∀ {R : Type u} {S : Type v} {T : Type w} [inst : Semiring R] [inst_1 : Semiring S] (f : R →+* S) [inst_2 : Semiring T]\n  (g : S →+* T) (p : Polynomial R), Polynomial.map (g.comp f) p = Polynomial.map g (Polynomial.map f p)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_42._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_37",
   "List.cons",
   "_obj",
   "_neutral",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_27"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_38._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Nat.gcd", "Nat", "rfl", "Int", "Int.natAbs", "Eq", "Int.gcd"],
  "name": "Int.gcd_eq_natAbs",
  "constType": "∀ {a b : ℤ}, a.gcd b = a.natAbs.gcd b.natAbs",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddZeroClass.toZero",
   "EquivLike",
   "OfNat.ofNat",
   "Iff",
   "map_eq_zero_iff",
   "AddEquivClass.instAddMonoidHomClass",
   "AddMonoidHomClass.toZeroHomClass",
   "AddEquivClass",
   "EquivLike.toFunLike",
   "DFunLike.coe",
   "EquivLike.injective",
   "AddZeroClass",
   "Eq"],
  "name": "AddEquivClass.map_eq_zero_iff",
  "constType":
  "∀ {F : Type u_1} {M : Type u_12} {N : Type u_13} [inst : AddZeroClass M] [inst_1 : AddZeroClass N]\n  [inst_2 : EquivLike F M N] [inst_3 : AddEquivClass F M N] (h : F) {x : M}, h x = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "Ring",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddCommGroup",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "Ring.add_left_neg",
   "AddCommGroup.mk"],
  "name": "Ring.toAddCommGroup",
  "constType": "{R : Type u} → [self : Ring R] → AddCommGroup R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Prod",
  "constType": "Type u → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["outParam", "HMod"],
  "name": "HMod.hMod",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMod α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": ["Bool"],
  "name": "Bool.false",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Int.instLinearOrder",
   "LinearOrder.decidableLE",
   "LinearOrder",
   "Int.mul_pos",
   "LinearOrder.max_def",
   "StrictOrderedRing.mk",
   "LinearOrder.min_def",
   "LinearOrder.le_total",
   "CommRing.mul_comm",
   "Int.instLinearOrderedCommRing.proof_1",
   "CommRing",
   "Int.add_le_add_left",
   "LinearOrder.toOrd",
   "Int.instCommRing",
   "LinearOrderedCommRing.mk",
   "LinearOrder.compare_eq_compareOfLessAndEq",
   "LinearOrder.decidableLT",
   "LinearOrder.toMax",
   "CommRing.toRing",
   "LinearOrder.toMin",
   "LinearOrderedCommRing",
   "LinearOrder.decidableEq",
   "LinearOrder.toPartialOrder",
   "LinearOrderedRing.mk",
   "Int",
   "Int.instNontrivial"],
  "name": "Int.instLinearOrderedCommRing",
  "constType": "LinearOrderedCommRing ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Iff", "Classical.propDecidable", "Not", "Decidable.not_forall"],
  "name": "Classical.not_forall",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) ↔ ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references": ["Monoid"],
  "name": "Units",
  "constType": "(α : Type u) → [inst : Monoid α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Finset.range",
   "LT.lt",
   "Finset",
   "Nat",
   "instLTNat",
   "Finset.instMembership",
   "Multiset.mem_range"],
  "name": "Finset.mem_range",
  "constType": "∀ {n m : ℕ}, m ∈ Finset.range n ↔ m < n",
  "constCategory": "Theorem"},
 {"references": ["Lean.Macro.Exception"],
  "name": "Lean.Macro.Exception.unsupportedSyntax",
  "constType": "Lean.Macro.Exception",
  "constCategory": "Other"},
 {"references": ["And", "and_imp", "Iff", "False", "Not"],
  "name": "not_and",
  "constType": "∀ {a b : Prop}, ¬(a ∧ b) ↔ a → ¬b",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "CommSemiring", "Algebra"],
  "name": "AlgHom",
  "constType":
  "(R : Type u) →\n  (A : Type v) →\n    (B : Type w) →\n      [inst : CommSemiring R] →\n        [inst_1 : Semiring A] → [inst_2 : Semiring B] → [inst_3 : Algebra R A] → [inst : Algebra R B] → Type (max v w)",
  "constCategory": "Other"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.num",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Int.negSucc",
   "Unit",
   "Int.negOfNat.match_1",
   "Nat",
   "instOfNat",
   "Int"],
  "name": "Int.negOfNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Set",
   "Submodule.idemSemiring",
   "Semiring.toMonoidWithZero",
   "Ideal.one_eq_top",
   "Submodule.instTop",
   "Ideal.span",
   "Ideal.span_one",
   "True",
   "Eq",
   "Set.instSingletonSet",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "Nat.recAux",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Ideal.span_singleton_mul_span_singleton",
   "Nat",
   "Eq.trans",
   "Semiring.toModule",
   "eq_self",
   "HPow.hPow",
   "instAddNat",
   "instHAdd",
   "Top.top",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "pow_zero",
   "instHMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "congr",
   "pow_succ",
   "Singleton.singleton",
   "IdemSemiring.toSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.id",
   "congrArg",
   "Ideal"],
  "name": "Ideal.span_singleton_pow",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] (s : R) (n : ℕ), Ideal.span {s} ^ n = Ideal.span {s ^ n}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Associated",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Classical.choose",
   "CommMonoidWithZero.toCommMonoid",
   "Classical.propDecidable",
   "dite",
   "Multiset.instZero",
   "CancelCommMonoidWithZero",
   "Eq",
   "Multiset.instMembership",
   "Zero.toOfNat0",
   "UniqueFactorizationMonoid",
   "And",
   "Prime",
   "MonoidWithZero.toMonoid",
   "Multiset.prod",
   "Multiset",
   "Not",
   "UniqueFactorizationMonoid.exists_prime_factors",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "UniqueFactorizationMonoid.factors",
  "constType":
  "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → [inst : UniqueFactorizationMonoid α] → α → Multiset α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_12"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Nat.succ_mul",
   "Nat.add_assoc",
   "Nat.add_comm",
   "AddSemigroup.mk",
   "AddCancelCommMonoid.mk",
   "AddLeftCancelSemigroup.mk",
   "AddCancelCommMonoid",
   "Nat.add_left_cancel",
   "Nat.zero_add",
   "instHMul",
   "Nat.add",
   "Nat.zero",
   "Nat.zero_mul",
   "Zero.mk",
   "HMul.hMul",
   "AddLeftCancelMonoid.mk",
   "Nat",
   "instMulNat",
   "Nat.add_zero",
   "Add.mk"],
  "name": "Nat.instAddCancelCommMonoid",
  "constType": "AddCancelCommMonoid ℕ",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveNeg",
   "neg_eq_iff_eq_neg",
   "InvolutiveNeg.toNeg",
   "propext",
   "Neg.neg",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.10",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, (-a = b) = (a = -b)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "Set",
   "Ideal.span",
   "semigroupDvd",
   "Ideal.Quotient.eq_zero_iff_dvd",
   "CommRing",
   "Submodule.Quotient.instZeroQuotient",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Set.instSingletonSet",
   "DFunLike.coe",
   "HasQuotient.Quotient",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "Ideal.instHasQuotient",
   "Semiring.toModule",
   "Ideal.Quotient.commRing",
   "Dvd.dvd",
   "RingHom.instFunLike",
   "SemigroupWithZero.toSemigroup",
   "CommRing.toCommSemiring",
   "propext",
   "CommRing.toRing",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Singleton.singleton",
   "Ideal.Quotient.mk",
   "Ring.toAddCommGroup",
   "Ideal"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.7",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] (x y : R), (x ∣ y) = ((Ideal.Quotient.mk (Ideal.span {x})) y = 0)",
  "constCategory": "Theorem"},
 {"references": ["Exists"],
  "name": "Exists.intro",
  "constType": "∀ {α : Sort u} {p : α → Prop} (w : α), p w → Exists p",
  "constCategory": "Other"},
 {"references":
  ["instHSub",
   "Eq.ndrec",
   "Ring.toSub",
   "HSub.hSub",
   "Ring",
   "Eq.refl",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.Ring.sub_congr",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a a' b b' c : R}, a = a' → b = b' → a' - b' = c → a - b = c",
  "constCategory": "Theorem"},
 {"references":
  ["Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid.toOne",
   "CommMonoid",
   "isUnit_iff_dvd_one",
   "One.toOfNat1",
   "Dvd.dvd",
   "IsUnit",
   "semigroupDvd",
   "CommMonoid.toMonoid",
   "Iff.mpr"],
  "name": "isUnit_of_dvd_one",
  "constType":
  "∀ {α : Type u_1} [inst : CommMonoid α] {a : α}, a ∣ 1 → IsUnit a",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "Finset.instInsert",
   "DecidableEq",
   "propext",
   "Finset",
   "Insert.insert",
   "Finset.mem_insert",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.MayAssume.Lemmas._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, (a ∈ insert b s) = (a = b ∨ a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_8",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_4"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["EStateM.Result"],
  "name": "EStateM.Result.ok",
  "constType": "{ε σ α : Type u} → α → σ → EStateM.Result ε σ α",
  "constCategory": "Other"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "Exists",
   "OfNat.ofNat",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Finset.mem_def",
   "Exists.intro",
   "Exists.casesOn",
   "Multiset.gcd",
   "Finset.gcd",
   "CancelCommMonoidWithZero",
   "True",
   "Finset.instMembership",
   "Eq",
   "Multiset.instMembership",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Iff.mp",
   "Iff",
   "Finset.gcd_def",
   "Finset",
   "Multiset",
   "Multiset.mem_map",
   "Finset.val",
   "And.casesOn",
   "Eq.trans",
   "id",
   "eq_self",
   "Membership.mem",
   "NormalizedGCDMonoid",
   "Multiset.map",
   "Iff.intro",
   "And",
   "eq_true",
   "Eq.ndrec",
   "of_eq_true",
   "propext",
   "Eq.mp",
   "congr",
   "congrArg",
   "Mathlib.Algebra.GCDMonoid.Finset._auxLemma.1",
   "and_self",
   "Multiset.gcd_eq_zero_iff"],
  "name": "Finset.gcd_eq_zero_iff",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : CancelCommMonoidWithZero α] [inst_1 : NormalizedGCDMonoid α] {s : Finset β}\n  {f : β → α}, s.gcd f = 0 ↔ ∀ x ∈ s, f x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["LocallyFiniteOrder.finsetIoo", "Finset", "LocallyFiniteOrder", "Preorder"],
  "name": "Finset.Ioo",
  "constType":
  "{α : Type u_1} → [inst : Preorder α] → [inst : LocallyFiniteOrder α] → α → α → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ne",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "nonZeroDivisors.ne_zero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "SetLike.instMembership",
   "nonZeroDivisors",
   "NoZeroDivisors",
   "Iff.intro",
   "Zero.toOfNat0",
   "mem_nonZeroDivisors_of_ne_zero",
   "MonoidWithZero.toMulZeroOneClass",
   "Iff",
   "Submonoid",
   "Nontrivial",
   "MonoidWithZero.toZero",
   "Submonoid.instSetLike",
   "MonoidWithZero"],
  "name": "mem_nonZeroDivisors_iff_ne_zero",
  "constType":
  "∀ {M : Type u_2} [inst : MonoidWithZero M] [inst_1 : NoZeroDivisors M] [inst_2 : Nontrivial M] {x : M},\n  x ∈ nonZeroDivisors M ↔ x ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["AlgHom.End.proof_5",
   "Monoid.mk",
   "Monoid",
   "AlgHom.id",
   "Semiring",
   "One.mk",
   "npowRec",
   "AlgHom.End.proof_4",
   "AlgHom",
   "AlgHom.End.proof_3",
   "CommSemiring",
   "AlgHom.End.proof_1",
   "Algebra",
   "AlgHom.End.proof_2",
   "Semigroup.mk",
   "Mul.mk",
   "AlgHom.comp"],
  "name": "AlgHom.End",
  "constType":
  "{R : Type u} →\n  {A : Type v} → [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → Monoid (A →ₐ[R] A)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "NonAssocSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["CommGroupWithZero", "CommMonoidWithZero"],
  "name": "CommGroupWithZero.toCommMonoidWithZero",
  "constType":
  "{G₀ : Type u_4} → [self : CommGroupWithZero G₀] → CommMonoidWithZero G₀",
  "constCategory": "Definition"},
 {"references":
  ["Module.zero_smul",
   "DistribMulAction.toMulAction",
   "inferInstance",
   "Module.toDistribMulAction",
   "MonoidWithZero.toMonoid",
   "MulActionWithZero.mk",
   "Semiring",
   "AddMonoid.toZero",
   "Semiring.toMonoidWithZero",
   "MulActionWithZero",
   "AddCommMonoid.toAddMonoid",
   "Module",
   "MulAction",
   "Module.toMulActionWithZero.proof_1",
   "AddCommMonoid"],
  "name": "Module.toMulActionWithZero",
  "constType":
  "{R : Type u_2} →\n  {M : Type u_5} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → MulActionWithZero R M",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance", "Int.instCommRing", "Ring", "CommRing.toRing", "Int"],
  "name": "Int.instRing",
  "constType": "Ring ℤ",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "Unit",
   "HAdd.hAdd",
   "rfl",
   "ZMod.val_zero.match_1",
   "ZMod",
   "Eq",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "ZMod.val",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "ZMod.commRing"],
  "name": "ZMod.val_zero",
  "constType": "∀ {n : ℕ}, ZMod.val 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Exists",
   "Set.instSingletonSet",
   "Submodule",
   "Semiring",
   "Set",
   "Singleton.singleton",
   "Module",
   "Submodule.span",
   "Submodule.IsPrincipal",
   "Eq",
   "AddCommMonoid"],
  "name": "Submodule.IsPrincipal.mk",
  "constType":
  "∀ {R : Type u_1} {M : Type u_4} [inst : Semiring R] [inst_1 : AddCommMonoid M] [inst_2 : Module R M]\n  {S : Submodule R M}, (∃ a, S = Submodule.span R {a}) → S.IsPrincipal",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_36",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_38",
   "Lean.Syntax.Preresolved.decl"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_39._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_6",
   "_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_12",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termR_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "eq_true",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "Preorder.toLT",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "MonoidWithZero.toZero",
   "add_zero",
   "congrArg",
   "Eq.trans",
   "OrderedSemiring.toPartialOrder"],
  "name": "Linarith.lt_of_lt_of_eq",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] {a b : α}, a < 0 → b = 0 → a + b < 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "True",
   "pow_add",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Monoid.toNatPow",
   "HMul.hMul",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.pow_add",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a c₁ c₂ : R} {b₁ b₂ : ℕ} {d : R},\n  a ^ b₁ = c₁ → a ^ b₂ = c₂ → c₁ * c₂ = d → a ^ (b₁ + b₂) = d",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.ParserDescr.node",
   "Lean.Name.mkNum",
   "instOfNatNat",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termR._@.FltRegular.CaseI.Statement._hyg.727",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["outParam", "HDiv"],
  "name": "HDiv.hDiv",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HDiv α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Field",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "IsUnit.dvd",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "Eq.refl",
   "Exists.intro",
   "semigroupDvd",
   "rfl",
   "CommMonoid.toCommSemigroup",
   "Eq",
   "mul_comm",
   "Eq.mpr",
   "Iff",
   "CommMonoid.toMonoid",
   "Eq.symm",
   "isUnit_iff_dvd_one.match_1",
   "Units.mk",
   "id",
   "Monoid.toSemigroup",
   "One.toOfNat1",
   "Dvd.dvd",
   "CommMagma.toMul",
   "Monoid.toMulOneClass",
   "Iff.intro",
   "instHMul",
   "Units",
   "CommMonoid",
   "CommSemigroup.toCommMagma",
   "Units.val",
   "HMul.hMul",
   "IsUnit",
   "congrArg"],
  "name": "isUnit_iff_dvd_one",
  "constType":
  "∀ {α : Type u_1} [inst : CommMonoid α] {x : α}, IsUnit x ↔ x ∣ 1",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toZero", "SMulZeroClass", "DistribSMul", "AddZeroClass"],
  "name": "DistribSMul.toSMulZeroClass",
  "constType":
  "{M : Type u_10} → {A : Type u_11} → [inst : AddZeroClass A] → [self : DistribSMul M A] → SMulZeroClass M A",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_gt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a b₂ c : R} (b₁ : R), a + b₂ = c → a + (b₁ + b₂) = b₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.card",
   "Ne",
   "Finset.Nonempty",
   "OfNat.ofNat",
   "Iff",
   "Finset.card_ne_zero",
   "LT.lt",
   "Finset",
   "Nat.pos_iff_ne_zero",
   "instOfNatNat",
   "Iff.trans",
   "Nat",
   "instLTNat"],
  "name": "Finset.card_pos",
  "constType": "∀ {α : Type u_1} {s : Finset α}, 0 < s.card ↔ s.Nonempty",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "propext",
   "AddMonoid.toZero",
   "AddMonoidWithOne.toAddMonoid",
   "instOfNatNat",
   "Nat",
   "Nat.cast_eq_zero",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.33",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, (↑n = 0) = (n = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Equiv",
   "instENatCanonicallyOrderedCommSemiring",
   "PartENat.instLE",
   "Part.Dom",
   "PartENat.toWithTop",
   "PartialOrder.toPreorder",
   "Classical.propDecidable",
   "PartENat",
   "LE.le",
   "True",
   "Preorder.toLE",
   "iff_self",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "PartENat.withTopEquiv",
   "Iff",
   "of_eq_true",
   "Mathlib.Data.Nat.PartENat._auxLemma.29",
   "ENat",
   "OrderedCommSemiring.toOrderedSemiring",
   "Equiv.instFunLike",
   "DFunLike.coe",
   "Nat",
   "congrArg",
   "Eq.trans",
   "OrderedSemiring.toPartialOrder"],
  "name": "PartENat.withTopEquiv_le",
  "constType":
  "∀ {x y : PartENat}, PartENat.withTopEquiv x ≤ PartENat.withTopEquiv y ↔ x ≤ y",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg.mul_neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "mul_neg",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "CommSemiring.toSemiring",
  "constType": "{R : Type u} → [self : CommSemiring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["Cardinal.toNat",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.instSemiring",
   "OrderedCommSemiring.toOrderedSemiring",
   "OrderedSemiring.toSemiring",
   "Cardinal",
   "Cardinal.mk",
   "Nat",
   "MonoidWithZeroHom",
   "DFunLike.coe",
   "NonAssocSemiring.toMulZeroOneClass",
   "MonoidWithZeroHom.funLike",
   "Cardinal.canonicallyOrderedCommSemiring"],
  "name": "Nat.card",
  "constType": "Type u_3 → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["isUnit_one",
   "MulOneClass.toMul",
   "Or",
   "OfNat.ofNat",
   "Int.instDecidableEq",
   "Monoid.toOne",
   "of_decide_eq_true",
   "Eq.refl",
   "One.toOfNat1",
   "Neg.neg",
   "Int.instMonoid",
   "Exists.intro",
   "Or.casesOn",
   "rfl",
   "Monoid.toMulOneClass",
   "Eq",
   "Iff.intro",
   "instHMul",
   "Units",
   "Iff",
   "Eq.ndrec",
   "Int.isUnit_eq_one_or",
   "Bool.true",
   "Units.val",
   "HMul.hMul",
   "Int.instNegInt",
   "Bool",
   "IsUnit",
   "Eq.symm",
   "Units.mk",
   "Int",
   "instOfNat"],
  "name": "Int.isUnit_iff",
  "constType": "∀ {u : ℤ}, IsUnit u ↔ u = 1 ∨ u = -1",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "NonUnitalRing.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_1",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_9",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_3",
   "SeminormedRing.toPseudoMetricSpace",
   "AddCommMonoid.toAddMonoid",
   "SeminormedCommRing",
   "SeminormedCommRing.toSeminormedRing",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_5",
   "Ring.toNeg",
   "SeminormedRing.toNorm",
   "NonUnitalSeminormedCommRing.mk",
   "Ring.toSub",
   "NonUnitalSeminormedRing.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_8",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_6",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_13",
   "AddCommGroup.mk",
   "SeminormedCommRing.mul_comm",
   "NonUnitalSeminormedCommRing",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_10",
   "AddGroup.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_4",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_7",
   "Ring.zsmul",
   "SeminormedRing.toRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_2",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_11",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing.proof_12"],
  "name": "SeminormedCommRing.toNonUnitalSeminormedCommRing",
  "constType":
  "{α : Type u_1} → [β : SeminormedCommRing α] → NonUnitalSeminormedCommRing α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalSemiring.mul_assoc",
   "SemigroupWithZero.mk",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalSemiring",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "SemigroupWithZero"],
  "name": "NonUnitalSemiring.toSemigroupWithZero",
  "constType":
  "{α : Type u} → [self : NonUnitalSemiring α] → SemigroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Finset.insert_eq_of_mem",
   "Finset.instInsert",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "instAssociativeGcd",
   "Eq.refl",
   "dite",
   "semigroupDvd",
   "NormalizedGCDMonoid.toGCDMonoid",
   "Multiset.normalize_gcd",
   "Insert.insert",
   "Finset.gcd",
   "CancelCommMonoidWithZero",
   "Iff.mpr",
   "Finset.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "GCDMonoid.gcd",
   "MonoidWithZero.toSemigroupWithZero",
   "Finset",
   "Finset.val",
   "Finset.fold_insert",
   "id",
   "CommMonoidWithZero.toMonoidWithZero",
   "Membership.mem",
   "Finset.decidableMem",
   "instCommutativeGcd",
   "Dvd.dvd",
   "NormalizedGCDMonoid",
   "SemigroupWithZero.toSemigroup",
   "gcd_eq_right_iff",
   "Multiset.map",
   "DecidableEq",
   "Finset.gcd_dvd",
   "Not",
   "congrArg"],
  "name": "Finset.gcd_insert",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : CancelCommMonoidWithZero α] [inst_1 : NormalizedGCDMonoid α] {s : Finset β}\n  {f : β → α} [inst_2 : DecidableEq β] {b : β}, (insert b s).gcd f = gcd (f b) (s.gcd f)",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.instLinearOrder.proof_3",
   "LE.mk",
   "Nat.instLinearOrder.proof_1",
   "Nat.le",
   "Nat.instMax",
   "LinearOrder",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Nat.decLt",
   "Nat.lt",
   "LT.mk",
   "Nat.instLinearOrder.proof_2",
   "LE.le",
   "instDecidableEqNat",
   "Preorder.toLE",
   "Nat.lt_iff_le_not_le",
   "Preorder.mk",
   "Nat.le_total",
   "inferInstance",
   "DecidableEq",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.mk",
   "Nat.le_refl",
   "Nat.le_trans",
   "instOrdNat",
   "Nat",
   "Nat.le_antisymm",
   "instMinNat",
   "Nat.decLe",
   "DecidableRel"],
  "name": "Nat.instLinearOrder",
  "constType": "LinearOrder ℕ",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_16",
   "Lean.ParserDescr.node",
   "_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_14"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_17._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Units", "Monoid"],
  "name": "Units.val",
  "constType": "{α : Type u} → [inst : Monoid α] → αˣ → α",
  "constCategory": "Definition"},
 {"references":
  ["Finset.le_iff_subset",
   "Finset.instHasSubset",
   "PartialOrder.toPreorder",
   "Iff.mp",
   "GeneralizedBooleanAlgebra.toGeneralizedCoheytingAlgebra",
   "DecidableEq",
   "sdiff_le",
   "Finset",
   "Finset.instGeneralizedBooleanAlgebra",
   "HasSubset.Subset",
   "SDiff.sdiff",
   "Finset.partialOrder",
   "LE.le",
   "Finset.instSDiff",
   "Preorder.toLE"],
  "name": "Finset.sdiff_subset",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α}, s \\ t ⊆ s",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_21",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_22._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["And",
   "Exists",
   "Iff",
   "And.comm",
   "exists_congr",
   "Iff.trans",
   "exists_eq_left",
   "Eq"],
  "name": "exists_eq_right",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, p a ∧ a = a') ↔ p a'",
  "constCategory": "Theorem"},
 {"references":
  ["instCommGroupRelativeUnits",
   "CommSemiring.toSemiring",
   "RingHom",
   "MulOneClass.toMul",
   "DivisionRing.toRing",
   "MulZeroOneClass.toMulOneClass",
   "LieRing.toAddCommGroup",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "QuotientGroup.lift",
   "RelativeUnits",
   "relativeUnitsMap.proof_3",
   "NonAssocSemiring.toMulZeroOneClass",
   "relativeUnitsMap.proof_2",
   "Units.map",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "RelativeUnits.proof_1",
   "instIsIntegralClosureRingOfIntegers_fltRegular",
   "Field",
   "Algebra",
   "instIsScalarTowerRingOfIntegers_fltRegular",
   "Subgroup",
   "EquivLike.toFunLike",
   "QuotientGroup.Quotient.group",
   "DFunLike.coe",
   "HasQuotient.Quotient",
   "LieRing.ofAssociativeRing",
   "FiniteDimensional",
   "CommGroup.toGroup",
   "QuotientGroup.instHasQuotientSubgroup",
   "Algebra.toModule",
   "algebraMap",
   "MulEquiv.instEquivLike",
   "Field.toSemifield",
   "MonoidHom.comp",
   "MonoidHomClass.toMonoidHom",
   "MonoidHom",
   "MulEquiv",
   "relativeUnitsMap.proof_1",
   "DivInvMonoid.toMonoid",
   "AlgHom",
   "MonoidHom.range",
   "Monoid.toMulOneClass",
   "RingHom.instFunLike",
   "Units",
   "DivisionSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "galRestrictHom",
   "AlgHom.End",
   "QuotientGroup.mk'",
   "AlgHom.funLike",
   "NumberField.inst_ringOfIntegersAlgebra",
   "NumberField",
   "Semifield.toDivisionSemiring",
   "Group.toDivInvMonoid",
   "Algebra.id",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Units.instGroup",
   "NumberField.RingOfIntegers.instIsFractionRing",
   "NumberField.RingOfIntegers.instAlgebra_1",
   "relativeUnitsMap.proof_4"],
  "name": "relativeUnitsMap",
  "constType":
  "{K : Type u_1} →\n  [inst : Field K] →\n    [inst_1 : NumberField K] →\n      {k : Type u_2} →\n        [inst_2 : Field k] →\n          [inst_3 : NumberField k] →\n            [inst_4 : Algebra k K] →\n              [inst_5 : FiniteDimensional k K] → (K →ₐ[k] K) → RelativeUnits k K →* RelativeUnits k K",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "Subtype.ext",
   "Subalgebra",
   "EuclideanDomain.toCommRing",
   "algebraInt",
   "integralClosure",
   "Subalgebra.instSetLike",
   "SetLike.instMembership",
   "Eq",
   "NumberField.RingOfIntegers.val",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "Field.toEuclideanDomain",
   "Field",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Int"],
  "name": "NumberField.RingOfIntegers.ext",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] {x y : NumberField.RingOfIntegers K}, ↑x = ↑y → x = y",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "tsub_le_iff_left",
   "nonpos_iff_eq_zero",
   "Sub",
   "AddMonoid.toAddZeroClass",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Eq.mpr",
   "Iff",
   "OrderedSub",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "id",
   "instHSub",
   "instHAdd",
   "HSub.hSub",
   "AddCommMagma.toAdd",
   "LE.le",
   "propext",
   "CanonicallyOrderedAddCommMonoid",
   "congrArg",
   "add_zero",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "tsub_eq_zero_iff_le",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b : α},\n  a - b = 0 ↔ a ≤ b",
  "constCategory": "Theorem"},
 {"references":
  ["not_lt",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclotomicUnits._auxLemma.3",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, (¬a < b) = (b ≤ a)",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "Ring"],
  "name": "Ring.toSemiring",
  "constType": "{R : Type u} → [self : Ring R] → Semiring R",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Eq",
   "AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "one_add_one_eq_two",
   "AddMonoidWithOne.toOne",
   "AddMonoid.toAddSemigroup",
   "instNatAtLeastTwo",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "instOfNatAtLeastTwo"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.4",
  "constType": "∀ {R : Type u_1} [inst : AddMonoidWithOne R], 2 = 1 + 1",
  "constCategory": "Theorem"},
 {"references": ["List"],
  "name": "List.Mem",
  "constType": "{α : Type u} → α → List α → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_ndunion",
   "Or",
   "Finset.instUnion",
   "Iff",
   "DecidableEq",
   "Union.union",
   "Finset",
   "Finset.val",
   "Finset.instMembership"],
  "name": "Finset.mem_union",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, a ∈ s ∪ t ↔ a ∈ s ∨ a ∈ t",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast",
   "instNatCastInt",
   "propext",
   "Int.cast",
   "Int.ModEq",
   "Ring.toIntCast",
   "CommRing.toRing",
   "Nat",
   "Eq.symm",
   "Int",
   "ZMod.intCast_eq_intCast_iff",
   "ZMod",
   "ZMod.commRing",
   "Eq"],
  "name": "FltRegular.CaseI.Statement._auxLemma.7",
  "constType": "∀ (a b : ℤ) (c : ℕ), (a ≡ b [ZMOD ↑c]) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "Finset.instUnion",
   "DecidableEq",
   "Finset.mem_union",
   "propext",
   "Union.union",
   "Finset",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, (a ∈ s ∪ t) = (a ∈ s ∨ a ∈ t)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedCommMonoid", "OrderedCommMonoid"],
  "name": "LinearOrderedCommMonoid.toOrderedCommMonoid",
  "constType":
  "{α : Type u_3} → [self : LinearOrderedCommMonoid α] → OrderedCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Meta.NormNum.IsInt.mk",
   "Ring",
   "Int.rawCast",
   "Mathlib.Meta.NormNum.IsInt",
   "rfl",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : Ring α] (n : ℤ), Mathlib.Meta.NormNum.IsInt n.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Finset.instSingleton",
   "Singleton.singleton",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.CaseII.Statement._auxLemma.6",
  "constType": "∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Ne",
   "instHDiv",
   "OfNat.ofNat",
   "Int.instMul",
   "Eq.rec",
   "HMul.hMul",
   "Int.instDiv",
   "HDiv.hDiv",
   "Int.mul_ediv_cancel",
   "instOfNat",
   "Int",
   "Int.mul_comm",
   "Eq"],
  "name": "Int.mul_ediv_cancel_left",
  "constType": "∀ {a : ℤ} (b : ℤ), a ≠ 0 → a * b / a = b",
  "constCategory": "Theorem"},
 {"references":
  ["NatCast", "Nat.AtLeastTwo", "Nat.cast", "OfNat", "OfNat.mk", "Nat"],
  "name": "instOfNatAtLeastTwo",
  "constType":
  "{R : Type u_1} → {n : ℕ} → [inst : NatCast R] → [inst : n.AtLeastTwo] → OfNat R n",
  "constCategory": "Definition"},
 {"references": ["Fin.val", "LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.isLt",
  "constType": "∀ {n : ℕ} (self : Fin n), ↑self < n",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_8",
   "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_4",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "Function.minimalPeriod",
   "HMul.hMul",
   "One.toOfNat1",
   "Nat",
   "Monoid.toMulOneClass"],
  "name": "orderOf",
  "constType": "{G : Type u_1} → [inst : Monoid G] → G → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "of_eq_true",
   "Decidable",
   "Eq.refl",
   "Not",
   "congrArg",
   "instDecidableTrue",
   "Eq.trans",
   "ite_congr",
   "True",
   "ite",
   "Eq"],
  "name": "ite_cond_eq_true",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} (a b : α), c = True → (if c then a else b) = a",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "Finsupp.instFunLike",
   "Finsupp",
   "propext",
   "Finset",
   "DFunLike.coe",
   "Finsupp.mem_support_iff",
   "Eq",
   "Finsupp.support",
   "Finset.instMembership"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {f : α →₀ M} {a : α}, (a ∈ f.support) = (f a ≠ 0)",
  "constCategory": "Theorem"},
 {"references": ["Lean.SyntaxNodeKind", "Nat", "Lean.ParserDescr"],
  "name": "Lean.ParserDescr.node",
  "constType": "Lean.SyntaxNodeKind → ℕ → Lean.ParserDescr → Lean.ParserDescr",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "Semiring.mk",
   "Rat.commRing.proof_14",
   "Rat.commRing.proof_10",
   "Monoid.toOne",
   "SubNegMonoid.toNeg",
   "Rat.instIntCast",
   "CommMonoid.mul_comm",
   "Rat.commRing.proof_9",
   "Rat.commRing.proof_1",
   "Rat.commRing.proof_8",
   "NonUnitalNonAssocSemiring.mk",
   "NatCast.mk",
   "CommRing",
   "CommRing.mk",
   "Rat.commRing.proof_13",
   "SubNegMonoid.toSub",
   "AddCommMonoid.mk",
   "Nat.cast",
   "Rat.addCommGroup",
   "Rat.commMonoid",
   "AddCommGroup.toAddGroup",
   "CommMonoid.toMonoid",
   "Nat",
   "Rat.commRing.proof_4",
   "Monoid.toSemigroup",
   "AddCommGroup.add_comm",
   "Rat",
   "Rat.mul_add",
   "Rat.commRing.proof_3",
   "Rat.commRing.proof_6",
   "Rat.commRing.proof_11",
   "AddGroup.toSubNegMonoid",
   "Rat.commRing.proof_2",
   "Rat.commRing.proof_12",
   "Rat.mul_zero",
   "IntCast.mk",
   "Rat.zero_mul",
   "CommMonoid",
   "instNatCastInt",
   "Rat.commRing.proof_5",
   "Int.cast",
   "NonUnitalSemiring.mk",
   "SubNegMonoid.zsmul",
   "SubNegMonoid.toAddMonoid",
   "Rat.commRing.proof_7",
   "Ring.mk",
   "AddCommGroup",
   "Rat.add_mul",
   "Int",
   "Monoid.npow"],
  "name": "Rat.commRing",
  "constType": "CommRing ℚ",
  "constCategory": "Definition"},
 {"references": ["Lean.MonadQuotation", "Lean.MacroScope"],
  "name": "Lean.MonadQuotation.getCurrMacroScope",
  "constType":
  "{m : Type → Type} → [self : Lean.MonadQuotation m] → m Lean.MacroScope",
  "constCategory": "Definition"},
 {"references": ["Lean.SyntaxNodeKinds"],
  "name": "Lean.TSyntax",
  "constType": "Lean.SyntaxNodeKinds → Type",
  "constCategory": "Other"},
 {"references":
  ["Nat.cast",
   "instLENat",
   "instNatCastInt",
   "Int.ofNat_le",
   "Nat",
   "Int",
   "LE.le",
   "Int.instLEInt",
   "Iff.mpr"],
  "name": "Lean.Omega.Int.ofNat_le_of_le",
  "constType": "∀ {x y : ℕ}, x ≤ y → ↑x ≤ ↑y",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Semiring",
   "algebraMap",
   "CommSemiring",
   "Algebra",
   "DFunLike.coe",
   "Eq.symm",
   "Algebra.toSMul",
   "IsScalarTower",
   "RingHom.instFunLike",
   "IsScalarTower.algebraMap_apply",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert94._auxLemma.1",
  "constType":
  "∀ (R : Type u) (S : Type v) (A : Type w) [inst : CommSemiring R] [inst_1 : CommSemiring S] [inst_2 : Semiring A]\n  [inst_3 : Algebra R S] [inst_4 : Algebra S A] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R S A] (x : R),\n  (algebraMap S A) ((algebraMap R S) x) = (algebraMap R A) x",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_2",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_4",
   "Lean.Name.mkStr4",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_1",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_3"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OrderTop.toTop", "Top.top", "OrderTop.le_top", "OrderTop", "LE", "LE.le"],
  "name": "le_top",
  "constType":
  "∀ {α : Type u} [inst : LE α] [inst_1 : OrderTop α] {a : α}, a ≤ ⊤",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Ideal.map",
   "RingHomClass",
   "ZeroHom.mk",
   "Submodule.idemSemiring",
   "Ideal.mapHom.proof_1",
   "MulZeroOneClass.toZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "Ideal.map_mul",
   "IdemSemiring.toSemiring",
   "MonoidWithZeroHom",
   "Algebra.id",
   "Ideal",
   "MonoidWithZeroHom.mk",
   "Ideal.mapHom.proof_2"],
  "name": "Ideal.mapHom",
  "constType":
  "{R : Type u} →\n  {S : Type v} →\n    {F : Type u_1} →\n      [inst : CommRing R] →\n        [inst_1 : CommRing S] → [inst_2 : FunLike F R S] → [rc : RingHomClass F R S] → F → Ideal R →*₀ Ideal S",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Lean.Omega.LinearCombo.eval",
   "OfNat.ofNat",
   "List.cons",
   "Lean.Omega.LinearCombo.coordinate",
   "Lean.Omega.LinearCombo.coordinate_eval",
   "True",
   "Eq",
   "Lean.Omega.Coeffs.ofList",
   "of_eq_true",
   "List",
   "instOfNatNat",
   "Lean.Omega.Coeffs.get",
   "Nat",
   "congrArg",
   "Int",
   "Eq.trans"],
  "name": "Lean.Omega.LinearCombo.coordinate_eval_1",
  "constType":
  "∀ {a0 a1 : ℤ} {t : List ℤ}, (Lean.Omega.LinearCombo.coordinate 1).eval (Lean.Omega.Coeffs.ofList (a0 :: a1 :: t)) = a1",
  "constCategory": "Theorem"},
 {"references": ["Preorder.toLT", "LT.lt", "lt_irrefl", "Not", "Preorder"],
  "name": "Linarith.lt_irrefl",
  "constType": "∀ {α : Type u} [inst : Preorder α] {a : α}, ¬a < a",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedRing", "Ring"],
  "name": "StrictOrderedRing.toRing",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["IsDedekindDomain",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Ideal.cancelCommMonoidWithZero",
   "IsDomain",
   "Submodule.idemSemiring",
   "IsDomain.mk",
   "IsDomain.toNontrivial",
   "IdemSemiring.toSemiring",
   "Algebra.id",
   "CancelMonoidWithZero.toIsCancelMulZero",
   "Ideal",
   "CommRing",
   "IsDedekindDomain.toIsDomain",
   "Ideal.instNontrivial",
   "CancelCommMonoidWithZero.toCancelMonoidWithZero"],
  "name": "Ideal.isDomain",
  "constType":
  "∀ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDedekindDomain A], IsDomain (Ideal A)",
  "constCategory": "Definition"},
 {"references": ["Or", "False", "propext", "or_false_iff", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.6",
  "constType": "∀ (p : Prop), (p ∨ False) = p",
  "constCategory": "Theorem"},
 {"references":
  ["Iff",
   "instHAdd",
   "LT.lt",
   "HAdd.hAdd",
   "rel_iff_cov",
   "CovariantClass",
   "LT",
   "Add",
   "ContravariantClass"],
  "name": "add_lt_add_iff_left",
  "constType":
  "∀ {α : Type u_1} [inst : Add α] [inst_1 : LT α]\n  [inst_2 : CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1]\n  [inst_3 : ContravariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x < x_1] (a : α) {b c : α}, a + b < a + c ↔ b < c",
  "constCategory": "Theorem"},
 {"references": ["and_imp", "And", "propext", "Eq"],
  "name": "FltRegular.NumberTheory.Different._auxLemma.5",
  "constType": "∀ {a b c : Prop}, (a ∧ b → c) = (a → b → c)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HAdd.hAdd",
   "IsCoprime",
   "dite",
   "Int.instAdd",
   "Preorder.toLE",
   "Ideal.instIdemCommSemiring",
   "Finset.instMembership",
   "Eq",
   "Nat.Prime",
   "fltIdeals",
   "Nat.cast",
   "OrderedCommMonoid.toPartialOrder",
   "Nat",
   "HPow.hPow",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "Int.instHPowNat",
   "Int.instDvd",
   "Classical.propDecidable",
   "CyclotomicField",
   "instHMul",
   "IsCoprime.symm",
   "NumberField.RingOfIntegers.instIsDomain",
   "Eq.mp",
   "Init.Classical._auxLemma.2",
   "Not",
   "Fact",
   "congrArg",
   "Int",
   "Ideal",
   "aux_lem_flt",
   "NumberField.RingOfIntegers.instCommRing",
   "CyclotomicField.instField",
   "PNat.val",
   "instDecidableNot",
   "Finset",
   "LinearOrderedCancelCommMonoid.toLinearOrderedCommMonoid",
   "instOfNatNat",
   "fltIdeals_coprime2",
   "Membership.mem",
   "NeZero.succ",
   "Rat.instField",
   "LinearOrderedCommMonoid.toOrderedCommMonoid",
   "instHAdd",
   "Int.instMul",
   "Rat",
   "Dvd.dvd",
   "One.toOfNat1",
   "Ne.symm",
   "LE.le",
   "Polynomial.nthRootsFinset",
   "Semiring.toOne",
   "CommRing.toCommSemiring",
   "instNatCastInt",
   "Fact.mk",
   "instPNatLinearOrderedCancelCommMonoid",
   "letFun",
   "HMul.hMul",
   "Int.instCommSemiring",
   "NumberField.RingOfIntegers",
   "IdemCommSemiring.toCommSemiring",
   "PNat"],
  "name": "fltIdeals_coprime",
  "constType":
  "∀ {p : ℕ+} (hpri : Nat.Prime ↑p),\n  5 ≤ p →\n    ∀ {x y z : ℤ},\n      x ^ ↑p + y ^ ↑p = z ^ ↑p →\n        ∀ {η₁ η₂ : NumberField.RingOfIntegers (CyclotomicField p ℚ)},\n          IsCoprime x y →\n            ∀ (hη₁ : η₁ ∈ Polynomial.nthRootsFinset (↑p) (NumberField.RingOfIntegers (CyclotomicField p ℚ)))\n              (hη₂ : η₂ ∈ Polynomial.nthRootsFinset (↑p) (NumberField.RingOfIntegers (CyclotomicField p ℚ))),\n              η₁ ≠ η₂ →\n                ¬↑↑p ∣ x * y * z →\n                  let_fun this := ⋯;\n                  IsCoprime (fltIdeals p x y hη₁) (fltIdeals p x y hη₂)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "DecidablePred",
   "EmptyCollection.emptyCollection",
   "Finset.filter_eq_empty_iff",
   "propext",
   "Finset",
   "Finset.filter",
   "Not",
   "Finset.instEmptyCollection",
   "Finset.instMembership",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.15",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α},\n  (Finset.filter p s = ∅) = ∀ ⦃x : α⦄, x ∈ s → ¬p x",
  "constCategory": "Theorem"},
 {"references": ["Eq.ndrec", "Eq.refl", "Eq.symm", "Eq"],
  "name": "Mathlib.Tactic.Ring.of_eq",
  "constType": "∀ {R : Type u_1} {a b c : R}, a = c → b = c → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "Decidable.casesOn",
   "Decidable",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.decEq",
   "Int",
   "Int.neg",
   "Eq"],
  "name": "FltRegular.f._cstage1",
  "constType": "ℤ → ℤ → ℕ → ℕ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalNonAssocRing.toMul",
   "mul_neg",
   "Semiring.toMonoidWithZero",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "True",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "MonoidWithZero.toMonoid",
   "InvolutiveNeg.toNeg",
   "instHPow",
   "HasDistribNeg.toInvolutiveNeg",
   "Ring",
   "HMul.hMul",
   "Monoid.toNatPow",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.neg_mul",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] (a₁ : R) (a₂ : ℕ) {a₃ b : R}, -a₃ = b → -(a₁ ^ a₂ * a₃) = a₁ ^ a₂ * b",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "OfNat.ofNat",
   "Nat.AtLeastTwo",
   "AddMonoidWithOne.toNatCast",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "AddGroupWithOne",
   "Nat",
   "instOfNat",
   "Int",
   "AddGroupWithOne.intCast_ofNat",
   "instOfNatAtLeastTwo",
   "Eq",
   "id"],
  "name": "Int.cast_ofNat",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ) [inst_1 : n.AtLeastTwo], ↑(OfNat.ofNat n) = OfNat.ofNat n",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instFunLike.proof_1",
   "OneHom.toFun",
   "RingHom",
   "FunLike",
   "MonoidHom.toOneHom",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "RingHom.toMonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "DFunLike.mk",
   "NonAssocSemiring"],
  "name": "RingHom.instFunLike",
  "constType":
  "{α : Type u_2} → {β : Type u_3} → {x : NonAssocSemiring α} → {x_1 : NonAssocSemiring β} → FunLike (α →+* β) α β",
  "constCategory": "Definition"},
 {"references":
  ["MonoidWithZero.toMonoid",
   "GroupWithZero.zpow_succ'",
   "DivInvMonoid",
   "GroupWithZero.zpow_zero'",
   "GroupWithZero",
   "GroupWithZero.div_eq_mul_inv",
   "DivInvMonoid.mk",
   "GroupWithZero.toMonoidWithZero",
   "GroupWithZero.zpow_neg'",
   "GroupWithZero.zpow",
   "GroupWithZero.toDiv",
   "GroupWithZero.toInv"],
  "name": "GroupWithZero.toDivInvMonoid",
  "constType": "{G₀ : Type u} → [self : GroupWithZero G₀] → DivInvMonoid G₀",
  "constCategory": "Definition"},
 {"references":
  ["LeftCancelMonoid.toMonoid",
   "HPow.hPow",
   "instHMod",
   "instHPow",
   "propext",
   "pow_inj_mod",
   "HMod.hMod",
   "Monoid.toNatPow",
   "orderOf",
   "Nat",
   "LeftCancelMonoid",
   "Nat.instMod",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert90._auxLemma.4",
  "constType":
  "∀ {G : Type u_1} [inst : LeftCancelMonoid G] {x : G} {n m : ℕ}, (x ^ n = x ^ m) = (n % orderOf x = m % orderOf x)",
  "constCategory": "Theorem"},
 {"references": ["StrictOrderedRing", "PartialOrder"],
  "name": "StrictOrderedRing.toPartialOrder",
  "constType": "{α : Type u} → [self : StrictOrderedRing α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["Bind"],
  "name": "Bind.bind",
  "constType":
  "{m : Type u → Type v} → [self : Bind m] → {α β : Type u} → m α → (α → m β) → m β",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Or",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Eq",
   "Zero.toOfNat0",
   "propext",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "add_pos_iff",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.10",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a b : α}, (0 < a + b) = (0 < a ∨ 0 < b)",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_3",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["StrictOrderedRing.toPartialOrder",
   "Semiring.toNonUnitalSemiring",
   "StrictOrderedRing.toRing",
   "OrderedAddCommGroup",
   "AddGroup.mk",
   "AddCommMonoid.toAddMonoid",
   "Ring.toSemiring",
   "OrderedAddCommGroup.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Ring.zsmul",
   "Ring.toNeg",
   "AddCommMonoid.add_comm",
   "StrictOrderedRing",
   "StrictOrderedRing.add_le_add_left",
   "Ring.toSub",
   "Ring.zsmul_succ'",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg",
   "AddCommGroup.mk"],
  "name": "StrictOrderedRing.toOrderedAddCommGroup",
  "constType":
  "{α : Type u} → [self : StrictOrderedRing α] → OrderedAddCommGroup α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Zero", "SMulWithZero", "SMulZeroClass"],
  "name": "SMulWithZero.toSMulZeroClass",
  "constType":
  "{R : Type u_1} → {M : Type u_3} → [inst : Zero R] → [inst_1 : Zero M] → [self : SMulWithZero R M] → SMulZeroClass R M",
  "constCategory": "Definition"},
 {"references":
  ["MulHomClass",
   "NonUnitalNonAssocSemiring",
   "outParam",
   "FunLike",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalRingHomClass"],
  "name": "NonUnitalRingHomClass.toMulHomClass",
  "constType":
  "∀ {F : Type u_5} {α : outParam (Type u_6)} {β : outParam (Type u_7)} [inst : NonUnitalNonAssocSemiring α]\n  [inst_1 : NonUnitalNonAssocSemiring β] [inst_2 : FunLike F α β] [self : NonUnitalRingHomClass F α β],\n  MulHomClass F α β",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "instHMul",
   "And.right",
   "Iff.mp",
   "Int.instSemiring",
   "Int.instMul",
   "HMul.hMul",
   "Odd",
   "Int.odd_mul",
   "Int"],
  "name": "Int.Odd.of_mul_right",
  "constType": "∀ {m n : ℤ}, Odd (m * n) → Odd n",
  "constCategory": "Theorem"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "dite",
  "constType":
  "{α : Sort u} → (c : Prop) → [h : Decidable c] → (c → α) → (¬c → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Finset.Basic._auxLemma.74",
   "Or",
   "Finset.instHasSubset",
   "Finset.instInsert",
   "Mathlib.Data.Finset.Basic._auxLemma.45",
   "Mathlib.Data.Finset.Basic._auxLemma.64",
   "Mathlib.Data.Finset.Basic._auxLemma.46",
   "Eq.refl",
   "HasSubset.Subset",
   "Insert.insert",
   "implies_congr",
   "True",
   "iff_self",
   "Finset.instMembership",
   "Eq",
   "And",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "congr",
   "Mathlib.Data.Finset.Basic._auxLemma.47",
   "congrArg",
   "Eq.trans"],
  "name": "Finset.insert_subset_iff",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, insert a s ⊆ t ↔ a ∈ t ∧ s ⊆ t",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_toFinset",
   "DecidableEq",
   "propext",
   "Finset",
   "Multiset",
   "Multiset.toFinset",
   "Eq",
   "Multiset.instMembership",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.4",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, (a ∈ s.toFinset) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "MvPolynomial.IsWeightedHomogeneous",
   "Pi.instOne",
   "MvPolynomial",
   "CommSemiring",
   "Nat.instCanonicallyOrderedCommSemiring",
   "One.toOfNat1",
   "Nat",
   "CanonicallyOrderedCommSemiring.toOne",
   "Nat.instAddCommMonoid"],
  "name": "MvPolynomial.IsHomogeneous",
  "constType":
  "{σ : Type u_1} → {R : Type u_3} → [inst : CommSemiring R] → MvPolynomial σ R → ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec", "instHAdd", "HAdd.hAdd", "Eq.refl", "Int", "Int.instAdd", "Eq"],
  "name": "Lean.Omega.Int.add_congr",
  "constType": "∀ {a b c d : ℤ}, a = b → c = d → a + c = b + d",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_10",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_32",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_33._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.instInsert",
   "EmptyCollection.emptyCollection",
   "LawfulSingleton.mk",
   "Finset.instSingleton",
   "LawfulSingleton",
   "Insert.insert",
   "True",
   "iff_self",
   "Finset.instMembership",
   "Eq",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "Iff",
   "DecidableEq",
   "of_eq_true",
   "Finset.ext",
   "Finset",
   "congr",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans",
   "Finset.instEmptyCollection"],
  "name": "Finset.instLawfulSingleton",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α], LawfulSingleton α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "Ne",
   "OfNat.ofNat",
   "Or",
   "Dvd.dvd",
   "semigroupDvd",
   "And.left",
   "CommMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Zero.toOfNat0",
   "SemigroupWithZero.toSemigroup",
   "And",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "And.right",
   "Prime",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "HMul.hMul",
   "Not",
   "IsUnit",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "Prime.not_unit",
  "constType":
  "∀ {α : Type u_1} [inst : CommMonoidWithZero α] {p : α}, Prime p → ¬IsUnit p",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "CharZero",
   "propext",
   "instOfNatNat",
   "One.toOfNat1",
   "Nat",
   "Nat.cast_eq_one",
   "Eq"],
  "name": "Mathlib.Algebra.CharZero.Defs._auxLemma.5",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {n : ℕ}, (↑n = 1) = (n = 1)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddMonoidWithOne",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring",
   "CommSemiring.mk",
   "CommRing.toRing",
   "CommRing.mul_comm",
   "Ring.toSemiring",
   "CommRing"],
  "name": "CommRing.toCommSemiring",
  "constType": "{α : Type u} → [s : CommRing α] → CommSemiring α",
  "constCategory": "Definition"},
 {"references": ["And", "Or", "Iff", "False", "Not", "or_imp"],
  "name": "not_or",
  "constType": "∀ {p q : Prop}, ¬(p ∨ q) ↔ ¬p ∧ ¬q",
  "constCategory": "Theorem"},
 {"references": ["trivial", "if_pos", "Decidable", "True", "ite", "Eq"],
  "name": "if_true",
  "constType":
  "∀ {α : Sort u_1} {x : Decidable True} (t e : α), (if True then t else e) = t",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "Finset.instInsert",
   "Union.union",
   "Finset.image_union",
   "Finset.instSingleton",
   "Insert.insert",
   "True",
   "Eq",
   "Finset.image_singleton",
   "Finset.instUnion",
   "DecidableEq",
   "of_eq_true",
   "Finset.image",
   "Finset",
   "Singleton.singleton",
   "congrArg",
   "Eq.trans"],
  "name": "Finset.image_insert",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : DecidableEq β] [inst_1 : DecidableEq α] (f : α → β) (a : α) (s : Finset α),\n  Finset.image f (insert a s) = insert (f a) (Finset.image f s)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "Int.instHPowNat",
   "Int.instDvd",
   "Int.instMul",
   "instHAdd",
   "HAdd.hAdd",
   "IsRegularPrime",
   "Dvd.dvd",
   "Int.instAdd",
   "instHMul",
   "Nat.Prime",
   "Nat.cast",
   "instNatCastInt",
   "HMul.hMul",
   "Not",
   "Nat",
   "Fact",
   "Int"],
  "name": "FltRegular.CaseI.Statement",
  "constType": "Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Omega.Constraint.not_sat_of_isImpossible",
   "Lean.Omega.Coeffs.dot",
   "Bool.true",
   "Lean.Omega.Constraint.isImpossible",
   "Lean.Omega.Coeffs",
   "Not",
   "Bool",
   "Lean.Omega.Constraint.sat'",
   "Lean.Omega.Constraint",
   "Eq"],
  "name": "Lean.Omega.Constraint.not_sat'_of_isImpossible",
  "constType":
  "∀ {c : Lean.Omega.Constraint}, c.isImpossible = true → ∀ {x y : Lean.Omega.Coeffs}, ¬c.sat' x y = true",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_41._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Associated",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "GCDMonoid",
   "MulZeroClass.mul_zero",
   "Associated.symm",
   "MulZeroClass.toMul",
   "CancelCommMonoidWithZero",
   "Eq",
   "Zero.toOfNat0",
   "gcd_mul_lcm",
   "GCDMonoid.gcd",
   "Eq.mpr",
   "Iff",
   "MonoidWithZero.toMonoid",
   "GCDMonoid.lcm",
   "MulZeroClass.toZero",
   "Eq.symm",
   "Associated.refl",
   "CommMonoidWithZero.toMonoidWithZero",
   "id",
   "Or",
   "mul_eq_zero",
   "GCDMonoid.lcm_zero_right",
   "Or.casesOn",
   "MulZeroOneClass.toMulZeroClass",
   "Iff.intro",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "Eq.ndrec",
   "Associated.trans",
   "propext",
   "letFun",
   "HMul.hMul",
   "associated_zero_iff_eq_zero",
   "GCDMonoid.lcm_zero_left",
   "MonoidWithZero.toZero",
   "congrArg",
   "CancelCommMonoidWithZero.toCancelMonoidWithZero",
   "CancelMonoidWithZero.to_noZeroDivisors"],
  "name": "lcm_eq_zero_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : GCDMonoid α] (a b : α), lcm a b = 0 ↔ a = 0 ∨ b = 0",
  "constCategory": "Theorem"},
 {"references": ["False", "Not", "False.rec"],
  "name": "absurd",
  "constType": "{a : Prop} → {b : Sort v} → a → ¬a → b",
  "constCategory": "Definition"},
 {"references": ["List"],
  "name": "List.nil",
  "constType": "{α : Type u} → List α",
  "constCategory": "Other"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "Monoid",
   "OfNat.ofNat",
   "IsUnit.pow",
   "isUnit_pow_iff.match_1",
   "Eq",
   "Iff.intro",
   "Units",
   "Units.isUnit",
   "Iff",
   "instHPow",
   "Units.val",
   "Units.ofPow",
   "Monoid.toNatPow",
   "instOfNatNat",
   "IsUnit",
   "Nat",
   "Eq.symm"],
  "name": "isUnit_pow_iff",
  "constType":
  "∀ {M : Type u_1} [inst : Monoid M] {n : ℕ} {a : M}, n ≠ 0 → (IsUnit (a ^ n) ↔ IsUnit a)",
  "constCategory": "Theorem"},
 {"references":
  ["Array.mkArray1",
   "Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node1",
  "constType":
  "Lean.SourceInfo → Lean.SyntaxNodeKind → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["GCDMonoid", "CancelCommMonoidWithZero"],
  "name": "GCDMonoid.gcd",
  "constType":
  "{α : Type u_2} → [inst : CancelCommMonoidWithZero α] → [self : GCDMonoid α] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "IsUnit.mul",
   "And",
   "instHMul",
   "And.right",
   "MulOneClass.toMul",
   "Iff",
   "isUnit_of_mul_isUnit_left",
   "CommMonoid",
   "isUnit_of_mul_isUnit_right",
   "HMul.hMul",
   "And.intro",
   "IsUnit",
   "CommMonoid.toMonoid",
   "And.left",
   "Monoid.toMulOneClass"],
  "name": "IsUnit.mul_iff",
  "constType":
  "∀ {M : Type u_1} [inst : CommMonoid M] {x y : M}, IsUnit (x * y) ↔ IsUnit x ∧ IsUnit y",
  "constCategory": "Theorem"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "MulZeroClass.mul_zero",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulZeroClass.toMul",
   "True",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Nat.recAux",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "mul_add",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instAddNat",
   "MulOneClass.toOne",
   "AddSemigroup.toAdd",
   "instHAdd",
   "Nat.instSemiring",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat.instDistrib",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_add",
   "NonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Distrib.leftDistribClass",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "congr",
   "mul_one",
   "instMulNat",
   "congrArg"],
  "name": "Nat.cast_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocSemiring α] (m n : ℕ), ↑(m * n) = ↑m * ↑n",
  "constCategory": "Theorem"},
 {"references": ["Eq"],
  "name": "Eq.refl",
  "constType": "∀ {α : Sort u_1} (a : α), a = a",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalNonAssocRing.toMul",
   "Int.instMul",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "Eq",
   "instHMul",
   "Int.mul",
   "NonAssocRing.toIntCast",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "HMul.hMul",
   "Mathlib.Meta.NormNum.isInt_mul.match_1",
   "Int.cast_mul",
   "Mathlib.Meta.NormNum.IsInt",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_mul",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HMul.hMul →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → a'.mul b' = c → Mathlib.Meta.NormNum.IsInt (a * b) c",
  "constCategory": "Theorem"},
 {"references":
  ["Eq.le", "Preorder", "Eq.symm", "LE.le", "Preorder.toLE", "Eq"],
  "name": "Eq.ge",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] {x y : α}, x = y → y ≤ x",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Set",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat", "UInt8", "Bool.casesOn", "_obj", "Nat.decEq", "Int.neg"],
  "name": "FltRegular.f._cstage2",
  "constType": "_obj → _obj → _obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "EStateM.Result.error",
   "UInt8",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Lean.Name.num._override",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___unexpand_CyclotomicField_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.num",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Ideal.map",
   "PartialOrder.toPreorder",
   "Semiring",
   "RingHomClass",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.completeLattice",
   "Ideal.comap",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "Ideal.map_le_iff_le_comap",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal",
   "Semiring.toModule"],
  "name": "FltRegular.NumberTheory.AuxLemmas._auxLemma.1",
  "constType":
  "∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : FunLike F R S]\n  [rc : RingHomClass F R S] {f : F} {I : Ideal R} {K : Ideal S}, (Ideal.map f I ≤ K) = (I ≤ Ideal.comap f K)",
  "constCategory": "Theorem"},
 {"references":
  ["Function.instFunLikeEmbedding.proof_1",
   "FunLike",
   "Function.Embedding.toFun",
   "Function.Embedding",
   "DFunLike.mk"],
  "name": "Function.instFunLikeEmbedding",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ↪ β) α β",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Monoid.toSemigroup",
   "Monoid",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "PartENat.find",
   "PartENat",
   "Dvd.dvd",
   "semigroupDvd",
   "instHPow",
   "instDecidableNot",
   "Monoid.toNatPow",
   "Not",
   "instOfNatNat",
   "Nat",
   "DecidableRel"],
  "name": "multiplicity",
  "constType":
  "{α : Type u_1} → [inst : Monoid α] → [inst : DecidableRel fun x x_1 => x ∣ x_1] → α → α → PartENat",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonAssocSemiring"],
  "name": "NonAssocSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonAssocSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Iff", "Eq"],
  "name": "propext",
  "constType": "∀ {a b : Prop}, (a ↔ b) → a = b",
  "constCategory": "Axiom"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.Name.num._override",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_45._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["not_or", "And", "Or", "propext", "Not", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.21",
  "constType": "∀ {p q : Prop}, (¬(p ∨ q)) = (¬p ∧ ¬q)",
  "constCategory": "Theorem"},
 {"references":
  ["MulZeroClass.mk",
   "NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "MulZeroClass",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.mul_zero"],
  "name": "NonUnitalNonAssocSemiring.toMulZeroClass",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → MulZeroClass α",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "NeZero",
   "Zero.ofOfNat0",
   "instOfNatPNatOfNeZeroNat.proof_1",
   "LT.lt",
   "OfNat",
   "instOfNatNat",
   "OfNat.mk",
   "Nat",
   "instLTNat",
   "Subtype.mk",
   "PNat"],
  "name": "instOfNatPNatOfNeZeroNat",
  "constType": "(n : ℕ) → [inst : NeZero n] → OfNat ℕ+ n",
  "constCategory": "Definition"},
 {"references": ["Div.div", "Div", "HDiv", "HDiv.mk"],
  "name": "instHDiv",
  "constType": "{α : Type u_1} → [inst : Div α] → HDiv α α α",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Macro.Context",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommRing.toNonUnitalCommRing",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "Module.Finite",
   "FractionRing.field",
   "CommRing",
   "Eq",
   "nonZeroDivisors",
   "Semiring.toNonAssocSemiring",
   "OreLocalization.oreSetComm",
   "FractionRing.liftAlgebra",
   "Algebra",
   "CommSemiring.toCommMonoidWithZero",
   "IsIntegrallyClosed",
   "Algebra.toSMul",
   "Semiring.toModule",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "OreLocalization.instCommRing",
   "Submodule.instBot",
   "NoZeroSMulDivisors",
   "Bot.bot",
   "Algebra.toModule",
   "OreLocalization.instRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Ideal.spanIntNorm_eq_bot_iff",
   "OreLocalization.instAlgebra",
   "Module.Free",
   "CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "FractionRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "CommRing.toRing",
   "FractionRing.instNoZeroSMulDivisors",
   "Ideal.spanIntNorm",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.IsSeparable",
   "Ideal"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.9",
  "constType":
  "∀ {R : Type u_1} [inst : CommRing R] {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsIntegrallyClosed R] [inst_4 : IsDomain R] [inst_5 : IsDomain S] [inst_6 : NoZeroSMulDivisors R S]\n  [inst_7 : IsIntegrallyClosed S] [inst_8 : Algebra.IsSeparable (FractionRing R) (FractionRing S)] [inst_9 : IsDomain R]\n  [inst_10 : IsDomain S] [inst_11 : Module.Free R S] [inst_12 : Module.Finite R S] {I : Ideal S},\n  (Ideal.spanIntNorm R I = ⊥) = (I = ⊥)",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Submodule.hasQuotient",
   "CommRing.toRing",
   "Ring.toAddCommGroup",
   "HasQuotient",
   "Ideal",
   "Semiring.toModule",
   "CommRing"],
  "name": "Ideal.instHasQuotient",
  "constType": "{R : Type u} → [inst : CommRing R] → HasQuotient R (Ideal R)",
  "constCategory": "Definition"},
 {"references": ["Group"],
  "name": "Subgroup",
  "constType": "(G : Type u_5) → [inst : Group G] → Type u_5",
  "constCategory": "Other"},
 {"references": [],
  "name": "Iff",
  "constType": "Prop → Prop → Prop",
  "constCategory": "Other"},
 {"references": ["Mul"],
  "name": "HasDistribNeg",
  "constType": "(α : Type u_1) → [inst : Mul α] → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Set.instSingletonSet",
   "Set",
   "Singleton.singleton",
   "Set.instMembership",
   "rfl"],
  "name": "Set.mem_singleton",
  "constType": "∀ {α : Type u} (a : α), a ∈ {a}",
  "constCategory": "Theorem"},
 {"references": ["Preorder", "PartialOrder"],
  "name": "PartialOrder.toPreorder",
  "constType": "{α : Type u} → [self : PartialOrder α] → Preorder α",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Prime.pos",
   "Nat.Prime",
   "Nat.pred",
   "Nat.succ_pred_eq_of_pos",
   "Nat",
   "Nat.succ",
   "Eq"],
  "name": "Nat.succ_pred_prime",
  "constType": "∀ {p : ℕ}, Nat.Prime p → p.pred.succ = p",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Int.cast_natCast",
   "AddGroupWithOne.toIntCast",
   "Eq.refl",
   "One.toOfNat1",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "AddMonoidWithOne.toOne",
   "instNatCastInt",
   "Int.cast",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Int",
   "instOfNat",
   "Nat.cast_one",
   "id"],
  "name": "Int.cast_one",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R], ↑1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "_neutral",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "UInt8",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "_obj",
   "Lean.Name.num._override",
   "Lean.Syntax.node1",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termR_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Eq.ndrec", "List", "Eq.refl", "List.casesOn", "List.noConfusionType", "Eq"],
  "name": "List.noConfusion",
  "constType":
  "{α : Type u} → {P : Sort u_1} → {v1 v2 : List α} → v1 = v2 → List.noConfusionType P v1 v2",
  "constCategory": "Definition"},
 {"references": ["OrderedSemiring", "Semiring"],
  "name": "OrderedSemiring.toSemiring",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "AddMonoid"],
  "name": "SubNegMonoid.toAddMonoid",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → AddMonoid G",
  "constCategory": "Definition"},
 {"references": ["Lean.Name", "Lean.MonadQuotation"],
  "name": "Lean.MonadQuotation.getMainModule",
  "constType":
  "{m : Type → Type} → [self : Lean.MonadQuotation m] → m Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.num",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Monoid",
   "LeftCancelMonoid.npow",
   "Monoid.mk",
   "LeftCancelMonoid.one_mul",
   "LeftCancelMonoid.npow_zero",
   "LeftCancelMonoid.toLeftCancelSemigroup",
   "LeftCancelMonoid.toOne",
   "LeftCancelMonoid.mul_one",
   "LeftCancelSemigroup.toSemigroup",
   "LeftCancelMonoid",
   "LeftCancelMonoid.npow_succ"],
  "name": "LeftCancelMonoid.toMonoid",
  "constType": "{M : Type u} → [self : LeftCancelMonoid M] → Monoid M",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "congr_arg",
   "Rat",
   "Rat.num",
   "Int.instRing",
   "Eq",
   "Rat.commRing",
   "Int.instCharZero",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CharZero",
   "Eq.mp",
   "CommRing.toRing",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.2",
   "Nat",
   "CharZero.mk",
   "Int"],
  "name": "Rat.instCharZero",
  "constType": "CharZero ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Classical.decEq",
   "IsDomain",
   "Finset",
   "Polynomial.nthRoots",
   "One.toOfNat1",
   "Multiset.toFinset",
   "Nat",
   "CommRing"],
  "name": "Polynomial.nthRootsFinset",
  "constType":
  "ℕ → (R : Type u_1) → [inst : CommRing R] → [inst : IsDomain R] → Finset R",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.num",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.node5",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Int.instCancelCommMonoidWithZero.proof_1",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "CommSemiring.toCommMonoidWithZero",
   "Int",
   "CancelCommMonoidWithZero",
   "CancelCommMonoidWithZero.mk"],
  "name": "Int.instCancelCommMonoidWithZero",
  "constType": "CancelCommMonoidWithZero ℤ",
  "constCategory": "Definition"},
 {"references":
  ["DecidableEq",
   "Finset",
   "Multiset",
   "Multiset.nodup_dedup",
   "Finset.mk",
   "Multiset.dedup"],
  "name": "Multiset.toFinset",
  "constType":
  "{α : Type u_1} → [inst : DecidableEq α] → Multiset α → Finset α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["IsDomain.toIsCancelMulZero",
   "CancelMonoidWithZero",
   "CancelMonoidWithZero.mk",
   "Semiring",
   "IsDomain",
   "Semiring.toMonoidWithZero"],
  "name": "IsDomain.toCancelMonoidWithZero",
  "constType":
  "{α : Type u_1} → [inst : Semiring α] → [inst : IsDomain α] → CancelMonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "NeZero.nat_of_injective",
   "Algebra.instCompleteLatticeSubalgebra",
   "CommSemiring.toSemiring",
   "Polynomial.IsRoot",
   "OfNat.ofNat",
   "LT.lt.ne'",
   "PartialOrder.toPreorder",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "Polynomial.degree_cyclotomic_pos",
   "IsCyclotomicExtension.mk",
   "Semifield.toCommGroupWithZero",
   "Exists.casesOn",
   "Subalgebra.instSetLike",
   "LocalRing.toNontrivial",
   "implies_congr",
   "SetLike.instMembership",
   "Polynomial.cyclotomic",
   "Semiring.toNatCast",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Field",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "Eq.trans",
   "HPow.hPow",
   "Polynomial.rootSet",
   "setOf",
   "Polynomial.exists_root_of_splits",
   "eq_comm",
   "ValuationRing.localRing",
   "WithBot.zero",
   "Set.instMembership",
   "EuclideanDomain.toCommRing",
   "CommGroupWithZero.toCommMonoidWithZero",
   "RingHom.instFunLike",
   "CyclotomicField",
   "And",
   "CommRing.toCommMonoid",
   "ValuationRing.of_field",
   "propext",
   "Field.toEuclideanDomain",
   "Polynomial.eval₂",
   "Eq.mp",
   "Mathlib.NumberTheory.Cyclotomic.Basic._auxLemma.16",
   "CommRing.toRing",
   "Singleton.singleton",
   "Algebra.id",
   "MonoidWithZero.toZero",
   "congrArg",
   "Field.toDivisionRing",
   "Polynomial.SplittingField.adjoin_rootSet",
   "Polynomial.SplittingField.commRing",
   "RingHom",
   "Exists",
   "CyclotomicField.algebra",
   "CommMonoidWithZero.toZero",
   "DivisionRing.toDivisionSemiring",
   "Nat.instStrictOrderedSemiring",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "PNat.pos",
   "Polynomial.map_cyclotomic",
   "DivisionRing.toRing",
   "Set",
   "Semiring.toMonoidWithZero",
   "Subalgebra",
   "Eq.refl",
   "Exists.intro",
   "RingHom.injective",
   "Polynomial.SplittingField.algebra'",
   "Mathlib.NumberTheory.Cyclotomic.Basic._auxLemma.6",
   "Polynomial.SplittingField.instField",
   "Zero.toOfNat0",
   "PNat.val",
   "CyclotomicField.instField",
   "Polynomial",
   "Set.instSingletonSet",
   "NeZero",
   "Polynomial.isRoot_cyclotomic_iff",
   "WithBot.preorder",
   "instHPow",
   "forall_congr",
   "Monoid.toNatPow",
   "Eq.symm",
   "id",
   "Membership.mem",
   "Polynomial.SplittingField.splits",
   "Top.top",
   "algebraMap",
   "IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots",
   "Field.toSemifield",
   "One.toOfNat1",
   "Ring.toSemiring",
   "Polynomial.SplittingField",
   "Polynomial.eval",
   "Polynomial.map",
   "Semiring.toOne",
   "IsCyclotomicExtension",
   "CommRing.toCommSemiring",
   "DivisionSemiring.toSemiring",
   "Field.isDomain",
   "StrictOrderedSemiring.toPartialOrder",
   "Polynomial.eval_map",
   "Polynomial.IsRoot.def",
   "CompleteLattice.toTop",
   "Algebra.eq_top_iff",
   "Semifield.toDivisionSemiring",
   "WithBot",
   "Polynomial.degree",
   "Algebra.adjoin",
   "PNat"],
  "name": "CyclotomicField.isCyclotomicExtension",
  "constType":
  "∀ (n : ℕ+) (K : Type w) [inst : Field K] [inst_1 : NeZero ↑↑n], IsCyclotomicExtension {n} K (CyclotomicField n K)",
  "constCategory": "Definition"},
 {"references": ["Add", "AddSemigroup"],
  "name": "AddSemigroup.toAdd",
  "constType": "{G : Type u} → [self : AddSemigroup G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_1",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_7",
   "Lean.Name.mkStr4",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_3",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_2"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Iff", "Decidable", "dite_eq_right_iff", "ite", "Eq"],
  "name": "ite_eq_right_iff",
  "constType":
  "∀ {α : Sort u_1} {a b : α} {P : Prop} [inst : Decidable P], (if P then a else b) = b ↔ P → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.ble",
   "instLENat",
   "Decidable.isFalse",
   "Bool.true",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "dite",
   "Bool",
   "Nat.not_le_of_not_ble_eq_true",
   "Nat.le_of_ble_eq_true",
   "Nat",
   "LE.le",
   "instDecidableEqBool",
   "Eq"],
  "name": "Nat.decLe",
  "constType": "(n m : ℕ) → Decidable (n ≤ m)",
  "constCategory": "Definition"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "Eq.symm",
  "constType": "∀ {α : Sort u} {a b : α}, a = b → b = a",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "AddCommMonoid"],
  "name": "Module",
  "constType":
  "(R : Type u) → (M : Type v) → [inst : Semiring R] → [inst : AddCommMonoid M] → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["List",
   "Lean.SourceInfo",
   "Lean.Syntax.Preresolved",
   "Lean.Name",
   "Lean.Syntax",
   "Substring"],
  "name": "Lean.Syntax.ident",
  "constType":
  "Lean.SourceInfo → Substring → Lean.Name → List Lean.Syntax.Preresolved → Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Equiv",
   "Equiv.toFun",
   "FunLike",
   "Equiv.instFunLike.proof_1",
   "DFunLike.mk"],
  "name": "Equiv.instFunLike",
  "constType": "{α : Sort u} → {β : Sort v} → FunLike (α ≃ β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "AddGroup.toSubtractionMonoid",
   "AddGroupWithOne.toAddGroup",
   "Preorder.toLE",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "mul_pos_of_neg_of_neg",
   "Ring.toNeg",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "HasDistribNeg.toInvolutiveNeg",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "neg_neg_of_pos",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Init.Core._auxLemma.7",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "AddCancelMonoid.toIsCancelAdd",
   "OrderedCancelAddCommMonoid.toContravariantClassLeft",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "StrictOrderedSemiring.toOrderedSemiring",
   "neg_of_neg_pos",
   "LT.lt",
   "Eq.mp",
   "MonoidWithZero.toZero",
   "congrArg",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "StrictOrderedRing.toRing",
   "AddZeroClass.toAdd",
   "Mathlib.Algebra.Order.Group.Unbundled.Basic._auxLemma.10",
   "StrictOrderedSemiring.toOrderedCancelAddCommMonoid",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddMonoid.toAddZeroClass",
   "Ring.toNonAssocRing",
   "StrictOrderedRing.toStrictOrderedSemiring",
   "Zero.toOfNat0",
   "StrictOrderedSemiring.toMulPosStrictMono",
   "Preorder.toLT",
   "InvolutiveNeg.toNeg",
   "StrictOrderedRing",
   "AddGroup.toAddCancelMonoid",
   "neg_mul",
   "OrderedAddCommGroup.to_covariantClass_left_le",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "contravariant_swap_add_of_contravariant_add",
   "id",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "IsCancelAdd.toIsLeftCancelAdd",
   "AddGroup.existsAddOfLE",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "StrictOrderedSemiring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "letFun",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg"],
  "name": "Linarith.mul_neg",
  "constType":
  "∀ {α : Type u_1} [inst : StrictOrderedRing α] {a b : α}, a < 0 → 0 < b → b * a < 0",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LE",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["HPow", "Pow.pow", "Pow", "HPow.mk"],
  "name": "instHPow",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → [inst : Pow α β] → HPow α β α",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_18",
   "_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_12",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_19._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "MvPolynomial.commSemiring",
   "CommSemiring.toSemiring",
   "RingHom",
   "OfNat.ofNat",
   "Semiring.toNonAssocSemiring",
   "MvPolynomial",
   "CommSemiring",
   "One.toOfNat1",
   "DFunLike.coe",
   "RingHom.instFunLike",
   "rfl",
   "Eq",
   "MvPolynomial.C"],
  "name": "MvPolynomial.C_1",
  "constType":
  "∀ {R : Type u} {σ : Type u_1} [inst : CommSemiring R], MvPolynomial.C 1 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Subtype.val",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "PNat"],
  "name": "PNat.val",
  "constType": "ℕ+ → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "add_assoc",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toAddSemigroup",
   "CommSemiring",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_lt",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₂ b c : R} (a₁ : R), a₂ + b = c → a₁ + a₂ + b = a₁ + c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Or",
   "Finset.instInsert",
   "DecidableEq",
   "propext",
   "Finset",
   "Insert.insert",
   "Finset.mem_insert",
   "Eq",
   "Finset.instMembership"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.64",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s : Finset α} {a b : α}, (a ∈ insert b s) = (a = b ∨ a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "PartialOrder.toPreorder",
   "LinearOrderedCommSemiring.toMin",
   "Nat.instLinearOrderedCommMonoidWithZero.proof_2",
   "AddCommMonoid.toAddMonoid",
   "LinearOrderedCommSemiring.max_def",
   "StrictOrderedCommSemiring.toStrictOrderedSemiring",
   "OrderedCommMonoid.mk",
   "Preorder.toLE",
   "Nat.instLinearOrderedCommMonoidWithZero.proof_6",
   "inferInstance",
   "LinearOrderedCommSemiring.min_def",
   "LinearOrderedCommSemiring.le_total",
   "Semiring.npow",
   "AddMonoid.toZero",
   "Nat.mul_le_mul_left",
   "LinearOrderedCommSemiring.compare_eq_compareOfLessAndEq",
   "Nat.instLinearOrderedCommMonoidWithZero.proof_4",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "CommMonoid.mk",
   "Semigroup.mk",
   "LinearOrderedCommSemiring.toMax",
   "Nat.instLinearOrderedCommMonoidWithZero.proof_3",
   "Nat.instLinearOrderedCommMonoidWithZero.proof_9",
   "Nat.instLinearOrderedCommMonoidWithZero.proof_1",
   "LinearOrderedCommMonoidWithZero",
   "Nat.instLinearOrderedCommMonoidWithZero.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "LinearOrderedCommSemiring.toOrd",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "LinearOrderedCommSemiring.decidableEq",
   "StrictOrderedSemiring.toSemiring",
   "CommMonoidWithZero",
   "LE.le",
   "LinearOrderedCommSemiring.decidableLE",
   "LinearOrderedCommSemiring",
   "LinearOrderedCommMonoidWithZero.mk",
   "Semiring.toOne",
   "Nat.instLinearOrderedCommMonoidWithZero.proof_5",
   "Nat.instCommSemiring",
   "Nat.instLinearOrderedCommSemiring",
   "StrictOrderedSemiring.toPartialOrder",
   "LinearOrderedCommMonoid.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "LinearOrderedCommSemiring.decidableLT",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Nat.instLinearOrderedCommMonoidWithZero.proof_7"],
  "name": "Nat.instLinearOrderedCommMonoidWithZero",
  "constType": "LinearOrderedCommMonoidWithZero ℕ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_46._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "Multiset.prod.proof_1",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "Multiset.foldr",
   "CommMonoid",
   "Multiset",
   "HMul.hMul",
   "One.toOfNat1",
   "CommMonoid.toMonoid",
   "Monoid.toMulOneClass"],
  "name": "Multiset.prod",
  "constType": "{α : Type u_3} → [inst : CommMonoid α] → Multiset α → α",
  "constCategory": "Definition"},
 {"references":
  ["RingHom",
   "RingHom.comp",
   "DFunLike.coe",
   "RingHom.instFunLike",
   "rfl",
   "NonAssocSemiring",
   "Eq"],
  "name": "RingHom.comp_apply",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β}\n  {x_2 : NonAssocSemiring γ} (hnp : β →+* γ) (hmn : α →+* β) (x_3 : α), (hnp.comp hmn) x_3 = hnp (hmn x_3)",
  "constCategory": "Theorem"},
 {"references": ["EuclideanDomain", "CommRing"],
  "name": "EuclideanDomain.toCommRing",
  "constType": "{R : Type u} → [self : EuclideanDomain R] → CommRing R",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termR_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Equiv",
   "Int.instAddGroup",
   "Subgroup.zpowers.proof_1",
   "DivInvMonoid.Pow",
   "MonoidHom",
   "AddMonoid.toAddZeroClass",
   "MonoidHom.range",
   "DivInvMonoid.toMonoid",
   "zpowersHom",
   "Monoid.toMulOneClass",
   "Set.range",
   "Subgroup.copy",
   "Multiplicative",
   "Int.instAddMonoid",
   "instHPow",
   "Multiplicative.group",
   "Subgroup",
   "Equiv.instFunLike",
   "Group",
   "Group.toDivInvMonoid",
   "DFunLike.coe",
   "Int",
   "Multiplicative.mulOneClass"],
  "name": "Subgroup.zpowers",
  "constType": "{G : Type u_1} → [inst : Group G] → G → Subgroup G",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveNeg",
   "Iff",
   "InvolutiveNeg.toNeg",
   "neg_injective",
   "Neg.neg",
   "Function.Injective.eq_iff",
   "Eq"],
  "name": "neg_inj",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, -a = -b ↔ a = b",
  "constCategory": "Theorem"},
 {"references": ["congrArg", "Eq"],
  "name": "congr_arg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["Units",
   "OfNat.ofNat",
   "Monoid",
   "One",
   "Monoid.toOne",
   "One.mk",
   "One.toOfNat1",
   "Units.instOne.proof_1",
   "Units.mk"],
  "name": "Units.instOne",
  "constType": "{α : Type u} → [inst : Monoid α] → One αˣ",
  "constCategory": "Definition"},
 {"references": ["Zero", "SMul"],
  "name": "NoZeroSMulDivisors",
  "constType":
  "(R : Type u_9) → (M : Type u_10) → [inst : Zero R] → [inst : Zero M] → [inst : SMul R M] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.Name.num._override",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Exists.intro",
   "Or.imp_right",
   "Odd.proof_1",
   "Eq",
   "Semiring.toNatCast",
   "Nat.Prime.eq_two_or_odd",
   "Nat.Prime",
   "Semiring.toNonAssocSemiring",
   "instOfNatNat",
   "HDiv.hDiv",
   "Odd",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "instOfNatAtLeastTwo",
   "Or",
   "instHDiv",
   "congr_arg",
   "Nat.instDiv",
   "instAddNat",
   "instHAdd",
   "Nat.instSemiring",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "instHMul",
   "instHMod",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Nat.div_add_mod",
   "HMod.hMod",
   "HMul.hMul",
   "instMulNat",
   "Nat.instMod"],
  "name": "Nat.Prime.eq_two_or_odd'",
  "constType": "∀ {p : ℕ}, Nat.Prime p → p = 2 ∨ Odd p",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_eq_left", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.2",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a = a' ∧ p a) = p a'",
  "constCategory": "Theorem"},
 {"references": ["DivisionMonoid", "DivisionCommMonoid"],
  "name": "DivisionCommMonoid.toDivisionMonoid",
  "constType":
  "{G : Type u} → [self : DivisionCommMonoid G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Finsupp",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "MvPolynomial",
   "CommSemiring",
   "Finset",
   "Semiring.toMonoidWithZero",
   "LinearOrderedCommMonoidWithZero.toZero",
   "MonoidWithZero.toZero",
   "Nat",
   "Finsupp.support"],
  "name": "MvPolynomial.support",
  "constType":
  "{R : Type u} → {σ : Type u_1} → [inst : CommSemiring R] → MvPolynomial σ R → Finset (σ →₀ ℕ)",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "EquivLike",
  "constType":
  "Sort u_1 → outParam (Sort u_2) → outParam (Sort u_3) → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Other"},
 {"references": ["Zero", "AddZeroClass"],
  "name": "AddZeroClass.toZero",
  "constType": "{M : Type u} → [self : AddZeroClass M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_29",
   "_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_5",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_30._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SemigroupWithZero.toSemigroup",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "mul_assoc",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "CommSemiring.toNonUnitalCommSemiring",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "Eq"],
  "name": "Mathlib.Tactic.RingNF.mul_assoc_rev",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a b c : R), a * (b * c) = a * b * c",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Eq",
  "constType": "{α : Sort u_1} → α → α → Prop",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "QuotientGroup.instHasQuotientSubgroup",
   "IsDomain",
   "FractionalIdeal.commSemiring",
   "Semiring.toMonoidWithZero",
   "Field.toSemifield",
   "FractionRing.field",
   "MonoidHom.range",
   "EuclideanDomain.toCommRing",
   "CommRing",
   "nonZeroDivisors",
   "OreLocalization.instAlgebra",
   "toPrincipalIdeal",
   "DivisionSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "Units",
   "CommRing.toCommMonoid",
   "FractionRing",
   "MonoidWithZero.toMonoid",
   "Field.toEuclideanDomain",
   "OreLocalization.oreSetComm",
   "Subgroup",
   "FractionalIdeal",
   "Semifield.toDivisionSemiring",
   "HasQuotient.Quotient",
   "Algebra.id",
   "Units.instGroup",
   "ClassGroup.proof_1",
   "OreLocalization.instCommRing"],
  "name": "ClassGroup",
  "constType":
  "(R : Type u_1) → [inst : CommRing R] → [inst : IsDomain R] → Type u_1",
  "constCategory": "Definition"},
 {"references":
  ["NormedAddCommGroup.toMetricSpace",
   "Int.instNormedAddCommGroup",
   "Int.instNormedCommRing.proof_1",
   "NormedAddCommGroup",
   "Int.instCommRing",
   "NormedCommRing",
   "CommRing.toRing",
   "NormedRing.mk",
   "CommRing.mul_comm",
   "NormedAddCommGroup.dist_eq",
   "NormedAddCommGroup.toNorm",
   "NormedCommRing.mk",
   "Int",
   "CommRing"],
  "name": "Int.instNormedCommRing",
  "constType": "NormedCommRing ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ne",
   "And",
   "Nat.divisors",
   "OfNat.ofNat",
   "propext",
   "Finset",
   "Nat.mem_divisors",
   "instOfNatNat",
   "Dvd.dvd",
   "Nat.instDvd",
   "Nat",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.9",
  "constType": "∀ {n m : ℕ}, (n ∈ m.divisors) = (n ∣ m ∧ m ≠ 0)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_12",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_18"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_19._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["AddGroupWithOne", "Sub"],
  "name": "AddGroupWithOne.toSub",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → Sub R",
  "constCategory": "Definition"},
 {"references": ["Monoid", "One"],
  "name": "Monoid.toOne",
  "constType": "{M : Type u} → [self : Monoid M] → One M",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "Lean.Name.mkStr3",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.node5",
   "_neutral",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Lean.Name.num._override",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["instHSub", "Eq.ndrec", "HSub.hSub", "Eq.refl", "Int.instSub", "Int", "Eq"],
  "name": "Lean.Omega.Int.sub_congr",
  "constType": "∀ {a b c d : ℤ}, a = b → c = d → a - c = b - d",
  "constCategory": "Theorem"},
 {"references": ["Lean.PrettyPrinter.UnexpandM", "Lean.Syntax"],
  "name": "Lean.PrettyPrinter.Unexpander",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Units",
   "OfNat.ofNat",
   "Units.instInv",
   "MulOneClass.toMul",
   "Monoid",
   "Monoid.toOne",
   "Units.inv_val",
   "Units.val",
   "HMul.hMul",
   "One.toOfNat1",
   "Monoid.toMulOneClass",
   "Inv.inv",
   "Eq"],
  "name": "Units.inv_mul",
  "constType": "∀ {α : Type u} [inst : Monoid α] (a : αˣ), ↑a⁻¹ * ↑a = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "pow_one",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat.instAddCommMonoidWithOne",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "HPow.hPow",
   "instHAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "AddMonoidWithOne.toOne",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "mul_one",
   "add_zero",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.atom_pf",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a = a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references": ["Units", "Exists", "Monoid", "Units.val", "Eq"],
  "name": "IsUnit",
  "constType": "{M : Type u_1} → [inst : Monoid M] → M → Prop",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termR_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Or"],
  "name": "Or.inl",
  "constType": "∀ {a b : Prop}, a → a ∨ b",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Subgroup.zpowers",
   "Finite",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "Submonoid.powers",
   "Eq",
   "mem_powers_iff_mem_zpowers",
   "propext",
   "Submonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "Eq.symm",
   "Submonoid.instSetLike",
   "Subgroup.instSetLike"],
  "name": "FltRegular.NumberTheory.Hilbert90._auxLemma.3",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G] {x y : G}, (y ∈ Subgroup.zpowers x) = (y ∈ Submonoid.powers x)",
  "constCategory": "Theorem"},
 {"references":
  ["Group.toDivisionMonoid",
   "Membership.mem",
   "QuotientGroup.instHasQuotientSubgroup",
   "OfNat.ofNat",
   "One.toOfNat1",
   "SetLike.instMembership",
   "Eq",
   "InvOneClass.toOne",
   "QuotientGroup.mk",
   "propext",
   "DivInvOneMonoid.toInvOneClass",
   "Subgroup.Normal",
   "Subgroup",
   "Group",
   "QuotientGroup.Quotient.group",
   "HasQuotient.Quotient",
   "DivisionMonoid.toDivInvOneMonoid",
   "Subgroup.instSetLike",
   "QuotientGroup.eq_one_iff"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.7",
  "constType":
  "∀ {G : Type u} [inst : Group G] {N : Subgroup G} [nN : N.Normal] (x : G), (↑x = 1) = (x ∈ N)",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "eq_true",
   "PNat.pos",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "True",
   "Eq",
   "PNat"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.1",
  "constType": "∀ (n : ℕ+), (0 < ↑n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "eq_false",
   "OfNat.ofNat",
   "NeZero",
   "False",
   "zero_ne_one",
   "One",
   "One.toOfNat1",
   "Eq"],
  "name": "Mathlib.Algebra.NeZero._auxLemma.3",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], (0 = 1) = False",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "instHAdd",
   "HAdd.hAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "of_eq_true",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "Mathlib.Tactic.Ring.cast_pos.match_1",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "add_zero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.cast_pos",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R} {n : ℕ}, Mathlib.Meta.NormNum.IsNat a n → a = n.rawCast + 0",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "propext",
   "LT.lt",
   "instOfNatNat",
   "Nat.lt_one_iff",
   "Nat",
   "instLTNat",
   "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.27",
  "constType": "∀ {n : ℕ}, (n < 1) = (n = 0)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Submodule", "Semiring", "Module", "AddCommMonoid"],
  "name": "Submodule.IsPrincipal",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_4} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → Submodule R M → Prop",
  "constCategory": "Other"},
 {"references": ["Nat"],
  "name": "Nat.succ",
  "constType": "ℕ → ℕ",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Set",
   "Set.instMembership",
   "Set.image",
   "Eq"],
  "name": "Set.mem_image",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), y ∈ f '' s ↔ ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "instHSMul",
   "Semiring",
   "algebraMap",
   "Algebra.smul_def",
   "NonUnitalNonAssocSemiring.toMul",
   "RingHom.instFunLike",
   "Eq",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "HSMul.hSMul",
   "HMul.hMul",
   "DFunLike.coe",
   "Eq.symm",
   "Algebra.toSMul"],
  "name": "FltRegular.NumberTheory.QuotientTrace._auxLemma.2",
  "constType":
  "∀ {R : Type u} {A : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Algebra R A] (r : R) (x : A),\n  (algebraMap R A) r * x = r • x",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Iff.rfl",
   "Polynomial.mem_nthRoots",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "instLTNat",
   "CommRing",
   "Eq",
   "Finset.instMembership",
   "Multiset.instMembership",
   "Eq.mpr",
   "Iff",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Finset",
   "Multiset",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "id",
   "Polynomial.nthRootsFinset_def",
   "HPow.hPow",
   "Membership.mem",
   "Classical.propDecidable",
   "Polynomial.nthRoots",
   "One.toOfNat1",
   "Multiset.toFinset",
   "Polynomial.nthRootsFinset",
   "Semiring.toOne",
   "CommRing.toCommSemiring",
   "Multiset.mem_toFinset",
   "propext",
   "LT.lt",
   "congrArg"],
  "name": "Polynomial.mem_nthRootsFinset",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] [inst_1 : IsDomain R] {n : ℕ},\n  0 < n → ∀ {x : R}, x ∈ Polynomial.nthRootsFinset n R ↔ x ^ n = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Prime.one_lt",
   "OfNat.ofNat",
   "Nat.Prime",
   "Fact.mk",
   "LT.lt",
   "Fact.out",
   "instOfNatNat",
   "Nat",
   "Fact",
   "instLTNat"],
  "name": "Nat.Prime.one_lt'",
  "constType": "∀ (p : ℕ) [hp : Fact (Nat.Prime p)], Fact (1 < p)",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "And",
   "CommMonoidWithZero.toZero",
   "gcd_eq_zero_iff",
   "OfNat.ofNat",
   "GCDMonoid.gcd",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "GCDMonoid",
   "propext",
   "CancelCommMonoidWithZero",
   "Eq"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : GCDMonoid α] (a b : α), (gcd a b = 0) = (a = 0 ∧ b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "FunLike",
   "RingHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoidHomClass",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring"],
  "name": "RingHomClass.toAddMonoidHomClass",
  "constType":
  "∀ {F : Type u_5} {α : outParam (Type u_6)} {β : outParam (Type u_7)} [inst : NonAssocSemiring α]\n  [inst_1 : NonAssocSemiring β] [inst_2 : FunLike F α β] [self : RingHomClass F α β], AddMonoidHomClass F α β",
  "constCategory": "Theorem"},
 {"references": ["Field", "CommRing"],
  "name": "Field.toCommRing",
  "constType": "{K : Type u} → [self : Field K] → CommRing K",
  "constCategory": "Definition"},
 {"references": ["Subsingleton.allEq", "Subsingleton", "Eq"],
  "name": "Subsingleton.elim",
  "constType": "∀ {α : Sort u} [h : Subsingleton α] (a b : α), a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "True",
  "constType": "Prop",
  "constCategory": "Other"},
 {"references": ["Fin.val", "LT.lt", "Nat", "instLTNat", "Fin.isLt", "Fin"],
  "name": "Fin.is_lt",
  "constType": "∀ {n : ℕ} (a : Fin n), ↑a < n",
  "constCategory": "Theorem"},
 {"references":
  ["NeZero",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "One",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "CanonicallyOrderedAddCommMonoid",
   "Fact.out",
   "AddCommMonoid.toAddMonoid",
   "One.toOfNat1",
   "NeZero.of_gt",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Fact",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "NeZero.of_gt'",
  "constType":
  "∀ {M : Type u_1} [inst : CanonicallyOrderedAddCommMonoid M] [inst_1 : One M] {y : M} [inst_2 : Fact (1 < y)], NeZero y",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "eq_true",
   "Set",
   "Set.instMembership",
   "Set.univ",
   "Set.mem_univ",
   "True",
   "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.10",
  "constType": "∀ {α : Type u} (x : α), (x ∈ Set.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionMonoid",
   "_private.Mathlib.Algebra.Group.Defs.0.inv_eq_of_mul",
   "Group.toDivisionMonoid.proof_1",
   "Group.toDivisionMonoid.proof_2",
   "DivisionMonoid.mk",
   "Group",
   "Group.toDivInvMonoid"],
  "name": "Group.toDivisionMonoid",
  "constType": "{G : Type u_1} → [inst : Group G] → DivisionMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHomClass",
   "FunLike",
   "CommMonoid",
   "Finset.prod",
   "Finset",
   "map_prod",
   "DFunLike.coe",
   "CommMonoid.toMonoid",
   "Eq.symm",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.3",
  "constType":
  "∀ {α : Type u_3} {β : Type u_4} {γ : Type u_5} [inst : CommMonoid β] [inst_1 : CommMonoid γ] {G : Type u_6}\n  [inst_2 : FunLike G β γ] [inst_3 : MonoidHomClass G β γ] (g : G) (f : α → β) (s : Finset α),\n  ∏ x ∈ s, g (f x) = g (∏ x ∈ s, f x)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "Semifield.toCommSemiring",
   "NumberField.RingOfIntegers.instCommRing",
   "Subalgebra.toCommSemiring",
   "Field.toSemifield",
   "Subalgebra",
   "Ring.toSemiring",
   "EuclideanDomain.toCommRing",
   "algebraInt",
   "integralClosure",
   "Subalgebra.instSetLike",
   "SetLike.instMembership",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "Field.toEuclideanDomain",
   "Field",
   "Ring",
   "Algebra",
   "inferInstanceAs",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Subalgebra.toAlgebra",
   "Int",
   "Subtype"],
  "name": "NumberField.RingOfIntegers.instAlgebra_1",
  "constType":
  "(K : Type u_1) →\n  [inst : Field K] →\n    {L : Type u_3} → [inst_1 : Ring L] → [inst_2 : Algebra K L] → Algebra (NumberField.RingOfIntegers K) L",
  "constCategory": "Definition"},
 {"references":
  ["MvPolynomial.leadingTerms",
   "MvPolynomial.homogeneousComponent_isHomogeneous",
   "MvPolynomial.IsHomogeneous",
   "MvPolynomial",
   "CommSemiring",
   "MvPolynomial.totalDegree"],
  "name": "MvPolynomial.isHomogeneous_leadingTerms",
  "constType":
  "∀ {R : Type u_2} {ι : Type u_1} [inst : CommSemiring R] (p : MvPolynomial ι R),\n  p.leadingTerms.IsHomogeneous p.totalDegree",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Int.instCommRing",
   "CommRing.toNonUnitalCommRing",
   "StarRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.instCommSemiring",
   "Int",
   "starRingOfComm",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "Int.instStarRing",
  "constType": "StarRing ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "NeZero.ne",
   "One",
   "One.toOfNat1"],
  "name": "one_ne_zero",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], 1 ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_8",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_4"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["trivial", "Iff.intro", "propext", "True", "Eq"],
  "name": "eq_true",
  "constType": "∀ {p : Prop}, p → p = True",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "List.cons",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.node5",
   "_neutral",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Lean.Name.num._override",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.node3"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "LinearOrderedCommMonoid.toOrderedCommMonoid",
   "PartialOrder.toPreorder",
   "propext",
   "LinearOrderedCommMonoidWithZero.toZero",
   "OrderedCommMonoid.toPartialOrder",
   "LinearOrderedCommMonoidWithZero",
   "le_zero_iff",
   "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.30",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedCommMonoidWithZero α] {a : α}, (a ≤ 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Monoid.toSemigroup",
   "eq_true",
   "Monoid",
   "dvd_refl",
   "Dvd.dvd",
   "semigroupDvd",
   "True",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.31",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a : α), (a ∣ a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "inferInstance",
   "Int.instCommRing",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int",
   "Distrib",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toDistrib"],
  "name": "Int.instDistrib",
  "constType": "Distrib ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "OfNat.ofNat",
   "Decidable.casesOn",
   "Decidable",
   "Not",
   "instOfNatNat",
   "Nat",
   "Nat.decEq",
   "Int",
   "Int.neg",
   "Eq"],
  "name": "FltRegular.CaseI.f1k₂._cstage1",
  "constType": "ℤ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "Bool.decEq", "Bool"],
  "name": "instDecidableEqBool",
  "constType": "DecidableEq Bool",
  "constCategory": "Definition"},
 {"references": ["NonUnitalNonAssocSemiring", "NonUnitalNonAssocCommSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → NonUnitalNonAssocSemiring α",
  "constCategory": "Definition"},
 {"references": ["Sub", "Int", "Int.sub", "Sub.mk"],
  "name": "Int.instSub",
  "constType": "Sub ℤ",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.MacroM",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "EStateM.instMonad",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "List.nil",
   "Bind.bind",
   "Nat",
   "Lean.Name.anonymous",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "instMonadExceptOfMonadExceptOf",
   "Lean.Syntax.atom",
   "ReaderT.instMonadExceptOf",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "EStateM.instMonadExceptOfOfBacktrackable",
   "Lean.MacroScope",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "ReaderT.instApplicativeOfMonad",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkNum",
   "letFun",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "ReaderT.instMonad",
   "Lean.Name"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termR_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CommSemiring",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": ["Bool"],
  "name": "Bool.true",
  "constType": "Bool",
  "constCategory": "Other"},
 {"references":
  ["Eq.ndrec", "Ring.toNeg", "Ring", "Eq.refl", "Neg.neg", "Eq.symm", "Eq"],
  "name": "Mathlib.Tactic.Ring.neg_congr",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a a' b : R}, a = a' → -a' = b → -a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "One",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "HMul.hMul",
   "Semigroup.mul_assoc",
   "Semigroup",
   "Eq"],
  "name": "mul_assoc",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * b * c = a * (b * c)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddSemigroup.toAdd",
   "AddGroupWithOne.toIntCast",
   "instHAdd",
   "Mathlib.Meta.NormNum.isInt_add.match_1",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.cast_add",
   "Int.instAdd",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "AddMonoid.toAddSemigroup",
   "Mathlib.Meta.NormNum.IsInt.mk",
   "Int.cast",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Int.add",
   "Eq.symm",
   "Int"],
  "name": "Mathlib.Meta.NormNum.isInt_add",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {f : α → α → α} {a b : α} {a' b' c : ℤ},\n  f = HAdd.hAdd →\n    Mathlib.Meta.NormNum.IsInt a a' →\n      Mathlib.Meta.NormNum.IsInt b b' → a'.add b' = c → Mathlib.Meta.NormNum.IsInt (f a b) c",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Omega.Int.sub_congr",
   "OfNat.ofNat",
   "Lean.Omega.LinearCombo.eval",
   "Lean.Omega.Int.ofNat_sub_dichotomy",
   "HAdd.hAdd",
   "FltRegular.CaseI.AuxLemmas._auxLemma.2",
   "Lean.Omega.LinearCombo.coordinate_eval_0",
   "le_of_le_of_eq",
   "And.left",
   "implies_congr",
   "instLTNat",
   "instDecidableEqNat",
   "Int.instAdd",
   "ite",
   "Eq",
   "Decidable.decide",
   "Lean.Omega.Coeffs.ofList",
   "Eq.mpr",
   "And.right",
   "Nat.Prime",
   "Nat.cast",
   "Option.none",
   "Bool.true",
   "Nat",
   "Ring.toSubtractionMonoid",
   "Int.instSub",
   "Lean.Omega.tidy_sat",
   "instOfNat",
   "Eq.trans",
   "Lean.Omega.LinearCombo",
   "Fin.mk",
   "instDecidableEqBool",
   "instHSub",
   "Ne",
   "Nat.Prime.pos",
   "Or",
   "Fin.val",
   "Lean.Omega.LinearCombo.coordinate",
   "Int.instRing",
   "Or.casesOn",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Lean.Omega.LinearCombo.instAdd",
   "Lean.Omega.combo_sat'",
   "FltRegular.CaseI.f0k₁",
   "instDecidableFalse",
   "And",
   "False.elim",
   "of_eq_true",
   "LT.lt",
   "Eq.mp",
   "instNatAtLeastTwo",
   "Not",
   "Nat.instCharZero",
   "congrArg",
   "Int",
   "Int.instLEInt",
   "Fin",
   "Exists",
   "FltRegular.CaseI.two_lt",
   "instSubNat",
   "Subtype.val",
   "Lean.Omega.LinearCombo.coordinate_eval_1",
   "of_decide_eq_true",
   "Eq.refl",
   "Lean.Omega.Int.ofNat_congr",
   "Exists.intro",
   "Int.sub_nonneg_of_le",
   "True",
   "Lean.Omega.LinearCombo.sub_eval",
   "Lean.Omega.Int.ofNat_le_of_le",
   "Zero.toOfNat0",
   "Lean.Omega.Constraint.addInequality_sat",
   "instLENat",
   "Nat.pred",
   "Lean.Omega.Constraint.mk",
   "Lean.Omega.Constraint.addEquality_sat",
   "instOfNatNat",
   "Option.some",
   "Int.instNegInt",
   "Nat.instAddCommMonoidWithOne",
   "List.nil",
   "FltRegular.CaseI.AuxLemmas._auxLemma.4",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Lean.Omega.Int.ofNat_lt_of_lt",
   "Int.sub_eq_zero_of_eq",
   "id",
   "eq_self",
   "Lean.Omega.Constraint.not_sat'_of_isImpossible",
   "List.cons",
   "False",
   "instHAdd",
   "Lean.Omega.Constraint.isImpossible",
   "HSub.hSub",
   "Neg.neg",
   "Lean.Omega.LinearCombo.mk",
   "Int.add_one_le_of_lt",
   "SubNegZeroMonoid.toNegZeroClass",
   "Nat.pred_eq_sub_one",
   "FltRegular.CaseI.AuxLemmas._auxLemma.3",
   "LE.le",
   "ite_congr",
   "Lean.Omega.LinearCombo.add_eval",
   "Lean.Omega.Constraint.combine_sat'",
   "instNatCastInt",
   "Lean.Omega.Int.add_congr",
   "letFun",
   "Bool",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Lean.Omega.LinearCombo.instSub",
   "Subtype.mk"],
  "name": "FltRegular.CaseI.auxf0k₁",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p), 5 ≤ p → ∀ (b : ℤ), ∃ i, FltRegular.CaseI.f0k₁ b p ↑i = 0",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_24"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_25._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["EmptyCollection"],
  "name": "EmptyCollection.emptyCollection",
  "constType": "{α : Type u} → [self : EmptyCollection α] → α",
  "constCategory": "Definition"},
 {"references": ["Add", "Distrib"],
  "name": "Distrib.toAdd",
  "constType": "{R : Type u_1} → [self : Distrib R] → Add R",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.ParserDescr.symbol",
   "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_9"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_10._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Iff.rfl",
   "AddGroupWithOne.toIntCast",
   "AddGroup.toSubtractionMonoid",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Iff",
   "Nat.cast",
   "Ring.toIntCast",
   "Int.modEq_zero_iff_dvd",
   "CommSemiring.toCommMonoidWithZero",
   "Nat",
   "Eq.symm",
   "instOfNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Ring.toAddGroupWithOne",
   "Int.instDvd",
   "Int.ModEq",
   "Dvd.dvd",
   "SubNegZeroMonoid.toNegZeroClass",
   "ZMod",
   "Int.cast_zero",
   "CommRing.toCommSemiring",
   "instNatCastInt",
   "Int.cast",
   "propext",
   "CommRing.toRing",
   "congrArg",
   "NegZeroClass.toZero",
   "Int",
   "ZMod.intCast_eq_intCast_iff",
   "ZMod.commRing"],
  "name": "ZMod.intCast_zmod_eq_zero_iff_dvd",
  "constType": "∀ (a : ℤ) (b : ℕ), ↑a = 0 ↔ ↑b ∣ a",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "OrderedCommSemiring"],
  "name": "OrderedCommSemiring.toOrderedSemiring",
  "constType":
  "{α : Type u} → [self : OrderedCommSemiring α] → OrderedSemiring α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_12._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["MonoidHom.comp_assoc",
   "Monoid",
   "Monoid.mk",
   "MulOneClass",
   "Monoid.End.instMul",
   "Nat.iterate",
   "One.mk",
   "MonoidHom.comp_id",
   "Monoid.End.instFunLike",
   "MonoidHom.comp",
   "npowRec",
   "Monoid.End.inst.proof_2",
   "MonoidHom.id_comp",
   "Monoid.End.inst.proof_1",
   "Monoid.End.instOne",
   "MonoidHom.copy",
   "MonoidHom.id",
   "DFunLike.coe",
   "Nat",
   "Monoid.End",
   "Semigroup.mk",
   "Monoid.End.inst.proof_3",
   "Mul.mk"],
  "name": "Monoid.End.inst",
  "constType":
  "(M : Type u_4) → [inst : MulOneClass M] → Monoid (Monoid.End M)",
  "constCategory": "Definition"},
 {"references": ["StrictOrderedSemiring", "PartialOrder"],
  "name": "StrictOrderedSemiring.toPartialOrder",
  "constType":
  "{α : Type u} → [self : StrictOrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne"],
  "name": "CharZero",
  "constType": "(R : Type u_1) → [inst : AddMonoidWithOne R] → Prop",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node2",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.num",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references": ["CancelCommMonoidWithZero"],
  "name": "UniqueFactorizationMonoid",
  "constType": "(α : Type u_2) → [inst : CancelCommMonoidWithZero α] → Prop",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "Membership.mem",
   "SetLike.instPartialOrder.proof_1",
   "PartialOrder.toPreorder",
   "PartialOrder.mk",
   "Lattice.toSemilatticeInf",
   "Set",
   "SemilatticeInf.toPartialOrder",
   "SetLike.instMembership",
   "PartialOrder",
   "CoheytingAlgebra.toGeneralizedCoheytingAlgebra",
   "Preorder.mk",
   "BooleanAlgebra.toBiheytingAlgebra",
   "SetLike",
   "SetLike.instPartialOrder.proof_3",
   "Set.instBooleanAlgebraSet",
   "Preorder.toLT",
   "SetLike.instPartialOrder.proof_2",
   "PartialOrder.lift",
   "PartialOrder.le_antisymm",
   "GeneralizedCoheytingAlgebra.toLattice",
   "BiheytingAlgebra.toCoheytingAlgebra",
   "SetLike.coe",
   "SetLike.coe_injective"],
  "name": "SetLike.instPartialOrder",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → PartialOrder A",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.em",
   "Or",
   "Or.inr",
   "Eq.refl",
   "Or.casesOn",
   "Eq",
   "ite",
   "Eq.mpr",
   "if_pos",
   "Or.inl",
   "Eq.ndrec",
   "Decidable",
   "Not",
   "congrArg",
   "Eq.symm",
   "if_neg",
   "id"],
  "name": "ite_congr",
  "constType":
  "∀ {α : Sort u_1} {b c : Prop} {x y u v : α} {s : Decidable b} [inst : Decidable c],\n  b = c → (c → x = u) → (¬c → y = v) → (if b then x else y) = if c then u else v",
  "constCategory": "Theorem"},
 {"references":
  ["Finsupp",
   "Finset.instHasSubset",
   "HasSubset.Subset",
   "AddCommMonoid.toAddMonoid",
   "MvPolynomial.Finsupp.support_mapDomain",
   "True",
   "Eq",
   "Finset.map",
   "eq_true",
   "Finsupp.mapDomain",
   "AddMonoid.toZero",
   "Finset",
   "Function.Embedding",
   "DFunLike.coe",
   "Function.instFunLikeEmbedding",
   "AddCommMonoid",
   "Finsupp.support"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {M : Type u_3} [inst : AddCommMonoid M] (f : α ↪ β) (v : α →₀ M),\n  ((Finsupp.mapDomain (⇑f) v).support ⊆ Finset.map f v.support) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.gcd_dvd_left",
   "Int.instDvd",
   "Int.ofNat_dvd",
   "Dvd.dvd",
   "Int.natAbs_dvd_self",
   "Int.gcd",
   "Int.dvd_trans",
   "Nat.cast",
   "instNatCastInt",
   "propext",
   "letFun",
   "Eq.mp",
   "Nat.gcd",
   "Nat.instDvd",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Int",
   "Int.natAbs"],
  "name": "Int.gcd_dvd_left",
  "constType": "∀ {a b : ℤ}, ↑(a.gcd b) ∣ a",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Ideal.dvd_iff_le",
   "PartialOrder.toPreorder",
   "Set",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set.instHasSubset",
   "Submodule.completeLattice",
   "Ideal.span",
   "CommSemiring.toNonUnitalCommSemiring",
   "semigroupDvd",
   "Ideal.instIdemCommSemiring",
   "CommRing",
   "Preorder.toLE",
   "SetLike.instMembership",
   "Set.instSingletonSet",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Iff.trans",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Semiring.toModule",
   "Membership.mem",
   "Set.singleton_subset_iff",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "HasSubset.Subset",
   "Dvd.dvd",
   "LE.le",
   "SemigroupWithZero.toSemigroup",
   "IsDedekindDomain",
   "CommRing.toCommSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Singleton.singleton",
   "Ideal.span_le",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal",
   "IdemCommSemiring.toCommSemiring",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Ideal.dvd_span_singleton",
  "constType":
  "∀ {A : Type u_2} [inst : CommRing A] [inst_1 : IsDedekindDomain A] {I : Ideal A} {x : A}, I ∣ Ideal.span {x} ↔ x ∈ I",
  "constCategory": "Theorem"},
 {"references":
  ["Polynomial.ofFinsupp",
   "AddMonoidAlgebra.semiring",
   "instHSMul",
   "Semiring",
   "Polynomial.coeff",
   "Semiring.toMonoidWithZero",
   "SMulZeroClass",
   "Nat.instAddMonoid",
   "AddMonoidAlgebra.smulZeroClass",
   "Eq",
   "SMulZeroClass.toSMul",
   "AddMonoidAlgebra",
   "Polynomial",
   "Polynomial.zero",
   "Polynomial.smulZeroClass",
   "Finsupp.smul_apply",
   "HSMul.hSMul",
   "MonoidWithZero.toZero",
   "Nat",
   "Polynomial.casesOn",
   "id"],
  "name": "Polynomial.coeff_smul",
  "constType":
  "∀ {R : Type u} {S : Type v} [inst : Semiring R] [inst_1 : SMulZeroClass S R] (r : S) (p : Polynomial R) (n : ℕ),\n  (r • p).coeff n = r • p.coeff n",
  "constCategory": "Theorem"},
 {"references": ["PUnit"],
  "name": "Unit",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "Rat.commRing",
   "CommSemiring",
   "Rat"],
  "name": "Rat.commSemiring",
  "constType": "CommSemiring ℚ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "congr_arg",
   "Subtype.val",
   "Subtype.ext",
   "Subtype",
   "Eq"],
  "name": "Subtype.ext_iff",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a1 a2 : { x // p x }}, a1 = a2 ↔ ↑a1 = ↑a2",
  "constCategory": "Theorem"},
 {"references": ["Nat.add", "Add", "Nat", "Add.mk"],
  "name": "instAddNat",
  "constType": "Add ℕ",
  "constCategory": "Definition"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "instNatCastInt",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "AddGroupWithOne",
   "Nat",
   "Int",
   "Eq",
   "AddGroupWithOne.intCast_ofNat"],
  "name": "Int.cast_natCast",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℕ), ↑↑n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_one",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "AddGroupWithOne.toIntCast",
   "Fin.ext",
   "Fin.is_lt",
   "ZMod.val_cast_of_lt",
   "ZMod.val_natCast",
   "True",
   "Eq",
   "Semiring.toNatCast",
   "Eq.mpr",
   "Nat.Prime",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Nat.Prime.one_lt'",
   "ZMod.val",
   "Ring.toIntCast",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "instOfNat",
   "Fin.mk",
   "Fin.isLt",
   "id",
   "eq_self",
   "Nat.Prime.one_lt",
   "Int.cast_natCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "ZMod.val_one",
   "Ring.toAddGroupWithOne",
   "Fin.val",
   "Int.ModEq",
   "One.toOfNat1",
   "ZMod",
   "Semiring.toOne",
   "Fin.val_mk",
   "CommRing.toCommSemiring",
   "instHMod",
   "Fact.mk",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "instNatCastInt",
   "propext",
   "Int.cast",
   "Eq.mp",
   "letFun",
   "HMod.hMod",
   "CommRing.toRing",
   "congrArg",
   "Nat.instMod",
   "Int",
   "ZMod.intCast_eq_intCast_iff",
   "Fin",
   "ZMod.commRing"],
  "name": "FltRegular.CaseI.aux_cong0k₂",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p) {k : Fin p}, ↑↑k ≡ 1 [ZMOD ↑p] → k = ⟨1, ⋯⟩",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "sub_self",
   "HSub.hSub",
   "eq_of_sub_eq_zero",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Iff.mpr",
   "Eq",
   "Zero.toOfNat0",
   "Iff.intro",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "congrArg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_eq_zero_of_eq",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, a = b → a - b = 0",
  "constCategory": "Theorem"},
 {"references": ["eq_true", "rfl", "True", "Eq"],
  "name": "eq_self",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "FermatLastTheoremFor",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Int.instSemiring",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Int.instNormedCommRing",
   "MulZeroClass.zero_mul",
   "fermatLastTheoremThree",
   "MulZeroClass.mul_zero",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "True",
   "Int.instAdd",
   "Eq",
   "FermatLastTheoremWith",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Eq.rec",
   "Monoid.toNatPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Nat",
   "instOfNat",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "eq_self",
   "HPow.hPow",
   "Ne",
   "False",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "Int.instHPowNat",
   "instHAdd",
   "Int.instMul",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "NormedCommRing.toSeminormedCommRing",
   "False.elim",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "fermatLastTheoremFor_iff_int",
   "letFun",
   "Eq.mp",
   "HMul.hMul",
   "not_true_eq_false",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Not",
   "congrArg",
   "Int"],
  "name": "FltRegular.MayAssume.p_ne_three",
  "constType":
  "∀ {a b c : ℤ} {n : ℕ}, a * b * c ≠ 0 → a ^ n + b ^ n = c ^ n → n ≠ 3",
  "constCategory": "Theorem"},
 {"references": ["Top", "OrderTop", "LE"],
  "name": "OrderTop.toTop",
  "constType": "{α : Type u} → [inst : LE α] → [self : OrderTop α] → Top α",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_27",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_36._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveNeg",
   "neg_inj",
   "InvolutiveNeg.toNeg",
   "propext",
   "Neg.neg",
   "Eq"],
  "name": "Mathlib.Algebra.Group.Basic._auxLemma.18",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, (-a = -b) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_5",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_30"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_31._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.mem_image",
   "Set.instMembership",
   "Set.image",
   "Eq"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.3",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["instHAdd", "HAdd.hAdd", "Int.instNegInt", "Neg.neg", "Int", "Int.instAdd"],
  "name": "Int.sub",
  "constType": "ℤ → ℤ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Ne",
   "Iff",
   "congr_arg",
   "Function.Injective",
   "Function.Injective.ne",
   "mt",
   "Eq"],
  "name": "Function.Injective.ne_iff",
  "constType":
  "∀ {α : Sort u_1} {β : Sort u_2} {f : α → β}, Function.Injective f → ∀ {x y : α}, f x ≠ f y ↔ x ≠ y",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "MulZeroOneClass.toMulOneClass",
   "CommRing.toNonUnitalCommRing",
   "IsDomain",
   "Module.Finite",
   "Semiring.toMonoidWithZero",
   "FractionRing.field",
   "Ideal.span",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "nonZeroDivisors",
   "Semiring.toNonAssocSemiring",
   "OreLocalization.oreSetComm",
   "FractionRing.liftAlgebra",
   "Algebra",
   "DFunLike.coe",
   "CommSemiring.toCommMonoidWithZero",
   "IsIntegrallyClosed",
   "Set.image",
   "Algebra.toSMul",
   "Semiring.toModule",
   "Algebra.intNorm",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "OreLocalization.instCommRing",
   "NoZeroSMulDivisors",
   "Algebra.toModule",
   "OreLocalization.instRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MonoidHom",
   "OreLocalization.instAlgebra",
   "CommRing.toCommSemiring",
   "CommRing.toCommMonoid",
   "FractionRing",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "FractionRing.instNoZeroSMulDivisors",
   "MonoidHom.instFunLike",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.IsSeparable",
   "Ideal",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Ideal.spanIntNorm",
  "constType":
  "(R : Type u_1) →\n  [inst : CommRing R] →\n    {S : Type u_2} →\n      [inst_1 : CommRing S] →\n        [inst_2 : Algebra R S] →\n          [inst_3 : IsIntegrallyClosed R] →\n            [inst_4 : IsDomain R] →\n              [inst_5 : IsDomain S] →\n                [inst_6 : NoZeroSMulDivisors R S] →\n                  [hRS : Module.Finite R S] →\n                    [inst_7 : IsIntegrallyClosed S] →\n                      [inst_8 : Algebra.IsSeparable (FractionRing R) (FractionRing S)] → Ideal S → Ideal R",
  "constCategory": "Definition"},
 {"references":
  ["OneHom.toFun",
   "FunLike",
   "MonoidHom.instFunLike.proof_1",
   "MonoidHom.toOneHom",
   "MulOneClass",
   "MulOneClass.toOne",
   "MonoidHom",
   "DFunLike.mk"],
  "name": "MonoidHom.instFunLike",
  "constType":
  "{M : Type u_4} → {N : Type u_5} → [inst : MulOneClass M] → [inst_1 : MulOneClass N] → FunLike (M →* N) M N",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_toFinset",
   "DecidableEq",
   "propext",
   "Finset",
   "Multiset",
   "Multiset.toFinset",
   "Eq.symm",
   "Eq",
   "Multiset.instMembership",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.9",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, (a ∈ s) = (a ∈ s.toFinset)",
  "constCategory": "Theorem"},
 {"references": ["Ring", "CommRing"],
  "name": "CommRing.toRing",
  "constType": "{α : Type u} → [self : CommRing α] → Ring α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Field.toNontrivial",
   "EuclideanDomain.mk",
   "Semifield.toCommGroupWithZero",
   "Field.toEuclideanDomain.proof_3",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Eq",
   "Field.toCommRing",
   "Zero.toOfNat0",
   "Field.toEuclideanDomain.proof_4",
   "Field",
   "Ring.toSub",
   "Field.toEuclideanDomain.proof_1",
   "HDiv.hDiv",
   "instHSub",
   "Ne",
   "NonUnitalNonAssocRing.toMul",
   "instHDiv",
   "HSub.hSub",
   "Field.toSemifield",
   "CommGroupWithZero.toCommMonoidWithZero",
   "instHMul",
   "And",
   "Field.toEuclideanDomain.proof_2",
   "HMul.hMul",
   "Field.toDiv",
   "EuclideanDomain",
   "Field.toDivisionRing",
   "Field.toEuclideanDomain.proof_5"],
  "name": "Field.toEuclideanDomain",
  "constType": "{K : Type u_1} → [inst : Field K] → EuclideanDomain K",
  "constCategory": "Definition"},
 {"references": ["Int", "IntCast.intCast", "IntCast"],
  "name": "Int.cast",
  "constType": "{R : Type u} → [inst : IntCast R] → ℤ → R",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Nat.cast_zero",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Mathlib.Tactic.Ring.cast_zero.match_1",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "CommSemiring",
   "AddMonoid.toZero",
   "CommSemiring.toCommMonoidWithZero",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.cast_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a : R}, Mathlib.Meta.NormNum.IsNat a 0 → a = 0",
  "constCategory": "Theorem"},
 {"references": ["False", "propext", "Not", "not_true", "True", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclotomicUnits._auxLemma.2",
  "constType": "(¬True) = False",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toAddMonoidWithOne",
   "AddGroupWithOne.toIntCast",
   "AddGroup.toSubtractionMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "Nat.cast_zero",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "AddGroupWithOne.intCast_ofNat",
   "Zero.toOfNat0",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "instNatCastInt",
   "Int.cast",
   "AddGroupWithOne",
   "instOfNatNat",
   "Nat",
   "NegZeroClass.toZero",
   "instOfNat",
   "Eq.trans",
   "Int",
   "IntCast.intCast",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Int.cast_zero",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R], ↑0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["OrderedSemiring",
   "Nat.instStrictOrderedSemiring",
   "StrictOrderedSemiring.toOrderedSemiring'",
   "Nat",
   "Nat.decLe"],
  "name": "Nat.instOrderedSemiring",
  "constType": "OrderedSemiring ℕ",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.right_distrib",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "AddCommMonoid.toAddMonoid",
   "Distrib.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Distrib",
   "NonUnitalNonAssocSemiring.left_distrib"],
  "name": "NonUnitalNonAssocSemiring.toDistrib",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Distrib α",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Monoid.toSemigroup",
   "Ne",
   "MulOneClass.toMul",
   "Monoid",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Dvd.dvd.mul_right",
   "Dvd.dvd",
   "pow_succ'",
   "semigroupDvd",
   "Monoid.toMulOneClass",
   "rfl",
   "Eq",
   "dvd_pow.match_1",
   "instHMul",
   "Eq.mpr",
   "False.elim",
   "instHPow",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "id"],
  "name": "dvd_pow",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] {a b : α}, a ∣ b → ∀ {n : ℕ}, n ≠ 0 → a ∣ b ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_34",
   "_obj",
   "Lean.Name.num._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_35._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Int.lt", "LT", "LT.mk", "Int"],
  "name": "Int.instLTInt",
  "constType": "LT ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Int.lcm",
   "Nat.cast",
   "GCDMonoid",
   "instNatCastInt",
   "Int.gcd_dvd_right",
   "Int.instGCDMonoid.proof_2",
   "Int.dvd_gcd",
   "Int.gcd_dvd_left",
   "GCDMonoid.mk",
   "Int.instGCDMonoid.proof_3",
   "Int.instCancelCommMonoidWithZero",
   "Int",
   "Int.instGCDMonoid.proof_1",
   "Int.gcd"],
  "name": "Int.instGCDMonoid",
  "constType": "GCDMonoid ℤ",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "instHPow",
   "Monoid.toNatPow",
   "Monoid.npow_zero",
   "One.toOfNat1",
   "instOfNatNat",
   "Nat",
   "Eq"],
  "name": "pow_zero",
  "constType": "∀ {M : Type u_2} [inst : Monoid M] (a : M), a ^ 0 = 1",
  "constCategory": "Theorem"},
 {"references":
  ["tryCatchThe",
   "ReaderT",
   "liftM",
   "instMonadLiftT",
   "instMonadExceptOfMonadExceptOf",
   "MonadExcept.throw",
   "ReaderT.instMonadLift",
   "MonadExceptOf.mk",
   "MonadExceptOf",
   "instMonadLiftTOfMonadLift"],
  "name": "ReaderT.instMonadExceptOf",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → (ε : Type u_1) → [inst : MonadExceptOf ε m] → MonadExceptOf ε (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ideal.Quotient.commRing",
   "CommSemiring.toSemiring",
   "RingHom",
   "OfNat.ofNat",
   "RingHom.instFunLike",
   "SetLike.instMembership",
   "Submodule.Quotient.instZeroQuotient",
   "CommRing",
   "Eq",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Submodule.Quotient.mk_eq_zero",
   "CommRing.toRing",
   "Ideal.Quotient.mk",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "HasQuotient.Quotient",
   "DFunLike.coe",
   "Ideal",
   "Ideal.instHasQuotient",
   "Submodule.setLike",
   "Semiring.toModule"],
  "name": "Ideal.Quotient.eq_zero_iff_mem",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] {a : R} {I : Ideal R}, (Ideal.Quotient.mk I) a = 0 ↔ a ∈ I",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro",
   "exists_prop.match_2",
   "And",
   "Exists",
   "Iff",
   "Exists.intro",
   "And.intro",
   "exists_prop.match_1"],
  "name": "exists_prop",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) ↔ a ∧ b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "And",
   "DecidableEq",
   "propext",
   "Finset",
   "Finset.mem_sdiff",
   "Not",
   "SDiff.sdiff",
   "Finset.instSDiff",
   "Eq",
   "Finset.instMembership"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.116",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, (a ∈ s \\ t) = (a ∈ s ∧ a ∉ t)",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Exists",
   "Dvd.mk",
   "Int.instMul",
   "HMul.hMul",
   "Int",
   "Dvd",
   "Eq"],
  "name": "Int.instDvd",
  "constType": "Dvd ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_10"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Omega.LinearCombo",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Nat.rawCast",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "True",
   "Eq",
   "Semiring.toOne",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "CommSemiring",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Nat.cast_one"],
  "name": "Mathlib.Tactic.RingNF.nat_rawCast_1",
  "constType": "∀ {R : Type u_1} [inst : CommSemiring R], Nat.rawCast 1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Preorder.le_trans", "Preorder", "LE.le", "Preorder.toLE"],
  "name": "le_trans",
  "constType":
  "∀ {α : Type u} [inst : Preorder α] {a b c : α}, a ≤ b → b ≤ c → a ≤ c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "SemigroupWithZero.toSemigroup",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "Finset.dvd_gcd_iff",
   "MonoidWithZero.toSemigroupWithZero",
   "Finset",
   "Dvd.dvd",
   "semigroupDvd",
   "NormalizedGCDMonoid",
   "Finset.gcd",
   "Iff.mpr",
   "CancelCommMonoidWithZero",
   "Finset.instMembership",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "Finset.dvd_gcd",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} [inst : CancelCommMonoidWithZero α] [inst_1 : NormalizedGCDMonoid α] {s : Finset β}\n  {f : β → α} {a : α}, (∀ b ∈ s, a ∣ f b) → a ∣ s.gcd f",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CanonicallyLinearOrderedAddCommMonoid",
  "constType": "Type u_1 → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "Finset.biUnion",
   "DecidableEq",
   "propext",
   "Finset.mem_biUnion",
   "Finset",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {t : α → Finset β} [inst : DecidableEq β] {b : β},\n  (b ∈ s.biUnion t) = ∃ a ∈ s, b ∈ t a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Name.str._override",
   "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_1",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_2"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Set.preimage",
   "propext",
   "Set",
   "Set.mem_preimage",
   "Set.instMembership",
   "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.10",
  "constType":
  "∀ {α : Type u} {β : Type v} {f : α → β} {s : Set β} {a : α}, (a ∈ f ⁻¹' s) = (f a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Units", "Monoid", "Units.val", "IsUnit", "Exists.intro", "rfl", "Eq"],
  "name": "Units.isUnit",
  "constType": "∀ {M : Type u_1} [inst : Monoid M] (u : Mˣ), IsUnit ↑u",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_one",
   "OfNat.ofNat",
   "DivisionRing.toRing",
   "AddGroupWithOne.toSub",
   "AddGroupWithOne.toIntCast",
   "AddGroup.toSubtractionMonoid",
   "NeZero.one",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "ZMod.instField",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "Nat.Prime",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Nat.Prime.one_lt'",
   "Ring.toIntCast",
   "Nat",
   "Eq.symm",
   "Int.instSub",
   "Eq.trans",
   "instOfNat",
   "ZMod.nontrivial",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "instHSub",
   "Ne",
   "Int.cast_natCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "Ring.toAddGroupWithOne",
   "Fin.val",
   "Int.ModEq",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Int.cast_sub",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "ZMod",
   "DivisionSemiring.toSemiring",
   "False.elim",
   "AddMonoidWithOne.toOne",
   "instNatCastInt",
   "Fact.mk",
   "propext",
   "Int.cast",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "Eq.mp",
   "CommRing.toRing",
   "congr",
   "Semifield.toDivisionSemiring",
   "Ring.toAddCommGroup",
   "sub_eq_zero",
   "sub_sub_cancel",
   "congrArg",
   "Field.toDivisionRing",
   "NegZeroClass.toZero",
   "Int",
   "ZMod.intCast_eq_intCast_iff",
   "Fin",
   "ZMod.commRing"],
  "name": "FltRegular.CaseI.auxk₁k₂",
  "constType":
  "∀ {p : ℕ} {k₁ k₂ : Fin p}, Nat.Prime p → ↑↑k₂ ≡ ↑↑k₁ - 1 [ZMOD ↑p] → ↑k₁ ≠ ↑k₂",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "neg_eq_zero",
   "propext",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "FltRegular.MayAssume.Lemmas._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, (-a = 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_3",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_1"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["One", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toOne",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → One α",
  "constCategory": "Definition"},
 {"references":
  ["Units.instMul",
   "instHMul",
   "Units",
   "MulOneClass.toMul",
   "Monoid",
   "Units.val",
   "HMul.hMul",
   "Monoid.toMulOneClass",
   "rfl",
   "Eq"],
  "name": "Units.val_mul",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a b : αˣ), ↑(a * b) = ↑a * ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "propext",
   "Multiset",
   "Finset",
   "Finset.val",
   "Finset.mem_val",
   "Eq",
   "Finset.instMembership",
   "Multiset.instMembership"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.20",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ s.val) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["PNat.val",
   "OfNat.ofNat",
   "Function.Injective",
   "LT.lt",
   "instOfNatNat",
   "Nat",
   "Subtype.coe_injective",
   "instLTNat",
   "PNat"],
  "name": "PNat.coe_injective",
  "constType": "Function.Injective fun a => ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_one",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "MonoidWithZero.toMonoid",
   "Nat.recAux",
   "instHPow",
   "Ring.toIntCast",
   "Ring",
   "Monoid.toNatPow",
   "Int.cast_mul",
   "instOfNatNat",
   "Nat",
   "Eq.trans",
   "HPow.hPow",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Int.instHPowNat",
   "instAddNat",
   "instHAdd",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Int.instMonoid",
   "Ring.toSemiring",
   "Monoid.toMulOneClass",
   "pow_zero",
   "instHMul",
   "NonAssocRing.toIntCast",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "HMul.hMul",
   "congr",
   "pow_succ",
   "congrArg",
   "Int"],
  "name": "Int.cast_pow",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] (n : ℤ) (m : ℕ), ↑(n ^ m) = ↑n ^ m",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "AddGroupWithOne.toIntCast",
   "Nat.rawCast",
   "Int.rawCast",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "True",
   "Eq",
   "Ring.toNeg",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "of_eq_true",
   "Int.cast_negOfNat",
   "Int.cast",
   "Ring",
   "Nat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.RingNF.int_rawCast_neg",
  "constType":
  "∀ {n : ℕ} {R : Type u_2} [inst : Ring R], (Int.negOfNat n).rawCast = -n.rawCast",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "Units",
   "Exists",
   "MulOneClass.toMul",
   "Monoid",
   "Units.val",
   "HMul.hMul",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "Associated",
  "constType": "{α : Type u_1} → [inst : Monoid α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Syntax.isNodeOf", "Bool", "Lean.nullKind", "Nat", "Lean.Syntax"],
  "name": "Lean.Syntax.matchesNull",
  "constType": "Lean.Syntax → ℕ → Bool",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat", "LT.lt", "instOfNatNat", "Nat", "instLTNat", "Subtype"],
  "name": "PNat",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references": ["Iff.intro", "And", "propext", "And.intro", "And.left", "Eq"],
  "name": "and_self",
  "constType": "∀ (p : Prop), (p ∧ p) = p",
  "constCategory": "Theorem"},
 {"references":
  ["map_natCast'",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "RingHomClass",
   "MulOneClass.toOne",
   "map_one",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring",
   "Eq",
   "RingHomClass.toAddMonoidHomClass",
   "FunLike",
   "RingHomClass.toMonoidHomClass",
   "Nat.cast",
   "MonoidHomClass.toOneHomClass",
   "NonAssocSemiring.toNatCast",
   "Nat",
   "DFunLike.coe"],
  "name": "map_natCast",
  "constType":
  "∀ {R : Type u_3} {S : Type u_4} {F : Type u_5} [inst : NonAssocSemiring R] [inst_1 : NonAssocSemiring S]\n  [inst_2 : FunLike F R S] [inst_3 : RingHomClass F R S] (f : F) (n : ℕ), f ↑n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHSub",
   "SubNegMonoid.toSub",
   "OfNat.ofNat",
   "AddGroup",
   "propext",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_zero",
   "SubNegZeroMonoid.toNegZeroClass",
   "NegZeroClass.toZero",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.5",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, (a - b = 0) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.ndrec",
  "constType":
  "{α : Sort u2} → {a : α} → {motive : α → Sort u1} → motive a → {b : α} → a = b → motive b",
  "constCategory": "Definition"},
 {"references":
  ["Int.decLe",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "Units.instOne",
   "NormalizationMonoid",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "CommRing.toNonUnitalCommRing",
   "Int.normalizationMonoid.proof_2",
   "One.toOfNat1",
   "Neg.neg",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Int.normalizationMonoid.proof_3",
   "Int.instCancelCommMonoidWithZero",
   "LE.le",
   "ite",
   "Units",
   "Int.instCommRing",
   "Units.instNeg",
   "MonoidWithZero.toMonoid",
   "NormalizationMonoid.mk",
   "Int",
   "instOfNat",
   "Int.instLEInt",
   "Int.normalizationMonoid.proof_1",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "Int.normalizationMonoid",
  "constType": "NormalizationMonoid ℤ",
  "constCategory": "Definition"},
 {"references":
  ["instDecidableAnd.proof_2",
   "And",
   "instDecidableAnd.match_1",
   "Decidable.isFalse",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "And.intro",
   "instDecidableAnd.proof_1"],
  "name": "instDecidableAnd",
  "constType":
  "{p q : Prop} → [dp : Decidable p] → [dq : Decidable q] → Decidable (p ∧ q)",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Monoid",
   "Int.instCommMonoid",
   "CommMonoid.toMonoid",
   "Int"],
  "name": "Int.instMonoid",
  "constType": "Monoid ℤ",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "HPow.hPow",
   "CommSemiring.toSemiring",
   "MulOneClass.toMul",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "True",
   "Eq",
   "mul_pow",
   "instHMul",
   "pow_mul",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "MonoidWithZero.toMonoid",
   "of_eq_true",
   "instHPow",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "HMul.hMul",
   "Monoid.toNatPow",
   "CommSemiring.toCommMonoid",
   "CommMonoid.toMonoid",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.mul_pow",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₂ c₂ : R} {ea₁ b c₁ : ℕ} {xa₁ : R},\n  ea₁ * b = c₁ → a₂ ^ b = c₂ → (xa₁ ^ ea₁ * a₂) ^ b = xa₁ ^ c₁ * c₂",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CyclotomicField.instCharZero",
   "OfNat.ofNat",
   "Int.instDecidableEq",
   "Finset.instInsert",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "IsRegularPrime",
   "Ideal.span",
   "Exists.casesOn",
   "Insert.insert",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "instLTNat",
   "ClassGroup",
   "Int.instAdd",
   "Eq",
   "Finset.instMembership",
   "Nat.Prime",
   "IsRegularNumber.proof_1",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "IsRegularNumber.eq_1",
   "IsRegularPrime.eq_1",
   "Nat",
   "instOfNat",
   "NormedRing.toRing",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "CyclotomicField.classGroupFinite",
   "HPow.hPow",
   "Nat.Prime.pos",
   "Int.instDvd",
   "Int.instHPowNat",
   "NormedCommRing.toNormedRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Finset.instSingleton",
   "CyclotomicField",
   "NonUnitalNonAssocSemiring.toDistrib",
   "instHMul",
   "CommRing.toCommMonoid",
   "FltRegular.is_principal_aux",
   "NumberField.RingOfIntegers.instIsDomain",
   "IsRegularNumber.proof_2",
   "Int.cast",
   "LT.lt",
   "Eq.mp",
   "CommRing.toRing",
   "IsPrimitiveRoot.mem_nthRootsFinset",
   "Not",
   "Singleton.singleton",
   "Algebra.id",
   "congrArg",
   "Fact",
   "Ideal",
   "Int",
   "Exists",
   "CommRing.toNonUnitalCommRing",
   "Submodule.idemSemiring",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "instFactLtNatOfNatOfPrime_fltRegular",
   "Fact.out",
   "IsRegularNumber",
   "FltRegular.exists_ideal",
   "NeZero.pnat",
   "Finset.gcd",
   "PNat.val",
   "CyclotomicField.instField",
   "Set.instSingletonSet",
   "instLENat",
   "instHPow",
   "Finset",
   "Monoid.toNatPow",
   "instOfNatNat",
   "id",
   "NeZero.charZero",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Rat.instField",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "CyclotomicField.isCyclotomicExtension",
   "Int.instMul",
   "instHAdd",
   "Int.instNormalizedGCDMonoid",
   "Rat",
   "Fintype.card",
   "Dvd.dvd",
   "NormedField.toNormedCommRing",
   "Int.instCancelCommMonoidWithZero",
   "LE.le",
   "Rat.instCharZero",
   "Polynomial.nthRootsFinset",
   "Units",
   "CommRing.toCommSemiring",
   "instNatCastInt",
   "Units.val",
   "letFun",
   "Nat.Coprime",
   "HMul.hMul",
   "IdemSemiring.toSemiring",
   "NumberField.RingOfIntegers",
   "Rat.instNormedField",
   "Subtype.mk"],
  "name": "FltRegular.is_principal",
  "constType":
  "∀ {p : ℕ} [hpri : Fact (Nat.Prime p)] {a b c : ℤ} {ζ : NumberField.RingOfIntegers (CyclotomicField ⟨p, ⋯⟩ ℚ)},\n  IsRegularPrime p →\n    5 ≤ p →\n      {a, b, c}.gcd id = 1 →\n        ¬↑p ∣ a * b * c → a ^ p + b ^ p = c ^ p → IsPrimitiveRoot ζ p → ∃ u α, ↑u * α ^ p = ↑a + ζ * ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Fact.out",
   "One.toOfNat1",
   "instLTNat",
   "Nat.mod_eq_of_lt",
   "ZMod",
   "Eq",
   "Semiring.toOne",
   "CommRing.toCommSemiring",
   "Eq.mpr",
   "instHMod",
   "ZMod.val",
   "LT.lt",
   "HMod.hMod",
   "instOfNatNat",
   "ZMod.val_one_eq_one_mod",
   "Nat",
   "congrArg",
   "Fact",
   "Nat.instMod",
   "id",
   "ZMod.commRing"],
  "name": "ZMod.val_one",
  "constType": "∀ (n : ℕ) [inst : Fact (1 < n)], ZMod.val 1 = 1",
  "constCategory": "Theorem"},
 {"references": ["Bot"],
  "name": "Bot.bot",
  "constType": "{α : Type u_1} → [self : Bot α] → α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "inferInstance",
   "Nat.instCommSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Nat",
   "AddCommMonoidWithOne"],
  "name": "Nat.instAddCommMonoidWithOne",
  "constType": "AddCommMonoidWithOne ℕ",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "Option.some",
  "constType": "{α : Type u} → α → Option α",
  "constCategory": "Other"},
 {"references":
  ["QuotientGroup.instHasQuotientSubgroup",
   "Subgroup.Normal",
   "QuotientGroup.con",
   "Subgroup",
   "Group",
   "HasQuotient.Quotient",
   "Con.group"],
  "name": "QuotientGroup.Quotient.group",
  "constType":
  "{G : Type u} → [inst : Group G] → (N : Subgroup G) → [nN : N.Normal] → Group (G ⧸ N)",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "inv_pow",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "DivInvMonoid.Pow",
   "zpow_natCast",
   "DivInvMonoid.toMonoid",
   "DivInvMonoid.toInv",
   "Eq",
   "DivisionMonoid",
   "Eq.mpr",
   "Nat.cast",
   "instNatCastInt",
   "Int.negSucc",
   "instHPow",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "InvOneClass.toInv",
   "DivisionMonoid.toDivInvOneMonoid",
   "Int",
   "one_zpow.match_1",
   "zpow_negSucc",
   "id",
   "Inv.inv"],
  "name": "inv_zpow",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionMonoid α] (a : α) (n : ℤ), a⁻¹ ^ n = (a ^ n)⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Int.decLe",
   "OfNat.ofNat",
   "Lean.Omega.Coeffs.dot",
   "HAdd.hAdd",
   "GE.ge",
   "Eq.refl",
   "Lean.Omega.Coeffs",
   "True",
   "Int.instAdd",
   "Subsingleton.elim",
   "Eq",
   "Decidable.decide",
   "Lean.Omega.UpperBound.sat",
   "Eq.mpr",
   "Lean.Omega.Constraint.mk",
   "Option.none",
   "Eq.rec",
   "Bool.true",
   "Decidable",
   "Lean.Omega.LowerBound.sat",
   "Option.some",
   "Int.instNegInt",
   "Eq.symm",
   "Int.instSub",
   "instOfNat",
   "Eq.trans",
   "Lean.Omega.Constraint.lowerBound",
   "Int.zero_sub",
   "id",
   "instDecidableEqBool",
   "instHSub",
   "eq_self",
   "Int.sub_left_le_of_le_add",
   "decide_eq_true_eq",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "instDecidableAnd",
   "Lean.Omega.Constraint.upperBound",
   "and_true",
   "LE.le",
   "And",
   "Eq.ndrec",
   "congr",
   "Bool",
   "Lean.Omega.Constraint.sat'",
   "congrArg",
   "Int",
   "instSubsingletonDecidable",
   "Int.instLEInt"],
  "name": "Lean.Omega.Constraint.addInequality_sat",
  "constType":
  "∀ {c : ℤ} {x y : Lean.Omega.Coeffs}, c + x.dot y ≥ 0 → { lowerBound := some (-c), upperBound := none }.sat' x y = true",
  "constCategory": "Theorem"},
 {"references": ["DFunLike"],
  "name": "FunLike",
  "constType":
  "Sort u_1 → Sort u_2 → Sort u_3 → Sort (max (max (max 1 u_1) u_2) u_3)",
  "constCategory": "Definition"},
 {"references":
  ["Equiv",
   "Part.Dom",
   "PartENat.toWithTop",
   "Classical.propDecidable",
   "ENat",
   "PartENat",
   "Equiv.mk",
   "PartENat.withTopEquiv.proof_1",
   "PartENat.ofENat",
   "Nat",
   "PartENat.withTopEquiv.proof_2"],
  "name": "PartENat.withTopEquiv",
  "constType": "PartENat ≃ ℕ∞",
  "constCategory": "Definition"},
 {"references": ["Semiring"],
  "name": "Polynomial",
  "constType": "(R : Type u_1) → [inst : Semiring R] → Type u_1",
  "constCategory": "Other"},
 {"references":
  ["MulOneClass.toMul",
   "OfNat.ofNat",
   "div_eq_mul_inv",
   "GroupWithZero.toDivisionMonoid",
   "HAdd.hAdd",
   "Eq.refl",
   "DivInvMonoid.Pow",
   "Int.instAdd",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "instHPow",
   "Int.instNegInt",
   "HDiv.hDiv",
   "InvOneClass.toInv",
   "Int.instSub",
   "DivInvMonoid.toDiv",
   "id",
   "Int.sub_eq_add_neg",
   "instHSub",
   "HPow.hPow",
   "Ne",
   "instHDiv",
   "instHAdd",
   "HSub.hSub",
   "Neg.neg",
   "DivInvMonoid.toMonoid",
   "GroupWithZero.toDivInvMonoid",
   "Monoid.toMulOneClass",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "DivInvMonoid.toInv",
   "GroupWithZero.toDiv",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "DivInvOneMonoid.toInvOneClass",
   "DivisionMonoid.toDivInvMonoid",
   "GroupWithZero",
   "HMul.hMul",
   "zpow_neg",
   "zpow_add₀",
   "MonoidWithZero.toZero",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "Int",
   "Inv.inv"],
  "name": "zpow_sub₀",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → ∀ (m n : ℤ), a ^ (m - n) = a ^ m / a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "QuotientGroup.instHasQuotientSubgroup",
   "MulZeroOneClass.toMulOneClass",
   "algebraMap",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "Field.toSemifield",
   "MonoidHomClass.toMonoidHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "MonoidHom.range",
   "RingHom.instFunLike",
   "Units.map",
   "DivisionSemiring.toSemiring",
   "Units",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "RelativeUnits.proof_1",
   "MonoidWithZero.toMonoid",
   "Field",
   "NumberField.inst_ringOfIntegersAlgebra",
   "Algebra",
   "Subgroup",
   "Semifield.toDivisionSemiring",
   "HasQuotient.Quotient",
   "NumberField.RingOfIntegers",
   "Units.instGroup"],
  "name": "RelativeUnits",
  "constType":
  "(k : Type u_5) → (K : Type u_6) → [inst : Field k] → [inst_1 : Field K] → [inst : Algebra k K] → Type u_6",
  "constCategory": "Definition"},
 {"references":
  ["LT.lt", "Decidable", "Nat", "instLTNat", "Nat.succ", "Nat.decLe"],
  "name": "Nat.decLt",
  "constType": "(n m : ℕ) → Decidable (n < m)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "HEq",
  "constType": "{α : Sort u} → α → {β : Sort u} → β → Prop",
  "constCategory": "Other"},
 {"references":
  ["IsScalarTower.smul_assoc",
   "RingHom",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "Monoid.toOne",
   "instHSMul",
   "RingHom.comp",
   "Semiring.toMonoidWithZero",
   "True",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "one_smul",
   "MonoidWithZero.toMonoid",
   "CommSemiring",
   "HSMul.hSMul",
   "Algebra",
   "DFunLike.coe",
   "Algebra.toSMul",
   "Eq.trans",
   "MulActionWithZero.toMulAction",
   "id",
   "eq_self",
   "RingHom.ext",
   "Algebra.toModule",
   "Semiring",
   "algebraMap",
   "One.toOfNat1",
   "Module.toMulActionWithZero",
   "IsScalarTower",
   "RingHom.instFunLike",
   "Algebra.algebraMap_eq_smul_one",
   "Semiring.toOne",
   "MulAction.toSMul",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "congrArg"],
  "name": "IsScalarTower.algebraMap_eq",
  "constType":
  "∀ (R : Type u) (S : Type v) (A : Type w) [inst : CommSemiring R] [inst_1 : CommSemiring S] [inst_2 : Semiring A]\n  [inst_3 : Algebra R S] [inst_4 : Algebra S A] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R S A],\n  algebraMap R A = (algebraMap S A).comp (algebraMap R S)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "RingHom",
   "MulZeroOneClass.toMulOneClass",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "RelativeUnits",
   "NonAssocSemiring.toMulZeroOneClass",
   "Units.map",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "RelativeUnits.proof_1",
   "QuotientGroup.Quotient.commGroup",
   "Field",
   "Algebra",
   "Subgroup",
   "HasQuotient.Quotient",
   "id",
   "QuotientGroup.instHasQuotientSubgroup",
   "CommGroup",
   "algebraMap",
   "Field.toSemifield",
   "MonoidHomClass.toMonoidHom",
   "MonoidHom.range",
   "RingHom.instFunLike",
   "CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "Units",
   "DivisionSemiring.toSemiring",
   "Units.instCommGroupUnits",
   "NumberField.inst_ringOfIntegersAlgebra",
   "Semifield.toDivisionSemiring",
   "NumberField.RingOfIntegers",
   "Units.instGroup"],
  "name": "instCommGroupRelativeUnits",
  "constType":
  "{K : Type u_1} →\n  [inst : Field K] → {k : Type u_2} → [inst_1 : Field k] → [inst_2 : Algebra k K] → CommGroup (RelativeUnits k K)",
  "constCategory": "Definition"},
 {"references":
  ["Ne",
   "OfNat.ofNat",
   "Int.natAbs_pos",
   "Nat.mod_lt",
   "Int.emod_nonneg.match_1",
   "Int.sub_nonneg_of_le",
   "instLTNat",
   "LE.le",
   "Iff.mpr",
   "instHMod",
   "instLENat",
   "Nat.cast",
   "instNatCastInt",
   "Int.ofNat_le",
   "LT.lt",
   "HMod.hMod",
   "instOfNatNat",
   "Int.instMod",
   "Nat",
   "Int.ofNat_zero_le",
   "Nat.succ",
   "Int",
   "instOfNat",
   "Nat.instMod",
   "Int.instLEInt",
   "Int.natAbs"],
  "name": "Int.emod_nonneg",
  "constType": "∀ (a : ℤ) {b : ℤ}, b ≠ 0 → 0 ≤ a % b",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.mk",
   "AddCommGroupWithOne.toIntCast",
   "AddCommGroupWithOne.natCast_succ",
   "SubNegMonoid.toNeg",
   "AddCommGroupWithOne.toAddCommGroup",
   "SubNegMonoid.zsmul_neg'",
   "AddCommGroupWithOne",
   "AddCommGroupWithOne.intCast_ofNat",
   "AddCommGroupWithOne.toNatCast",
   "SubNegMonoid.sub_eq_add_neg",
   "AddCommGroupWithOne.toOne",
   "AddGroup.toSubNegMonoid",
   "AddGroup.add_left_neg",
   "SubNegMonoid.zsmul_succ'",
   "SubNegMonoid.toSub",
   "AddCommGroupWithOne.intCast_negSucc",
   "SubNegMonoid.toAddMonoid",
   "SubNegMonoid.zsmul",
   "AddGroupWithOne",
   "AddCommGroup.toAddGroup",
   "AddCommGroupWithOne.natCast_zero",
   "AddMonoidWithOne.mk",
   "SubNegMonoid.zsmul_zero'"],
  "name": "AddCommGroupWithOne.toAddGroupWithOne",
  "constType":
  "{R : Type u} → [self : AddCommGroupWithOne R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references": ["Classical.not_not", "propext", "Not", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.7",
  "constType": "∀ {a : Prop}, (¬¬a) = a",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "Ne",
   "Or",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "not_and_or",
   "instHAdd",
   "HAdd.hAdd",
   "pos_iff_ne_zero",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "And",
   "add_eq_zero_iff",
   "Iff",
   "of_eq_true",
   "propext",
   "Preorder.toLT",
   "LT.lt",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "congr",
   "Not",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "congrArg",
   "Eq.trans",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "add_pos_iff",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a b : α}, 0 < a + b ↔ 0 < a ∨ 0 < b",
  "constCategory": "Theorem"},
 {"references": ["Lean.Name"],
  "name": "Lean.SyntaxNodeKind",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "IsDomain",
   "NumberField.RingOfIntegers.instCommRing",
   "Subalgebra",
   "EuclideanDomain.toCommRing",
   "algebraInt",
   "integralClosure",
   "Subalgebra.instSetLike",
   "SetLike.instMembership",
   "Field.isDomain",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "Field.toEuclideanDomain",
   "Field",
   "inferInstanceAs",
   "instIsDomainSubtypeMemSubalgebraIntegralClosure",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Int",
   "Subtype",
   "Subalgebra.toSemiring"],
  "name": "NumberField.RingOfIntegers.instIsDomain",
  "constType":
  "∀ (K : Type u_1) [inst : Field K], IsDomain (NumberField.RingOfIntegers K)",
  "constCategory": "Definition"},
 {"references": ["Semiring", "Module", "AddCommMonoid"],
  "name": "Module.Free",
  "constType":
  "(R : Type u) → (M : Type v) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Prop",
  "constCategory": "Other"},
 {"references": [],
  "name": "PartialOrder",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "Ne",
   "CommMonoidWithZero.toZero",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "One.toOfNat1",
   "NormalizedGCDMonoid",
   "Finset.gcd",
   "CancelCommMonoidWithZero",
   "Finset.instMembership",
   "Eq",
   "MulDivCancelClass",
   "Zero.toOfNat0",
   "MonoidWithZero.toMonoid",
   "Finset",
   "Div",
   "Finset.gcd_div_eq_one",
   "HDiv.hDiv",
   "id",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "Finset.gcd_div_id_eq_one",
  "constType":
  "∀ {α : Type u_2} [inst : CancelCommMonoidWithZero α] [inst_1 : NormalizedGCDMonoid α] [inst_2 : Div α]\n  [inst_3 : MulDivCancelClass α] {s : Finset α} {a : α}, a ∈ s → a ≠ 0 → (s.gcd fun b => b / s.gcd id) = 1",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.add_comm",
   "NonUnitalNonAssocRing.toMul",
   "NonUnitalNonAssocCommSemiring.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "NonUnitalNonAssocSemiring.mk",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocRing.left_distrib",
   "NonUnitalNonAssocCommRing.mul_comm",
   "AddCommMonoid.mk",
   "NonUnitalNonAssocRing.zero_mul",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "NonUnitalNonAssocRing.right_distrib",
   "NonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.mul_zero",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommRing α] → NonUnitalNonAssocCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["QuotientGroup.leftRel",
   "Subgroup",
   "Group",
   "HasQuotient",
   "Quotient",
   "HasQuotient.mk"],
  "name": "QuotientGroup.instHasQuotientSubgroup",
  "constType": "{α : Type u_1} → [inst : Group α] → HasQuotient α (Subgroup α)",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "OfNat", "OfNat.mk", "Nat", "Int"],
  "name": "instOfNat",
  "constType": "{n : ℕ} → OfNat ℤ n",
  "constCategory": "Definition"},
 {"references":
  ["Nat.le_zero_eq",
   "OfNat.ofNat",
   "Iff.rfl",
   "instLTNat",
   "LE.le",
   "Eq",
   "Eq.mpr",
   "instLENat",
   "Iff",
   "LT.lt",
   "Nat.lt_succ_iff",
   "Iff.trans",
   "instOfNatNat",
   "Nat",
   "congrArg",
   "Nat.succ",
   "id"],
  "name": "Nat.lt_one_iff",
  "constType": "∀ {n : ℕ}, n < 1 ↔ n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map",
   "Membership.mem",
   "And",
   "Exists",
   "Setoid.r",
   "List.mem_map",
   "Iff",
   "List",
   "List.isSetoid",
   "Multiset",
   "Quot.inductionOn",
   "Eq",
   "Multiset.instMembership"],
  "name": "Multiset.mem_map",
  "constType":
  "∀ {α : Type u_1} {β : Type v} {f : α → β} {b : β} {s : Multiset α}, b ∈ Multiset.map f s ↔ ∃ a ∈ s, f a = b",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "RingHomClass.toAddMonoidHomClass",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "RingHomClass.toMonoidHomClass",
   "FunLike",
   "RingHomClass",
   "AddMonoidHomClass.toZeroHomClass",
   "MonoidWithZeroHomClass",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "MonoidWithZeroHomClass.mk",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "NonAssocSemiring"],
  "name": "RingHomClass.toMonoidWithZeroHomClass",
  "constType":
  "∀ {F : Type u_5} {α : outParam (Type u_6)} {β : outParam (Type u_7)} [inst : NonAssocSemiring α]\n  [inst_1 : NonAssocSemiring β] [inst_2 : FunLike F α β] [self : RingHomClass F α β], MonoidWithZeroHomClass F α β",
  "constCategory": "Definition"},
 {"references":
  ["Associated",
   "CommSemiring.toSemiring",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "Set",
   "IsDomain",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Semiring.toMonoidWithZero",
   "Submodule.completeLattice",
   "CommSemiring.toNonUnitalCommSemiring",
   "Ideal.span",
   "semigroupDvd",
   "CommRing",
   "Preorder.toLE",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Iff",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.toSemigroupWithZero",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Eq.symm",
   "le_antisymm_iff",
   "Semiring.toModule",
   "id",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "IsDomain.toCancelMonoidWithZero",
   "dvd_dvd_iff_associated",
   "Dvd.dvd",
   "LE.le",
   "SemigroupWithZero.toSemigroup",
   "and_comm",
   "And",
   "CommRing.toCommSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "and_congr",
   "CancelMonoidWithZero.toMonoidWithZero",
   "congrArg",
   "Ideal",
   "Ideal.span_singleton_le_span_singleton"],
  "name": "Ideal.span_singleton_eq_span_singleton",
  "constType":
  "∀ {α : Type u} [inst : CommRing α] [inst_1 : IsDomain α] {x y : α}, Ideal.span {x} = Ideal.span {y} ↔ Associated x y",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.mul_zero",
   "Eq",
   "PProd",
   "Eq.mpr",
   "instHPow",
   "PUnit",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Nat.succ",
   "id",
   "HPow.hPow",
   "Nat.mul_succ",
   "Nat.below",
   "Nat.brecOn",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "Unit",
   "One.toOfNat1",
   "pow_zero",
   "Monoid.toMulOneClass",
   "pow_add",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "HMul.hMul",
   "pow_succ'.match_1",
   "pow_succ",
   "instMulNat",
   "congrArg"],
  "name": "pow_mul",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (m n : ℕ), a ^ (m * n) = (a ^ m) ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "sub_self",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "instLTNat",
   "Semiring.toNatCast",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "Nat.Prime",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Nat",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Int.instSub",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Fin.mk",
   "instHSub",
   "HPow.hPow",
   "Ne",
   "Nat.Prime.pos",
   "Fin.val",
   "Int.ModEq",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.instRing",
   "CyclotomicField",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "CommRing.toCommMonoid",
   "instHMul",
   "Int.instCharZero",
   "Int.cast",
   "LT.lt",
   "Eq.mp",
   "CommRing.toRing",
   "Not",
   "congrArg",
   "Int",
   "Fin",
   "Int.instAddGroup",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CommRing.toNonUnitalCommRing",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "semigroupDvd",
   "Zero.toOfNat0",
   "CyclotomicField.instField",
   "instLENat",
   "FltRegular.CaseI.AuxLemmas._auxLemma.1",
   "instHPow",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Rat.instField",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "False",
   "instHAdd",
   "HSub.hSub",
   "Rat",
   "Dvd.dvd",
   "Ne.symm",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "FltRegular.CaseI.aux_cong1k₁",
   "CommRing.toCommSemiring",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.5",
   "instNatCastInt",
   "letFun",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "FltRegular.CaseI.aux0k₂",
   "NegZeroClass.toZero",
   "NumberField.RingOfIntegers",
   "Subtype.mk"],
  "name": "FltRegular.CaseI.aux1k₁",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p) {a b : ℤ} {ζ : NumberField.RingOfIntegers (CyclotomicField ⟨p, ⋯⟩ ℚ)},\n  5 ≤ p →\n    IsPrimitiveRoot ζ p →\n      ¬a ≡ b [ZMOD ↑p] →\n        ∀ {k₁ k₂ : Fin p}, ↑↑k₂ ≡ ↑↑k₁ - 1 [ZMOD ↑p] → ↑p ∣ ↑a + ↑b * ζ - ↑a * ζ ^ ↑k₁ - ↑b * ζ ^ ↑k₂ → 1 ≠ ↑k₁",
  "constCategory": "Theorem"},
 {"references": ["NatCast", "Semiring"],
  "name": "Semiring.toNatCast",
  "constType": "{α : Type u} → [self : Semiring α] → NatCast α",
  "constCategory": "Definition"},
 {"references": ["outParam", "Insert"],
  "name": "Insert.insert",
  "constType":
  "{α : outParam (Type u)} → {γ : Type v} → [self : Insert α γ] → α → γ → γ",
  "constCategory": "Definition"},
 {"references":
  ["SemilatticeSup.toSup",
   "AddGroup",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "Sup.sup",
   "Lattice",
   "SubNegZeroMonoid.toNegZeroClass",
   "Lattice.toSemilatticeSup",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "abs",
  "constType":
  "{α : Type u_1} → [inst : Lattice α] → [inst : AddGroup α] → α → α",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "Lean.Macro.Context",
   "Monad.toApplicative",
   "Lean.Macro.Context.currMacroScope",
   "Lean.MacroM",
   "Lean.MonadQuotation.mk",
   "Pure.pure",
   "Lean.Macro.withFreshMacroScope",
   "Lean.Macro.instMonadRefMacroM",
   "Lean.MacroScope",
   "EStateM.instMonad",
   "Lean.Macro.State",
   "Lean.Macro.Context.mainModule",
   "Lean.Macro.Exception",
   "Lean.Name",
   "Lean.MonadQuotation",
   "Applicative.toPure"],
  "name": "Lean.Macro.instMonadQuotationMacroM",
  "constType": "Lean.MonadQuotation Lean.MacroM",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.trans",
   "Nat.cast_one",
   "eq_self",
   "HPow.hPow",
   "instHAdd",
   "Nat.rawCast",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "pow_zero",
   "NonUnitalNonAssocSemiring.toDistrib",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "add_zero",
   "congrArg"],
  "name": "Mathlib.Tactic.Ring.pow_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] (a : R), a ^ 0 = Nat.rawCast 1 + 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "NoZeroDivisors",
   "instHMul",
   "mul_eq_zero",
   "Or",
   "OfNat.ofNat",
   "propext",
   "HMul.hMul",
   "MulZeroClass.toZero",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "FltRegular.MayAssume.Lemmas._auxLemma.1",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroClass M₀] [inst_1 : NoZeroDivisors M₀] {a b : M₀}, (a * b = 0) = (a = 0 ∨ b = 0)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termR_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "eq_true",
   "Fintype",
   "Finset",
   "Finset.mem_univ",
   "True",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.11",
  "constType":
  "∀ {α : Type u_1} [inst : Fintype α] (x : α), (x ∈ Finset.univ) = True",
  "constCategory": "Theorem"},
 {"references":
  ["mul_comm",
   "instHMul",
   "Eq.mpr",
   "CommSemigroup.toCommMagma",
   "Dvd.dvd.mul_right",
   "HMul.hMul",
   "Dvd.dvd",
   "semigroupDvd",
   "congrArg",
   "CommMagma.toMul",
   "CommSemigroup",
   "Eq",
   "id",
   "CommSemigroup.toSemigroup"],
  "name": "dvd_mul_of_dvd_right",
  "constType":
  "∀ {α : Type u_1} [inst : CommSemigroup α] {a b : α}, a ∣ b → ∀ (c : α), a ∣ c * b",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommSemiring",
   "inferInstance",
   "Int.instCommRing",
   "CommSemiring",
   "Int"],
  "name": "Int.instCommSemiring",
  "constType": "CommSemiring ℤ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toSemigroup",
   "OfNat.ofNat",
   "eq_true",
   "Monoid",
   "Monoid.toOne",
   "One.toOfNat1",
   "Dvd.dvd",
   "one_dvd",
   "semigroupDvd",
   "True",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.30",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a : α), (1 ∣ a) = True",
  "constCategory": "Theorem"},
 {"references": ["outParam", "HMul"],
  "name": "HMul.hMul",
  "constType":
  "{α : Type u} → {β : Type v} → {γ : outParam (Type w)} → [self : HMul α β γ] → α → β → γ",
  "constCategory": "Definition"},
 {"references": [],
  "name": "CovariantClass",
  "constType":
  "(M : Type u_1) → (N : Type u_2) → (M → N → N) → (N → N → Prop) → Prop",
  "constCategory": "Other"},
 {"references":
  ["Units",
   "CommGroup.mk",
   "CommMonoid",
   "CommGroup",
   "CommMonoid.toMonoid",
   "Units.instGroup",
   "Units.instCommGroupUnits.proof_1"],
  "name": "Units.instCommGroupUnits",
  "constType": "{α : Type u_1} → [inst : CommMonoid α] → CommGroup αˣ",
  "constCategory": "Definition"},
 {"references": ["Semiring", "DivisionSemiring"],
  "name": "DivisionSemiring.toSemiring",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references":
  ["Applicative",
   "Applicative.toSeqRight",
   "Monad",
   "ReaderT",
   "Monad.toApplicative",
   "Unit",
   "SeqLeft.seqLeft",
   "Applicative.toSeqLeft",
   "Applicative.mk",
   "ReaderT.instFunctorOfMonad",
   "Seq.seq",
   "Pure.mk",
   "Unit.unit",
   "Seq.mk",
   "Applicative.toSeq",
   "SeqRight.mk",
   "ReaderT.pure",
   "SeqLeft.mk",
   "SeqRight.seqRight"],
  "name": "ReaderT.instApplicativeOfMonad",
  "constType":
  "{ρ : Type u} → {m : Type u → Type v} → [inst : Monad m] → Applicative (ReaderT ρ m)",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "propext", "Exists.intro", "forall_exists_index", "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.4",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (∃ x, p x) → Prop}, (∀ (h : ∃ x, p x), q h) = ∀ (x : α) (h : p x), q ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "ExistsAddOfLE",
   "AddGroup.toSubNegMonoid",
   "LE.le",
   "Eq",
   "add_neg_cancel_left",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "LE",
   "ExistsAddOfLE.mk",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "AddGroup.existsAddOfLE",
  "constType":
  "∀ (α : Type u) [inst : AddGroup α] [inst_1 : LE α], ExistsAddOfLE α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.range",
   "propext",
   "LT.lt",
   "Finset",
   "Nat",
   "instLTNat",
   "Eq",
   "Finset.mem_range",
   "Finset.instMembership"],
  "name": "FltRegular.CaseI.AuxLemmas._auxLemma.6",
  "constType": "∀ {n m : ℕ}, (m ∈ Finset.range n) = (m < n)",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHSub",
   "SubNegMonoid.toSub",
   "OfNat.ofNat",
   "AddGroup",
   "propext",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_zero",
   "SubNegZeroMonoid.toNegZeroClass",
   "NegZeroClass.toZero",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.5",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, (a - b = 0) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OfNat.ofNat",
   "Trans.trans",
   "instHAdd",
   "HAdd.hAdd",
   "Preorder",
   "instTransLtLe_mathlib",
   "add_lt_add_right",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "zero_add",
   "instTransEq_1",
   "Function.swap",
   "AddZeroClass.toZero",
   "Preorder.toLT",
   "LT.lt",
   "CovariantClass",
   "AddZeroClass"],
  "name": "add_lt_of_neg_of_le",
  "constType":
  "∀ {α : Type u_1} [inst : AddZeroClass α] [inst_1 : Preorder α]\n  [inst_2 : CovariantClass α α (Function.swap fun x x_1 => x + x_1) fun x x_1 => x < x_1] {a b c : α},\n  a < 0 → b ≤ c → a + b < c",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "Iff.rfl",
   "Finset.toSet",
   "Set",
   "Finset",
   "Set.instMembership",
   "Finset.instMembership"],
  "name": "Finset.mem_coe",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, a ∈ ↑s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid",
   "one_mul",
   "Monoid.toOne",
   "Dvd.dvd",
   "One.toOfNat1",
   "semigroupDvd",
   "Dvd.intro",
   "Monoid.toMulOneClass"],
  "name": "one_dvd",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a : α), 1 ∣ a",
  "constCategory": "Theorem"},
 {"references": ["Fin.ext_iff", "Fin.val", "propext", "Nat", "Fin", "Eq"],
  "name": "FltRegular.CaseI.AuxLemmas._auxLemma.1",
  "constType": "∀ {n : ℕ} {a b : Fin n}, (a = b) = (↑a = ↑b)",
  "constCategory": "Theorem"},
 {"references":
  ["Units",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "NormalizationMonoid",
   "MonoidWithZero.toMonoid",
   "CancelCommMonoidWithZero",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "NormalizationMonoid.normUnit",
  "constType":
  "{α : Type u_2} → [inst : CancelCommMonoidWithZero α] → [self : NormalizationMonoid α] → α → αˣ",
  "constCategory": "Definition"},
 {"references":
  ["Associated",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Set.instSingletonSet",
   "MonoidWithZero.toMonoid",
   "propext",
   "Ideal.span_singleton_eq_span_singleton",
   "Set",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "Singleton.singleton",
   "Ideal.span",
   "Ideal",
   "CommRing",
   "Eq"],
  "name": "FltRegular.CaseI.Statement._auxLemma.5",
  "constType":
  "∀ {α : Type u} [inst : CommRing α] [inst_1 : IsDomain α] {x y : α}, (Ideal.span {x} = Ideal.span {y}) = Associated x y",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroHomClass.mk",
   "MulOneClass.toMul",
   "AlgHomClass.mk",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulZeroOneClass.toMulOneClass",
   "OneHomClass.mk",
   "MonoidHom.map_mul'",
   "AlgHom.toRingHom",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "AddZeroClass.toZero",
   "Semiring.toNonAssocSemiring",
   "AlgHom.commutes'",
   "CommSemiring",
   "Algebra",
   "RingHom.map_add'",
   "RingHom.toMonoidHom",
   "AddMonoidHomClass.mk",
   "MonoidHomClass.mk",
   "RingHomClass.mk",
   "AlgHomClass",
   "OneHom.map_one'",
   "Semiring",
   "MulOneClass.toOne",
   "AddMonoidWithOne.toAddMonoid",
   "AlgHom",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "MulHomClass.mk",
   "AddHomClass.mk",
   "MonoidHom.toOneHom",
   "RingHom.map_zero'",
   "AlgHom.funLike"],
  "name": "AlgHom.algHomClass",
  "constType":
  "∀ {R : Type u} {A : Type v} {B : Type w} [inst : CommSemiring R] [inst_1 : Semiring A] [inst_2 : Semiring B]\n  [inst_3 : Algebra R A] [inst_4 : Algebra R B], AlgHomClass (A →ₐ[R] B) R A B",
  "constCategory": "Definition"},
 {"references":
  ["List.cons",
   "_obj",
   "List.nil",
   "_neutral",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_28"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_37._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "algebraRat",
   "MulZeroClass.toMul",
   "Finset.instMembership",
   "Eq",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "Nat",
   "Subtype",
   "HPow.hPow",
   "instHSub",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "root_div_zeta_sub_one_dvd_gcd",
   "NumberField.to_charZero",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NumberField.RingOfIntegers.instIsDomain",
   "Field.toEuclideanDomain",
   "NumberField.inst_ringOfIntegersAlgebra",
   "NumberField",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Algebra.id",
   "Fact",
   "Field.toDivisionRing",
   "Ideal",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "div_zeta_sub_one_dvd_gcd",
   "Submodule.idemSemiring",
   "PNat.Prime",
   "Set",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "semigroupDvd",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instHPow",
   "Finset",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Eq.symm",
   "NeZero.succ",
   "Membership.mem",
   "root_div_zeta_sub_one_dvd_gcd_spec",
   "instAddNat",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Dvd.dvd",
   "Ring.toSemiring",
   "Polynomial.nthRootsFinset",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "Units.val",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IdemSemiring.toSemiring",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.15",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [hpri : Fact p.Prime] [inst : Field K] [inst_1 : NumberField K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K] (hp : p ≠ 2) {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p)\n  {x y z : NumberField.RingOfIntegers K} {ε : (NumberField.RingOfIntegers K)ˣ} {m : ℕ}\n  (e : x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p) (hy : ¬↑hζ.unit' - 1 ∣ y)\n  (η : { x // x ∈ Polynomial.nthRootsFinset (↑p) (NumberField.RingOfIntegers K) }),\n  div_zeta_sub_one_dvd_gcd hp hζ e hy η = root_div_zeta_sub_one_dvd_gcd hp hζ e hy η ^ ↑p",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.Syntax.Preresolved",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Submodule.mul_sup",
   "Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "Semiring.mk",
   "Submodule.sup_mul",
   "PartialOrder.toPreorder",
   "Submodule.idemSemiring.proof_4",
   "Submodule",
   "Submodule.toAddSubmonoid",
   "Submodule.pointwiseAddCommMonoid",
   "Submodule.mul_bot",
   "npowRec",
   "AddCommMonoid.toAddMonoid",
   "Function.Injective.semigroup",
   "Submodule.completeLattice",
   "AddMonoid.toAddZeroClass",
   "NonUnitalNonAssocSemiring.mk",
   "Preorder.toLE",
   "Submodule.idemSemiring.proof_6",
   "Submodule.bot_mul",
   "Submodule.idemSemiring.proof_8",
   "inferInstance",
   "Semiring.toNonAssocSemiring",
   "AddMonoidWithOne.toNatCast",
   "AddCommMonoid.mk",
   "CompleteLattice.toConditionallyCompleteLattice",
   "CommSemiring",
   "Algebra",
   "Submodule.idemSemiring.proof_5",
   "Lattice.toSemilatticeSup",
   "SemilatticeSup.toPartialOrder",
   "AddCommMonoid",
   "Bot.bot",
   "Submodule.mul",
   "Algebra.toModule",
   "Submodule.idemSemiring.proof_3",
   "Semiring",
   "Submodule.idemSemiring.proof_9",
   "AddMonoidWithOne.toAddMonoid",
   "Submodule.idemSemiring.proof_1",
   "ConditionallyCompleteLattice.toLattice",
   "Submodule.one_mul",
   "AddSubmonoid.semigroup",
   "AddSubmonoid",
   "AddMonoidWithOne.unary",
   "Submodule.one",
   "Submodule.mul_one",
   "Submodule.idemSemiring.proof_2",
   "AddMonoidWithOne",
   "Submodule.instOrderBot",
   "AddMonoidWithOne.toOne",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "IdemSemiring.mk",
   "NonUnitalSemiring.mk",
   "OrderBot.toBot",
   "IdemSemiring",
   "Submodule.mul_toAddSubmonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Lattice",
   "Submodule.idemSemiring.proof_7",
   "Semigroup"],
  "name": "Submodule.idemSemiring",
  "constType":
  "{R : Type u} →\n  [inst : CommSemiring R] → {A : Type v} → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → IdemSemiring (Submodule R A)",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Finset.Basic._auxLemma.117",
   "False",
   "EmptyCollection.emptyCollection",
   "Init.SimpLemmas._auxLemma.5",
   "Mathlib.Data.Finset.Basic._auxLemma.139",
   "Mathlib.Data.Finset.Basic._auxLemma.20",
   "iff_false",
   "True",
   "iff_self",
   "Eq",
   "Finset.instMembership",
   "DecidablePred",
   "And",
   "Iff",
   "of_eq_true",
   "forall_congr",
   "Finset",
   "congr",
   "Finset.filter",
   "Not",
   "congrArg",
   "Eq.trans",
   "Finset.instEmptyCollection"],
  "name": "Finset.filter_eq_empty_iff",
  "constType":
  "∀ {α : Type u_1} {p : α → Prop} [inst : DecidablePred p] {s : Finset α}, Finset.filter p s = ∅ ↔ ∀ ⦃x : α⦄, x ∈ s → ¬p x",
  "constCategory": "Theorem"},
 {"references": ["outParam", "FunLike", "NonAssocSemiring"],
  "name": "RingHomClass",
  "constType":
  "(F : Type u_5) →\n  (α : outParam (Type u_6)) →\n    (β : outParam (Type u_7)) →\n      [inst : NonAssocSemiring α] → [inst : NonAssocSemiring β] → [inst : FunLike F α β] → Prop",
  "constCategory": "Other"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "OfNat.ofNat",
   "SMulWithZero.toSMulZeroClass",
   "instHSMul",
   "SMulWithZero",
   "HSMul.hSMul",
   "SMulWithZero.zero_smul",
   "SMulZeroClass.toSMul",
   "Eq"],
  "name": "zero_smul",
  "constType":
  "∀ (R : Type u_1) {M : Type u_3} [inst : Zero R] [inst_1 : Zero M] [inst_2 : SMulWithZero R M] (m : M), 0 • m = 0",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.toAlgebra",
   "Mul.toSMul",
   "CommSemiring.toSemiring",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "Algebra.id.proof_6",
   "Algebra.id.proof_5",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.id",
   "RingHom.mk",
   "Algebra.id.proof_1",
   "Algebra.id.proof_2",
   "Algebra.id.proof_4",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "OneHom.mk",
   "MonoidHom.mk",
   "Algebra.mk",
   "Algebra.id.proof_3"],
  "name": "Algebra.id",
  "constType": "(R : Type u) → [inst : CommSemiring R] → Algebra R R",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.ParserDescr.node",
   "Lean.Name.mkNum",
   "instOfNatNat",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termP._@.FltRegular.CaseI.AuxLemmas._hyg.14",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.univ",
   "Fintype.complete",
   "Fintype",
   "Finset",
   "Finset.instMembership"],
  "name": "Finset.mem_univ",
  "constType": "∀ {α : Type u_1} [inst : Fintype α] (x : α), x ∈ Finset.univ",
  "constCategory": "Theorem"},
 {"references": ["EStateM", "ReaderT", "Unit", "Lean.Syntax"],
  "name": "Lean.PrettyPrinter.UnexpandM",
  "constType": "Type → Type",
  "constCategory": "Definition"},
 {"references": ["Exists", "eq_true", "exists_apply_eq_apply", "True", "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.10",
  "constType":
  "∀ {α : Sort u_2} {β : Sort u_1} (f : α → β) (a' : α), (∃ a, f a = f a') = True",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Iff",
   "DecidableEq",
   "Multiset.mem_dedup",
   "Finset",
   "Multiset",
   "Multiset.toFinset",
   "Multiset.instMembership",
   "Finset.instMembership"],
  "name": "Multiset.mem_toFinset",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, a ∈ s.toFinset ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Mathlib.Meta.NormNum.isNat_eq_false",
   "Mathlib.Tactic.Ring.pow_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Finset.instMembership",
   "ite",
   "Semiring.toNatCast",
   "DecidablePred",
   "Finset.sum_range",
   "instOfNat",
   "Fin.mk",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "MulOneClass.toOne",
   "NormedCommRing.toNormedRing",
   "Finset.filter_filter",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.ModEq.symm",
   "SMulZeroClass.toSMul",
   "And",
   "Finset.sum_neg_distrib",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "Int.instCharZero",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "instNatAtLeastTwo",
   "MonoidWithZero.toZero",
   "Nat.instCharZero",
   "Field.toDivisionRing",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "Int.instSemigroup",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Nat.decLt",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "semigroupDvd",
   "NeZero.pnat",
   "NonAssocSemiring.toMulZeroOneClass",
   "Mathlib.Tactic.Ring.sub_pf",
   "CyclotomicField.instField",
   "Monoid.toNatPow",
   "Nat.instAddCommMonoidWithOne",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Mathlib.Tactic.Ring.mul_pow",
   "Mathlib.Tactic.Ring.mul_add",
   "Neg.neg",
   "NormedField.toNormedCommRing",
   "instDecidableAnd",
   "LE.le",
   "CommRing.toCommSemiring",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.5",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.zero_mul",
   "instNatCastInt",
   "letFun",
   "Mathlib.Tactic.Ring.one_mul",
   "NegZeroClass.toNeg",
   "Subtype.mk",
   "Mathlib.Tactic.Ring.mul_congr",
   "Mathlib.Tactic.RingNF.int_rawCast_neg",
   "MulOneClass.toMul",
   "instHSMul",
   "SubtractionCommMonoid.toAddCommMonoid",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "instSubsingletonForall",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_iff_eq_add",
   "Finset.sum_const_zero",
   "Int.cast_add",
   "ZMod.instField",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "AddCommGroup.intModule",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "dvd_coeff_cycl_integer",
   "Eq.trans",
   "Mathlib.Tactic.RingNF.nat_rawCast_1",
   "NormedRing.toRing",
   "ite_smul",
   "Mathlib.Tactic.RingNF.add_neg",
   "Int.instDvd",
   "Finset.instSingleton",
   "Mathlib.Tactic.RingNF.mul_neg",
   "Fin.fintype",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "pow_zero",
   "ZMod",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "Mathlib.Tactic.Ring.neg_mul",
   "Finset.univ",
   "MulActionWithZero.toSMulWithZero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "Singleton.singleton",
   "mul_one",
   "Finset.instEmptyCollection",
   "instSubsingletonDecidable",
   "Int.ofNat",
   "CommRing.toNonUnitalCommRing",
   "AddGroupWithOne.toIntCast",
   "Dvd.dvd.mul_right",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "instDecidableNot",
   "AddMonoid.toZero",
   "ite_cond_eq_true",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Mathlib.Tactic.Ring.pow_congr",
   "id",
   "instOfNatAtLeastTwo",
   "eq_self",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "False",
   "AddMonoidWithOne.toAddMonoid",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "ite_congr",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Bool",
   "NumberField.RingOfIntegers",
   "Distrib.toAdd",
   "Mathlib.Tactic.Ring.one_pow",
   "CommSemiring.toSemiring",
   "Finset.range_filter_eq",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "EmptyCollection.emptyCollection",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "AddCommGroup.toAddCommMonoid",
   "instDecidableEqNat",
   "AddGroupWithOne.toAddGroup",
   "Mathlib.Meta.NormNum.isInt_add",
   "pow_one",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "Nat.Prime",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "Finset.range",
   "HSMul.hSMul",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Mathlib.Tactic.Ring.pow_add",
   "Int.instSub",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "HPow.hPow",
   "zsmul_eq_mul",
   "Int.instRing",
   "Module.toMulActionWithZero",
   "ne_and_eq_iff_right",
   "CyclotomicField",
   "instDecidableTrue",
   "CommRing.toCommMonoid",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "Finset.sum_ite",
   "LT.lt",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "Fin",
   "neg_smul",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "AddMonoid.toAddZeroClass",
   "FltRegular.CaseI.f1k₂",
   "True",
   "Subsingleton.elim",
   "AddMonoid.toAddSemigroup",
   "Eq.rec",
   "Decidable",
   "Finset",
   "Finset.filter",
   "FltRegular.CaseI.auxf1k₂",
   "NeZero.charZero",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instMul",
   "Finset.sum",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "Ne.symm",
   "Int.cast_sub",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Fact.mk",
   "Bool.false",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Rat.instNormedField",
   "ZMod.intCast_eq_intCast_iff",
   "CyclotomicField.instCharZero",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "AddGroupWithOne.toSub",
   "AddGroup.intSMulWithZero",
   "instLTNat",
   "Int.instAdd",
   "Eq",
   "Eq.mpr",
   "Ring.toNeg",
   "Finset.sum_singleton",
   "Nat",
   "Finset.sum_congr",
   "Ne",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "Nat.Prime.pos",
   "Fin.val",
   "Int.ModEq",
   "Nat.rawCast",
   "FltRegular.CaseI.aux_cong1k₂",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "SubNegMonoid.SMulInt",
   "Mathlib.Tactic.Ring.add_congr",
   "instHMul",
   "NonAssocRing.toIntCast",
   "Not",
   "congrArg",
   "add_zero",
   "zero_smul",
   "FltRegular.CaseI.two_lt",
   "NonAssocRing.toAddCommGroupWithOne",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "DivisionRing.toRing",
   "NumberField.RingOfIntegers.instCommRing",
   "AddCommMonoid.toAddMonoid",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Ring.toNonAssocRing",
   "PNat.val",
   "Zero.toOfNat0",
   "instLENat",
   "instHPow",
   "Ring.toSub",
   "Int.instNegInt",
   "Eq.symm",
   "funext",
   "Rat.instField",
   "CyclotomicField.isCyclotomicExtension",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "Rat",
   "Mathlib.Tactic.Ring.single_pow",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "Rat.instCharZero",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "Nat.instCommSemiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "Int.instCommSemiring",
   "ZMod.commRing"],
  "name": "FltRegular.CaseI.aux1k₂",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p) {a b c : ℤ} {ζ : NumberField.RingOfIntegers (CyclotomicField ⟨p, ⋯⟩ ℚ)},\n  5 ≤ p →\n    IsPrimitiveRoot ζ p →\n      ¬↑p ∣ a * b * c →\n        ∀ {k₁ k₂ : Fin p}, ↑↑k₂ ≡ ↑↑k₁ - 1 [ZMOD ↑p] → ↑p ∣ ↑a + ↑b * ζ - ↑a * ζ ^ ↑k₁ - ↑b * ζ ^ ↑k₂ → 1 ≠ ↑k₂",
  "constCategory": "Theorem"},
 {"references":
  ["SubNegMonoid", "SMul", "SMul.mk", "SubNegMonoid.zsmul", "Int"],
  "name": "SubNegMonoid.SMulInt",
  "constType": "{M : Type u_2} → [inst : SubNegMonoid M] → SMul ℤ M",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "Finset.sum_eq_zero_iff_of_nonneg",
   "OfNat.ofNat",
   "Iff",
   "AddMonoid.toZero",
   "Finset.sum",
   "Finset",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "zero_le",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "OrderedAddCommMonoid.toAddCommMonoid",
   "Eq",
   "Finset.instMembership"],
  "name": "Finset.sum_eq_zero_iff",
  "constType":
  "∀ {ι : Type u_1} {M : Type u_4} [inst : CanonicallyOrderedAddCommMonoid M] {f : ι → M} {s : Finset ι},\n  ∑ x ∈ s, f x = 0 ↔ ∀ x ∈ s, f x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "Submodule.idemSemiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "Ideal.span",
   "Eq",
   "Set.instSingletonSet",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "Ideal.span_singleton_pow",
   "Singleton.singleton",
   "IdemSemiring.toSemiring",
   "Nat",
   "Algebra.id",
   "Eq.symm",
   "Ideal"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.8",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] (s : R) (n : ℕ), Ideal.span {s ^ n} = Ideal.span {s} ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Int.cast_one",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Nat.succ_pred_prime",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.isInt_add",
   "Semiring.toNatCast",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "SubNegMonoid.toSub",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.Prime",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Fin.mk",
   "instHSub",
   "HPow.hPow",
   "Mathlib.Meta.NormNum.IsNat.to_raw_eq",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.instRing",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Nat.cast_add",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "eq_true",
   "Int.instCharZero",
   "AddMonoidWithOne.toOne",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "congr",
   "instNatAtLeastTwo",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "LinearOrder.toPartialOrder",
   "Field.toDivisionRing",
   "Int",
   "Fin",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Int.instAddGroup",
   "sub_nonpos_of_le",
   "Int.instSemiring",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "GE.ge",
   "Eq.refl",
   "Int.rawCast",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "Mathlib.Tactic.Ring.sub_congr",
   "NeZero.of_gt'",
   "AddMonoid.toAddZeroClass",
   "Fin.is_lt",
   "IsCancelAdd.toIsRightCancelAdd",
   "ZMod.val_natCast",
   "Mathlib.Tactic.Ring.sub_pf",
   "AddMonoidWithOne.toNatCast",
   "Nat.Prime.one_lt'",
   "Int.instAddMonoid",
   "Int.instCovariantClassAddLE",
   "AddMonoid.toAddSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "zero_lt_one",
   "Nat.mod_add_mod",
   "Nat.one_mod",
   "Nat.succ",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "NonUnitalNonAssocRing.toMul",
   "covariant_swap_add_of_covariant_add",
   "Ring.toAddGroupWithOne",
   "ZMod.val_one",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.mul_add",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "LE.le",
   "Fin.val_mk",
   "CommRing.toCommSemiring",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Int.instLinearOrderedCommRing",
   "Mathlib.Tactic.Ring.zero_mul",
   "instNatCastInt",
   "Fact.mk",
   "Bool.false",
   "letFun",
   "HMod.hMod",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "NegZeroClass.toNeg",
   "ZMod.intCast_eq_intCast_iff",
   "Mathlib.Tactic.Ring.mul_congr",
   "Mathlib.Meta.NormNum.instAddMonoidWithOne",
   "HAdd.hAdd",
   "Fin.ext",
   "AddGroup.toSubtractionMonoid",
   "Int.cast_add",
   "CanonicallyOrderedCommSemiring.toOne",
   "ZMod.val_cast_of_lt",
   "Int.instAdd",
   "Nat.mod_eq_of_lt",
   "Preorder.toLE",
   "Eq",
   "ZMod.instField",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "Ring.toIntCast",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "Nat",
   "Eq.trans",
   "Nat.cast_one",
   "StrictOrderedRing.toPartialOrder",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "congr_arg",
   "neg_neg_of_pos",
   "Fin.val",
   "OrderedSemiring.zeroLEOneClass",
   "Int.ModEq",
   "Nat.rawCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Nat.succ_pred_eq_of_pos",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "lt_of_not_ge",
   "Mathlib.Tactic.Ring.add_congr",
   "Int.instLTInt",
   "Int.instAddCommSemigroup",
   "ZMod",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "instHMul",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.mul_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "AddCancelMonoid.toIsCancelAdd",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "congrArg",
   "Int.instLEInt",
   "OrderedAddCommGroup.toAddCommGroup",
   "StrictOrderedRing.toRing",
   "Int.ofNat",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "FltRegular.CaseI.two_lt",
   "Linarith.lt_irrefl",
   "LinearOrderedRing.toStrictOrderedRing",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "AddGroupWithOne.toIntCast",
   "Mathlib.Meta.NormNum.isNat_add",
   "Mathlib.Tactic.Zify._auxLemma.2",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toNonAssocRing",
   "Zero.toOfNat0",
   "instLENat",
   "Nat.pred",
   "instHPow",
   "ZMod.val",
   "Preorder.toLT",
   "Mathlib.Meta.NormNum.isNat_lt_true",
   "Linarith.mul_neg",
   "instOfNatNat",
   "NeZero.charZero_one",
   "add_lt_of_neg_of_le",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "Fin.isLt",
   "id",
   "instOfNatAtLeastTwo",
   "Int.cast_natCast",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "NonUnitalNonAssocSemiring.toMul",
   "AddGroup.toSubNegMonoid",
   "GT.gt",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "instHMod",
   "ZMod.val_add",
   "OrderedCommSemiring.toOrderedSemiring",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "Nat.instCanonicallyOrderedCommSemiring",
   "Nat.instLinearOrder",
   "HMul.hMul",
   "Bool",
   "Int.instCommSemiring",
   "NegZeroClass.toZero",
   "Nat.instMod",
   "Nat.Prime.pred_pos",
   "ZMod.commRing"],
  "name": "FltRegular.CaseI.aux_cong1k₂",
  "constType":
  "∀ {p : ℕ} {k : Fin p}, Nat.Prime p → ∀ (hp5 : 5 ≤ p), ↑↑k ≡ 1 + 1 [ZMOD ↑p] → k = ⟨2, ⋯⟩",
  "constCategory": "Theorem"},
 {"references": ["instHMod", "HMod.hMod", "Int.instMod", "Int", "Eq"],
  "name": "Int.ModEq",
  "constType": "ℤ → ℤ → ℤ → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Monoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "SubNegMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "Int.ofNat",
   "Int.cast_natCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "AddGroupWithOne.toIntCast",
   "True",
   "Eq",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.IsNat",
   "of_eq_true",
   "instNatCastInt",
   "Int.cast",
   "Mathlib.Meta.NormNum.IsInt.to_isNat.match_1",
   "Ring.toIntCast",
   "Ring",
   "Mathlib.Meta.NormNum.IsInt",
   "Nat",
   "congrArg",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "Eq.trans",
   "Int"],
  "name": "Mathlib.Meta.NormNum.IsInt.to_isNat",
  "constType":
  "∀ {α : Type u_1} [inst : Ring α] {a : α} {n : ℕ},\n  Mathlib.Meta.NormNum.IsInt a (Int.ofNat n) → Mathlib.Meta.NormNum.IsNat a n",
  "constCategory": "Theorem"},
 {"references":
  ["CyclotomicField.instCharZero",
   "Int.instDecidableEq",
   "CyclotomicField.classGroupFinite.proof_3",
   "DivisionRing.toRing",
   "Semifield.toCommSemiring",
   "NumberField.RingOfIntegers.instCommRing",
   "Rat.isFractionRing",
   "AbsoluteValue.abs",
   "algebraInt",
   "algebraRat",
   "ClassGroup",
   "CyclotomicField.classGroupFinite.proof_5",
   "CyclotomicField.instField",
   "Fintype",
   "ClassGroup.fintypeOfAdmissibleOfFinite",
   "AbsoluteValue.absIsAdmissible",
   "NormedRing.toRing",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Rat.instField",
   "safe'",
   "CyclotomicField.classGroupFinite.proof_4",
   "Rat",
   "CyclotomicField.classGroupFinite.proof_2",
   "NormedCommRing.toNormedRing",
   "Field.toSemifield",
   "NormedField.toNormedCommRing",
   "Int.euclideanDomain",
   "Int.infinite",
   "EuclideanDomain.toCommRing",
   "CyclotomicField",
   "Rat.instCharZero",
   "CyclotomicField.classGroupFinite.proof_1",
   "Int.instLinearOrderedCommRing",
   "NumberField.RingOfIntegers.instIsDomain",
   "CommRing.toRing",
   "CyclotomicField.algebra'",
   "Algebra.id",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "Rat.instNormedField",
   "Int",
   "NumberField.RingOfIntegers.instAlgebra_1",
   "PNat"],
  "name": "CyclotomicField.classGroupFinite",
  "constType":
  "{p : ℕ+} → Fintype (ClassGroup (NumberField.RingOfIntegers (CyclotomicField p ℚ)))",
  "constCategory": "Definition"},
 {"references": ["Lean.Name"],
  "name": "Lean.Name.anonymous",
  "constType": "Lean.Name",
  "constCategory": "Other"},
 {"references":
  ["eq_true",
   "MvPolynomial.leadingTerms",
   "MvPolynomial.IsHomogeneous",
   "MvPolynomial",
   "CommSemiring",
   "MvPolynomial.totalDegree",
   "MvPolynomial.isHomogeneous_leadingTerms",
   "True",
   "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.25",
  "constType":
  "∀ {R : Type u_2} {ι : Type u_1} [inst : CommSemiring R] (p : MvPolynomial ι R),\n  p.leadingTerms.IsHomogeneous p.totalDegree = True",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "not_le",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "FltRegular.NumberTheory.KummersLemma.KummersLemma._auxLemma.3",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, (¬a ≤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references": ["not_exists", "Exists", "propext", "Not", "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.21",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∃ x, p x) = ∀ (x : α), ¬p x",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Name.num._override",
   "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_7"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_26",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_29._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike",
   "Set",
   "Membership.mk",
   "Set.instMembership",
   "Membership",
   "SetLike.coe"],
  "name": "SetLike.instMembership",
  "constType":
  "{A : Type u_1} → {B : Type u_2} → [i : SetLike A B] → Membership B A",
  "constCategory": "Definition"},
 {"references": ["Add", "Int.add", "Int", "Add.mk"],
  "name": "Int.instAdd",
  "constType": "Add ℤ",
  "constCategory": "Definition"},
 {"references": ["Exists.rec", "Exists", "Exists.intro"],
  "name": "Exists.casesOn",
  "constType":
  "∀ {α : Sort u} {p : α → Prop} {motive : Exists p → Prop} (t : Exists p), (∀ (w : α) (h : p w), motive ⋯) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "And",
   "Exists",
   "Iff",
   "Eq.rec",
   "exists_eq_left.match_1",
   "And.intro",
   "Exists.intro",
   "rfl",
   "Eq"],
  "name": "exists_eq_left",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∃ a, a = a' ∧ p a) ↔ p a'",
  "constCategory": "Theorem"},
 {"references": ["ite_eq_right_iff", "propext", "Decidable", "ite", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.19",
  "constType":
  "∀ {α : Sort u_1} {a b : α} {P : Prop} [inst : Decidable P], ((if P then a else b) = b) = (P → a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.toSet",
   "Set",
   "Finset",
   "Set.instMembership",
   "Finset.mem_coe",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.4",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ ↑s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.mul_zero",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), a * 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.toAddMonoidWithOne",
   "AddMonoid.toAddSemigroup",
   "AddSemigroup.toAdd",
   "instHAdd",
   "AddGroupWithOne.toIntCast",
   "Int.cast",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne",
   "Int.cast_add",
   "Eq.symm",
   "Int",
   "Int.instAdd",
   "Eq"],
  "name": "FltRegular.CaseII.Statement._auxLemma.2",
  "constType":
  "∀ {R : Type u} [inst : AddGroupWithOne R] (m n : ℤ), ↑m + ↑n = ↑(m + n)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "CancelMonoidWithZero",
   "Or",
   "OfNat.ofNat",
   "False",
   "Classical.propDecidable",
   "MulZeroClass.zero_mul",
   "dite",
   "or_true",
   "MulZeroOneClass.toMulZeroClass",
   "True",
   "MulZeroClass.toMul",
   "iff_self",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "eq_false",
   "Iff",
   "of_eq_true",
   "MulZeroClass.toZero",
   "congr",
   "HMul.hMul",
   "or_false",
   "Not",
   "MonoidWithZero.toZero",
   "not_false_eq_true",
   "congrArg",
   "CancelMonoidWithZero.toMonoidWithZero",
   "Eq.trans",
   "Mathlib.Algebra.GroupWithZero.Basic._auxLemma.8"],
  "name": "mul_eq_mul_left_iff",
  "constType":
  "∀ {M₀ : Type u_2} [inst : CancelMonoidWithZero M₀] {a b c : M₀}, a * b = a * c ↔ b = c ∨ a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["instCommGroupRelativeUnits",
   "CommGroup.toGroup",
   "DivisionRing.toRing",
   "Algebra.toModule",
   "relativeUnitsMapHom_apply",
   "Semifield.toCommSemiring",
   "LieRing.toAddCommGroup",
   "Field.toSemifield",
   "RelativeUnits",
   "MonoidHom",
   "DivInvMonoid.toMonoid",
   "AlgHom",
   "Monoid.toMulOneClass",
   "Eq",
   "DivisionSemiring.toSemiring",
   "relativeUnitsMap",
   "relativeUnitsMapHom",
   "AlgHom.End",
   "Monoid.End.inst",
   "Field",
   "NumberField",
   "Algebra",
   "Semifield.toDivisionSemiring",
   "MonoidHom.instFunLike",
   "Group.toDivInvMonoid",
   "DFunLike.coe",
   "LieRing.ofAssociativeRing",
   "Field.toDivisionRing",
   "Eq.symm",
   "Monoid.End",
   "FiniteDimensional"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.12",
  "constType":
  "∀ {K : Type u_1} [inst : Field K] [inst_1 : NumberField K] {k : Type u_2} [inst_2 : Field k] [inst_3 : NumberField k]\n  [inst_4 : Algebra k K] [inst_5 : FiniteDimensional k K] (σ : K →ₐ[k] K), relativeUnitsMap σ = relativeUnitsMapHom σ",
  "constCategory": "Theorem"},
 {"references": ["Iff", "False", "iff_true_intro", "Not", "not_false", "True"],
  "name": "not_false_iff",
  "constType": "¬False ↔ True",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_27._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Int.cast_pow",
   "MonoidWithZero.toMonoid",
   "Int.instHPowNat",
   "instHPow",
   "Int.cast",
   "Ring.toIntCast",
   "Semiring.toMonoidWithZero",
   "Ring",
   "Monoid.toNatPow",
   "Nat",
   "Ring.toSemiring",
   "Eq.symm",
   "Int",
   "Eq"],
  "name": "FltRegular.CaseII.Statement._auxLemma.1",
  "constType":
  "∀ {R : Type u_1} [inst : Ring R] (n : ℤ) (m : ℕ), ↑n ^ m = ↑(n ^ m)",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "AddCommMonoid"],
  "name": "NonUnitalNonAssocSemiring.toAddCommMonoid",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → AddCommMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "eq_false",
   "OfNat.ofNat",
   "NeZero",
   "False",
   "One",
   "one_ne_zero",
   "One.toOfNat1",
   "Eq"],
  "name": "Mathlib.Algebra.NeZero._auxLemma.4",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], (1 = 0) = False",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_8",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_16",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_17._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["SubNegZeroMonoid.neg_zero",
   "SubNegZeroMonoid.toSubNegMonoid",
   "NegZeroClass.mk",
   "SubNegMonoid.toNeg",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "SubNegZeroMonoid",
   "NegZeroClass"],
  "name": "SubNegZeroMonoid.toNegZeroClass",
  "constType": "{G : Type u_2} → [self : SubNegZeroMonoid G] → NegZeroClass G",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "mul_neg",
   "HAdd.hAdd",
   "HasDistribNeg",
   "Exists.casesOn",
   "True",
   "pow_one",
   "Odd.proof_1",
   "Eq",
   "Semiring.toNatCast",
   "pow_mul",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "instHPow",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Odd",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "neg_sq",
   "instOfNatAtLeastTwo",
   "id",
   "eq_self",
   "HPow.hPow",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "Nat.instSemiring",
   "One.toOfNat1",
   "Neg.neg",
   "NonUnitalNonAssocSemiring.toMul",
   "Monoid.toMulOneClass",
   "pow_add",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "HMul.hMul",
   "instMulNat",
   "congrArg"],
  "name": "Odd.neg_pow",
  "constType":
  "∀ {α : Type u_2} [inst : Monoid α] [inst_1 : HasDistribNeg α] {n : ℕ}, Odd n → ∀ (a : α), (-a) ^ n = -a ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Nat.instSemiring",
   "Odd.neg_pow",
   "Eq.refl",
   "HasDistribNeg",
   "Neg.neg",
   "One.toOfNat1",
   "one_pow",
   "Monoid.toMulOneClass",
   "Eq",
   "Eq.mpr",
   "instHPow",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.toInvolutiveNeg",
   "Monoid.toNatPow",
   "Nat",
   "Odd",
   "congrArg",
   "id"],
  "name": "Odd.neg_one_pow",
  "constType":
  "∀ {α : Type u_2} [inst : Monoid α] [inst_1 : HasDistribNeg α] {n : ℕ}, Odd n → (-1) ^ n = -1",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_Statement___unexpand_CyclotomicField_1._closed_1"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___unexpand_CyclotomicField_1._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Name.anonymous._impl",
   "Lean.Syntax.isOfKind",
   "String.toSubstring'",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "Lean.Syntax.Preresolved.decl",
   "_neutral",
   "Lean.addMacroScope",
   "Lean.Syntax.Preresolved.namespace",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "UInt8",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Lean.Name.num._override",
   "Bool.false",
   "Lean.Name.str._override",
   "Lean.Syntax.ident",
   "Lean.SourceInfo.fromRef",
   "List.nil"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.mul_zero",
   "CommMonoidWithZero.zero_mul",
   "CommMonoidWithZero.toZero",
   "MonoidWithZero.mk",
   "CommMonoidWithZero.toCommMonoid",
   "CommMonoid.toMonoid",
   "CommMonoidWithZero",
   "MonoidWithZero"],
  "name": "CommMonoidWithZero.toMonoidWithZero",
  "constType":
  "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → MonoidWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "OfNat.ofNat",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "Subtype.val",
   "Eq.refl",
   "Exists.intro",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.10",
   "FltRegular.CaseI.f1k₂",
   "CanonicallyOrderedCommSemiring.toOne",
   "instLTNat",
   "True",
   "instDecidableEqNat",
   "ite",
   "Eq",
   "Zero.toOfNat0",
   "Nat.Prime",
   "AddMonoidWithOne.toNatCast",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Int.instNegInt",
   "instOfNatNat",
   "Nat.instAddCommMonoidWithOne",
   "Nat",
   "Eq.trans",
   "instOfNat",
   "if_false",
   "Fin.mk",
   "instOfNatAtLeastTwo",
   "eq_self",
   "NeZero.succ",
   "Nat.Prime.one_lt",
   "Ne",
   "Nat.Prime.pos",
   "False",
   "Fin.val",
   "Neg.neg",
   "One.toOfNat1",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "ite_congr",
   "instDecidableFalse",
   "eq_false",
   "Nat.zero",
   "False.elim",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Mathlib.Algebra.NeZero._auxLemma.4",
   "LT.lt",
   "Nat.instCanonicallyOrderedCommSemiring",
   "letFun",
   "Eq.mp",
   "instNatAtLeastTwo",
   "Not",
   "congrArg",
   "Nat.instCharZero",
   "Int",
   "Subtype.mk",
   "Fin"],
  "name": "FltRegular.CaseI.auxf1k₂",
  "constType":
  "∀ {p : ℕ} (hpri : Nat.Prime p) (a : ℤ), ∃ i, FltRegular.CaseI.f1k₂ a ↑i = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "Equiv",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "Ideal.span",
   "algebraRat",
   "div_zeta_sub_one_Bijective",
   "MulZeroClass.toMul",
   "Finset.instMembership",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "Nat",
   "Ideal.instHasQuotient",
   "Subtype",
   "Equiv.symm",
   "HPow.hPow",
   "instHSub",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NumberField.to_charZero",
   "EuclideanDomain.toCommRing",
   "RingHom.instFunLike",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NumberField.RingOfIntegers.instIsDomain",
   "Field.toEuclideanDomain",
   "NumberField",
   "CommRing.toRing",
   "Ideal.Quotient.mk",
   "Singleton.singleton",
   "Not",
   "Fact",
   "Field.toDivisionRing",
   "Ideal",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "RingHom",
   "PNat.Prime",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "semigroupDvd",
   "Equiv.ofBijective",
   "Zero.toOfNat0",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instHPow",
   "AddMonoid.toZero",
   "Finset",
   "Ring.toSub",
   "Equiv.instFunLike",
   "Monoid.toNatPow",
   "instOfNatNat",
   "HasQuotient.Quotient",
   "DFunLike.coe",
   "div_zeta_sub_one",
   "NeZero.succ",
   "Ideal.Quotient.commRing",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "zeta_sub_one_dvd_root.proof_1",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "Rat",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Dvd.dvd",
   "Ring.toSemiring",
   "Polynomial.nthRootsFinset",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "Units.val",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "zeta_sub_one_dvd_root",
  "constType":
  "{K : Type u_1} →\n  {p : ℕ+} →\n    [hpri : Fact p.Prime] →\n      [inst : Field K] →\n        [inst_1 : NumberField K] →\n          [inst_2 : IsCyclotomicExtension {p} ℚ K] →\n            p ≠ 2 →\n              {ζ : K} →\n                (hζ : IsPrimitiveRoot ζ ↑p) →\n                  {x y z : NumberField.RingOfIntegers K} →\n                    {ε : (NumberField.RingOfIntegers K)ˣ} →\n                      {m : ℕ} →\n                        x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p →\n                          ¬↑hζ.unit' - 1 ∣ y →\n                            { x // x ∈ Polynomial.nthRootsFinset (↑p) (NumberField.RingOfIntegers K) }",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "neg_eq_zero",
   "propext",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid",
   "NegZeroClass.toZero",
   "NegZeroClass.toNeg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "FltRegular.CaseI.AuxLemmas._auxLemma.4",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionMonoid α] {a : α}, (-a = 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "Iff.rfl",
   "Semiring.toMonoidWithZero",
   "Commute.one_right",
   "one_pow",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Ring.toNeg",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "Ring",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Commute.sq_eq_sq_iff_eq_or_eq_neg",
   "id",
   "HPow.hPow",
   "NonUnitalNonAssocRing.toMul",
   "Or",
   "MulOneClass.toOne",
   "One.toOfNat1",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "NoZeroDivisors",
   "Semiring.toOne",
   "propext",
   "MonoidWithZero.toZero",
   "congrArg"],
  "name": "sq_eq_one_iff",
  "constType":
  "∀ {R : Type x} [inst : Ring R] {a : R} [inst_1 : NoZeroDivisors R], a ^ 2 = 1 ↔ a = 1 ∨ a = -1",
  "constCategory": "Theorem"},
 {"references":
  ["instHDiv",
   "instAddNat",
   "Nat.instDiv",
   "instHAdd",
   "HAdd.hAdd",
   "Eq",
   "instHMul",
   "instHMod",
   "Nat.add_mul_mod_self_left",
   "Nat.add_right_comm",
   "Nat.mod_add_div",
   "Eq.mp",
   "letFun",
   "HMod.hMod",
   "HMul.hMul",
   "HDiv.hDiv",
   "Nat",
   "instMulNat",
   "congrArg",
   "Eq.symm",
   "Nat.instMod"],
  "name": "Nat.mod_add_mod",
  "constType": "∀ (m n k : ℕ), (m % n + k) % n = (m + k) % n",
  "constCategory": "Theorem"},
 {"references":
  ["DecidablePred",
   "Finset",
   "Finset.val",
   "Multiset.filter",
   "Finset.filter.proof_1",
   "Finset.mk"],
  "name": "Finset.filter",
  "constType":
  "{α : Type u_1} → (p : α → Prop) → [inst : DecidablePred p] → Finset α → Finset α",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Ideal.mapHom_apply",
   "Ideal.map",
   "Submodule",
   "RingHomClass",
   "Submodule.idemSemiring",
   "Ideal.mapHom",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "Eq",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IdemSemiring.toSemiring",
   "Algebra.id",
   "DFunLike.coe",
   "MonoidWithZeroHom",
   "Eq.symm",
   "MonoidWithZeroHom.funLike",
   "Ideal",
   "Semiring.toModule"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.1",
  "constType":
  "∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : FunLike F R S]\n  [rc : RingHomClass F R S] (f : F) (I : Ideal R), Ideal.map f I = (Ideal.mapHom f) I",
  "constCategory": "Theorem"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "FractionRing.liftAlgebra.proof_2",
   "DivisionRing.toRing",
   "IsDomain",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "IsFractionRing.lift",
   "FractionRing.field",
   "Semifield.toCommGroupWithZero",
   "CommRing",
   "nonZeroDivisors",
   "OreLocalization.oreSetComm",
   "Field",
   "Algebra",
   "CommSemiring.toCommMonoidWithZero",
   "Algebra.toSMul",
   "RingHom.toAlgebra",
   "NoZeroSMulDivisors",
   "algebraMap",
   "Field.toSemifield",
   "OreLocalization.instCommSemiring",
   "CommGroupWithZero.toCommMonoidWithZero",
   "Ring.toSemiring",
   "OreLocalization.instAlgebra",
   "DivisionSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "CommRing.toCommMonoid",
   "FractionRing",
   "FractionRing.liftAlgebra.proof_1",
   "Semifield.toDivisionSemiring",
   "Algebra.id",
   "Field.toDivisionRing"],
  "name": "FractionRing.liftAlgebra",
  "constType":
  "(R : Type u_1) →\n  [inst : CommRing R] →\n    (K : Type u_5) →\n      [inst_1 : IsDomain R] →\n        [inst_2 : Field K] → [inst_3 : Algebra R K] → [inst_4 : NoZeroSMulDivisors R K] → Algebra (FractionRing R) K",
  "constCategory": "Definition"},
 {"references": ["AddSemigroup", "AddMonoid"],
  "name": "AddMonoid.toAddSemigroup",
  "constType": "{M : Type u} → [self : AddMonoid M] → AddSemigroup M",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_5",
   "Lean.Syntax.Preresolved.namespace"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["NatCast", "AddMonoidWithOne"],
  "name": "AddMonoidWithOne.toNatCast",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → NatCast R",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "IsPrimitiveRoot",
   "Semifield.toCommGroupWithZero",
   "AlgHomClass.toRingHomClass",
   "Exists.casesOn",
   "algebraRat",
   "instLTNat",
   "IsCyclotomicExtension.zeta",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "DivisionCommMonoid.toDivisionMonoid",
   "Field",
   "IsPrimitiveRoot.pow_eq_one",
   "Nat",
   "And.casesOn",
   "InvOneClass.toInv",
   "AlgEquiv.instEquivLike",
   "HPow.hPow",
   "IsCyclotomicExtension.zeta_spec",
   "EuclideanDomain.toCommRing",
   "galConj_zeta",
   "AlgEquiv.instFunLike",
   "And",
   "CommRing.toCommMonoid",
   "RingHomClass.toMonoidHomClass",
   "Field.toEuclideanDomain",
   "DivInvOneMonoid.toInvOneClass",
   "LT.lt",
   "Singleton.singleton",
   "Field.toDivisionRing",
   "congrArg",
   "DivisionMonoid.toDivInvOneMonoid",
   "Inv.inv",
   "Exists",
   "AlgEquiv",
   "PNat.pos",
   "DivisionRing.toRing",
   "Set",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AlgEquivClass.toAlgHomClass",
   "AlgEquiv.instAlgEquivClass",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instHPow",
   "map_pow",
   "Monoid.toNatPow",
   "DFunLike.coe",
   "CommGroupWithZero.toDivisionCommMonoid",
   "id",
   "inv_pow",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Rat.commSemiring",
   "Rat",
   "Field.toSemifield",
   "Field.toInv",
   "DivInvMonoid.toMonoid",
   "IsPrimitiveRoot.eq_pow_of_pow_eq_one",
   "IsCyclotomicExtension",
   "CommRing.toCommSemiring",
   "DivisionSemiring.toSemiring",
   "Field.isDomain",
   "Eq.ndrec",
   "CharZero",
   "DivisionMonoid.toDivInvMonoid",
   "Semifield.toDivisionSemiring",
   "galConj",
   "PNat"],
  "name": "galConj_zeta_runity",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [inst : Field K] [inst_1 : CharZero K] [inst_2 : IsCyclotomicExtension {p} ℚ K] {ζ : K},\n  IsPrimitiveRoot ζ ↑p → (galConj K p) ζ = ζ⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["Associated",
   "Monoid",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Units.instOne",
   "Monoid.toOne",
   "MulOneClass.toOne",
   "units_eq_one",
   "Eq.refl",
   "Units.val_one",
   "One.toOfNat1",
   "Exists.casesOn",
   "Monoid.toMulOneClass",
   "Unique",
   "Eq",
   "Iff.intro",
   "Units",
   "instHMul",
   "Eq.mpr",
   "Iff",
   "Eq.ndrec",
   "Units.val",
   "HMul.hMul",
   "mul_one",
   "congrArg",
   "Associated.refl",
   "id"],
  "name": "associated_iff_eq",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] [inst_1 : Unique αˣ] {x y : α}, Associated x y ↔ x = y",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "Lean.Omega.LinearCombo.eval",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Lean.Omega.Coeffs",
   "Neg.neg",
   "Lean.Omega.LinearCombo.instAdd",
   "Int.instAdd",
   "True",
   "Lean.Omega.LinearCombo.add_eval",
   "Eq",
   "of_eq_true",
   "Int.instNegInt",
   "Int.instSub",
   "Lean.Omega.LinearCombo.instSub",
   "congrArg",
   "Lean.Omega.LinearCombo",
   "Int",
   "Eq.trans",
   "Lean.Omega.LinearCombo.instNeg",
   "Lean.Omega.LinearCombo.neg_eval",
   "Lean.Omega.LinearCombo.sub_eq_add_neg"],
  "name": "Lean.Omega.LinearCombo.sub_eval",
  "constType":
  "∀ (l₁ l₂ : Lean.Omega.LinearCombo) (v : Lean.Omega.Coeffs), (l₁ - l₂).eval v = l₁.eval v - l₂.eval v",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "propext",
   "Nat.cast_inj",
   "Nat",
   "Eq"],
  "name": "FltRegular.CaseII.Statement._auxLemma.10",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, (↑m = ↑n) = (m = n)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Int.instNegInt",
   "Neg.neg",
   "instOfNatNat",
   "Nat",
   "instOfNat",
   "Int",
   "instDecidableEqNat",
   "Eq",
   "ite"],
  "name": "FltRegular.CaseI.f1k₂",
  "constType": "ℤ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Ne",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "False",
   "Trans.trans",
   "MulZeroOneClass.toMulOneClass",
   "MulOneClass.toOne",
   "exists_pair_ne",
   "MulZeroClass.zero_mul",
   "Eq.refl",
   "One.toOfNat1",
   "MulZeroOneClass.toZero",
   "Exists.casesOn",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "MulZeroOneClass",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "NeZero",
   "Eq.mpr",
   "NeZero.mk",
   "one_mul",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "instTransEq",
   "Nontrivial",
   "congrArg",
   "id"],
  "name": "NeZero.one",
  "constType":
  "∀ {M₀ : Type u_1} [inst : MulZeroOneClass M₀] [inst_1 : Nontrivial M₀], NeZero 1",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "Finset.instInsert",
   "Int.instDecidableEq",
   "Ideal.uniqueUnits",
   "Finset.exists_eq_pow_of_mul_eq_pow_of_coprime",
   "Insert.insert",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "algebraRat",
   "Finset.instMembership",
   "Nat.Prime",
   "Nat.cast",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "safe",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "CyclotomicField",
   "CommRing.toCommMonoid",
   "False.elim",
   "NumberField.RingOfIntegers.instIsDomain",
   "LT.lt",
   "congr",
   "Field.toDivisionRing",
   "Int",
   "Exists",
   "Set",
   "Semiring.toMonoidWithZero",
   "Submodule.instIdemCommSemiring",
   "Eq.refl",
   "NeZero.pnat",
   "algebraInt",
   "Finset.gcd",
   "CyclotomicField.instField",
   "Field.toCommRing",
   "Nat.Prime.eq_two_or_odd",
   "AddMonoid.toAddSemigroup",
   "Finset",
   "Monoid.toNatPow",
   "FltRegular.CaseI.Statement._auxLemma.4",
   "NeZero.charZero",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "IsDomain.toCancelCommMonoidWithZero",
   "Int.instMul",
   "Ideal.instNormalizedGCDMonoid",
   "algebraMap",
   "NormedField.toNormedCommRing",
   "LE.le",
   "CommRing.toCommSemiring",
   "instNatCastInt",
   "Bool.false",
   "letFun",
   "HMod.hMod",
   "IdemSemiring.toSemiring",
   "Rat.instNormedField",
   "IdemCommSemiring.toCommSemiring",
   "Subtype.mk",
   "CyclotomicField.instCharZero",
   "Int.cast_pow",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "Ideal.span",
   "NormalizedGCDMonoid.toGCDMonoid",
   "Int.cast_add",
   "instLTNat",
   "Int.instAdd",
   "Eq",
   "IsCyclotomicExtension.zeta",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Nat.Prime.ne_zero",
   "Nat",
   "Eq.trans",
   "NormedRing.toRing",
   "FltRegular.ab_coprime",
   "Ne",
   "NumberField.RingOfIntegers.instIsDedekindDomain",
   "Nat.Prime.pos",
   "congr_arg",
   "Int.instHPowNat",
   "Int.instDvd",
   "IsCyclotomicExtension.zeta_spec",
   "Finset.instSingleton",
   "eq_false_of_decide",
   "RingHom.instFunLike",
   "IsPrimitiveRoot.unit'_coe",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Or.resolve_left",
   "instHMul",
   "NonAssocRing.toIntCast",
   "Int.cast",
   "fltIdeals_coprime",
   "Eq.mp",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Algebra.id",
   "Fact",
   "congrArg",
   "Ideal",
   "Ideal.isDomain",
   "pow_add_pow_eq_prod_add_zeta_runity_mul",
   "RingHom",
   "AddGroupWithOne.toIntCast",
   "CommRing.toNonUnitalCommRing",
   "Submodule.idemSemiring",
   "NumberField.RingOfIntegers.instCommRing",
   "Fact.out",
   "Ring.toNonAssocRing",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instLENat",
   "instHPow",
   "instOfNatNat",
   "DFunLike.coe",
   "Nat.decLe",
   "id",
   "Membership.mem",
   "Rat.instField",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "instHAdd",
   "CyclotomicField.isCyclotomicExtension",
   "AddSemigroup.toAdd",
   "Int.instNormalizedGCDMonoid",
   "Rat",
   "AddMonoidWithOne.toAddMonoid",
   "eq_intCast",
   "Dvd.dvd",
   "Ring.toSemiring",
   "Int.instCancelCommMonoidWithZero",
   "Polynomial.nthRootsFinset",
   "Rat.instCharZero",
   "instHMod",
   "FltRegular.CaseI.Statement._auxLemma.3",
   "Units.val",
   "Finset.prod",
   "HMul.hMul",
   "Bool",
   "Int.instCommSemiring",
   "NumberField.RingOfIntegers",
   "Nat.instMod"],
  "name": "FltRegular.exists_ideal",
  "constType":
  "∀ {p : ℕ} [hpri : Fact (Nat.Prime p)] {a b c : ℤ},\n  5 ≤ p →\n    a ^ p + b ^ p = c ^ p →\n      {a, b, c}.gcd id = 1 →\n        ¬↑p ∣ a * b * c →\n          ∀ {ζ : NumberField.RingOfIntegers (CyclotomicField ⟨p, ⋯⟩ ℚ)},\n            ζ ∈ Polynomial.nthRootsFinset p (NumberField.RingOfIntegers (CyclotomicField ⟨p, ⋯⟩ ℚ)) →\n              ∃ I, Ideal.span {↑a + ζ * ↑b} = I ^ p",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk",
   "MonoidWithZero"],
  "name": "Semiring.toMonoidWithZero",
  "constType": "{α : Type u} → [self : Semiring α] → MonoidWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["InvolutiveNeg",
   "neg_inj",
   "InvolutiveNeg.toNeg",
   "propext",
   "Neg.neg",
   "Eq"],
  "name": "FltRegular.CaseII.Statement._auxLemma.8",
  "constType":
  "∀ {G : Type u_3} [inst : InvolutiveNeg G] {a b : G}, (-a = -b) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["DivisionRing.toDivisionSemiring",
   "DivisionRing.toRing",
   "Semifield.toCommSemiring",
   "Set",
   "AddCommGroup.toAddCommMonoid",
   "NumberField.to_finiteDimensional",
   "algebraRat",
   "RingHom.injective",
   "LocalRing.toNontrivial",
   "Set.Elem",
   "Field",
   "Algebra",
   "NumberField.mk",
   "IsScalarTower.rat",
   "Algebra.toModule",
   "Rat.commSemiring",
   "algebraMap",
   "Finite",
   "Rat",
   "Field.toSemifield",
   "ValuationRing.localRing",
   "NumberField.to_charZero",
   "Ring.toSemiring",
   "EuclideanDomain.toCommRing",
   "IsCyclotomicExtension",
   "DivisionSemiring.toSemiring",
   "Field.isDomain",
   "Rat.instDivisionRing",
   "ValuationRing.of_field",
   "Field.toEuclideanDomain",
   "Module.Finite.trans",
   "NumberField",
   "IsCyclotomicExtension.finite",
   "Ring.toAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Field.toDivisionRing",
   "charZero_of_injective_algebraMap",
   "PNat"],
  "name": "IsCyclotomicExtension.numberField",
  "constType":
  "∀ (S : Set ℕ+) (K : Type w) (L : Type z) [inst : Field K] [inst_1 : Field L] [inst_2 : Algebra K L] [h : NumberField K]\n  [inst_3 : Finite ↑S] [inst : IsCyclotomicExtension S K L], NumberField L",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "WfDvdMonoid.mk",
   "Submodule",
   "PartialOrder.toPreorder",
   "HEq",
   "IsDomain",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Set",
   "Eq.refl",
   "Submodule.completeLattice",
   "IsNoetherianRing",
   "Ideal.span",
   "InvImage",
   "CommRing",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Set.instSingletonSet",
   "Preorder.toLT",
   "WellFounded",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "Semiring.toModule",
   "Ideal.span_singleton_lt_span_singleton",
   "DvdNotUnit",
   "WfDvdMonoid",
   "funext",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "eq_of_heq",
   "InvImage.wf",
   "wellFounded_submodule_gt",
   "GT.gt",
   "Iff.symm",
   "CommRing.toCommSemiring",
   "Eq.ndrec",
   "HEq.refl",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "LT.lt",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Eq.casesOn",
   "Ideal"],
  "name": "IsNoetherianRing.wfDvdMonoid",
  "constType":
  "∀ {α : Type u_1} [inst : CommRing α] [inst_1 : IsDomain α] [inst_2 : IsNoetherianRing α], WfDvdMonoid α",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "Lean.Name.str._override",
   "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_3",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_1"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["LE"],
  "name": "OrderTop",
  "constType": "(α : Type u) → [inst : LE α] → Type u",
  "constCategory": "Other"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "instHAdd",
   "Finset.sum",
   "HAdd.hAdd",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "ite",
   "DecidablePred",
   "Finset.sum_apply_ite",
   "of_eq_true",
   "instDecidableNot",
   "Finset",
   "Finset.filter",
   "Not",
   "congrArg",
   "Eq.trans",
   "AddCommMonoid"],
  "name": "Finset.sum_ite",
  "constType":
  "∀ {α : Type u_3} {β : Type u_4} [inst : AddCommMonoid β] {s : Finset α} {p : α → Prop} {hp : DecidablePred p}\n  (f g : α → β),\n  (∑ x ∈ s, if p x then f x else g x) = ∑ x ∈ Finset.filter p s, f x + ∑ x ∈ Finset.filter (fun x => ¬p x) s, g x",
  "constCategory": "Theorem"},
 {"references": ["Decidable", "Eq"],
  "name": "DecidableEq",
  "constType": "Sort u → Sort (max 1 u)",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HSub.hSub",
   "AddCommMonoid.toAddMonoid",
   "Sub",
   "AddCommMagma.toAdd",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "tsub_eq_zero_iff_le",
   "OrderedSub",
   "propext",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "FltRegular.NumberTheory.KummersLemma.KummersLemma._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b : α},\n  (a - b = 0) = (a ≤ b)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "neg_zero",
   "Semiring.toMonoidWithZero",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toSemiring",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "Ring.toNeg",
   "of_eq_true",
   "Ring",
   "Ring.toAddCommGroup",
   "MonoidWithZero.toZero",
   "congrArg",
   "NegZeroClass.toNeg",
   "NegZeroClass.toZero",
   "Eq.trans",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Mathlib.Tactic.Ring.neg_zero",
  "constType": "∀ {R : Type u_2} [inst : Ring R], -0 = 0",
  "constCategory": "Theorem"},
 {"references": ["forall_eq", "propext", "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.4",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {a' : α}, (∀ (a : α), a = a' → p a) = p a'",
  "constCategory": "Theorem"},
 {"references":
  ["And",
   "Ne",
   "Iff",
   "Eq.rec",
   "and_iff_right_of_imp",
   "Ne.symm",
   "Eq.symm",
   "Eq"],
  "name": "ne_and_eq_iff_right",
  "constType": "∀ {α : Sort u_1} {a b c : α}, b ≠ c → (a ≠ b ∧ a = c ↔ a = c)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff", "Classical.propDecidable", "Not", "Decidable.not_imp_self"],
  "name": "not_imp_self",
  "constType": "∀ {a : Prop}, ¬a → a ↔ a",
  "constCategory": "Theorem"},
 {"references":
  ["MonadExcept", "tryCatchThe", "MonadExcept.mk", "throwThe", "MonadExceptOf"],
  "name": "instMonadExceptOfMonadExceptOf",
  "constType":
  "(ε : Type u) → (m : Type v → Type w) → [inst : MonadExceptOf ε m] → MonadExcept ε m",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "SubNegMonoid.toSub",
   "SubNegMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "AddMonoid.toAddZeroClass",
   "Eq.symm",
   "Eq"],
  "name": "FltRegular.MayAssume.Lemmas._auxLemma.4",
  "constType":
  "∀ {G : Type u_1} [inst : SubNegMonoid G] (a b : G), a + -b = a - b",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Submodule",
   "MulZeroOneClass.toMulOneClass",
   "Algebra.toModule",
   "CommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "IsLocalization.coeSubmodule",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "IsFractional",
   "Algebra",
   "FractionalIdeal",
   "Submonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "FractionalIdeal.coeIdeal.proof_1",
   "Ideal",
   "Subtype.mk",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "FractionalIdeal.coeIdeal",
  "constType":
  "{R : Type u_1} →\n  [inst : CommRing R] →\n    {S : Submonoid R} → {P : Type u_2} → [inst_1 : CommRing P] → [inst_2 : Algebra R P] → Ideal R → FractionalIdeal S P",
  "constCategory": "Definition"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Finset.instSingleton",
   "Singleton.singleton",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.MayAssume.Lemmas._auxLemma.7",
  "constType": "∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Submodule.span_mul_span",
   "Submodule",
   "Submodule.mul",
   "Algebra.toModule",
   "Set.mul",
   "Ideal.instMul",
   "Set",
   "Set.singleton_mul_singleton",
   "Eq.refl",
   "Ideal.span",
   "NonUnitalNonAssocSemiring.toMul",
   "Submodule.span",
   "Eq",
   "instHMul",
   "Set.instSingletonSet",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "HMul.hMul",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.id",
   "congrArg",
   "Ideal",
   "Semiring.toModule",
   "id"],
  "name": "Ideal.span_singleton_mul_span_singleton",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] (r s : R), Ideal.span {r} * Ideal.span {s} = Ideal.span {r * s}",
  "constCategory": "Theorem"},
 {"references": ["Semiring", "CommSemiring"],
  "name": "Algebra",
  "constType":
  "(R : Type u) → (A : Type v) → [inst : CommSemiring R] → [inst : Semiring A] → Type (max u v)",
  "constCategory": "Other"},
 {"references": ["List", "List.isSetoid", "Quotient"],
  "name": "Multiset",
  "constType": "Type u → Type u",
  "constCategory": "Definition"},
 {"references":
  ["CyclotomicField.classGroupFinite",
   "Rat.instField",
   "OfNat.ofNat",
   "NumberField.RingOfIntegers.instCommRing",
   "Rat",
   "Eq.refl",
   "Fintype.card",
   "IsRegularNumber",
   "instLTNat",
   "CyclotomicField",
   "ClassGroup",
   "Eq",
   "CyclotomicField.instField",
   "IsRegularNumber.proof_1",
   "IsRegularNumber.proof_2",
   "LT.lt",
   "Nat.Coprime",
   "instOfNatNat",
   "Nat",
   "Fact",
   "NumberField.RingOfIntegers",
   "Subtype.mk"],
  "name": "IsRegularNumber.eq_1",
  "constType":
  "∀ (n : ℕ) [hn : Fact (0 < n)],\n  IsRegularNumber n = n.Coprime (Fintype.card (ClassGroup (NumberField.RingOfIntegers (CyclotomicField ⟨n, ⋯⟩ ℚ))))",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.nodup_range", "Multiset.range", "Finset", "Finset.mk", "Nat"],
  "name": "Finset.range",
  "constType": "ℕ → Finset ℕ",
  "constCategory": "Definition"},
 {"references": ["Zero.toOfNat0", "Zero", "Ne", "NeZero", "OfNat.ofNat"],
  "name": "NeZero.mk",
  "constType": "∀ {R : Type u_1} [inst : Zero R] {n : R}, n ≠ 0 → NeZero n",
  "constCategory": "Other"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "HMul.hMul",
   "Eq.symm",
   "Semigroup",
   "Eq"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.19",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * (b * c) = a * b * c",
  "constCategory": "Theorem"},
 {"references":
  ["AddCommGroup.add_comm",
   "AddCommMonoid.mk",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "AddGroup.toSubNegMonoid",
   "AddCommMonoid"],
  "name": "AddCommGroup.toAddCommMonoid",
  "constType": "{G : Type u} → [self : AddCommGroup G] → AddCommMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Int.eq_ofNat_of_zero_le",
   "Exists",
   "Int.natAbs_of_nonneg.match_1",
   "OfNat.ofNat",
   "Nat.cast",
   "instNatCastInt",
   "Nat",
   "rfl",
   "instOfNat",
   "LE.le",
   "Int",
   "Int.instLEInt",
   "Int.natAbs",
   "Eq"],
  "name": "Int.natAbs_of_nonneg",
  "constType": "∀ {a : ℤ}, 0 ≤ a → ↑a.natAbs = a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instDecidableFalse",
   "False",
   "of_eq_true",
   "Decidable",
   "Eq.refl",
   "Not",
   "congrArg",
   "Eq.trans",
   "ite_congr",
   "True",
   "ite",
   "Eq"],
  "name": "ite_cond_eq_false",
  "constType":
  "∀ {α : Sort u} {c : Prop} {x : Decidable c} (a b : α), c = False → (if c then a else b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_10",
   "Lean.Name.str._override",
   "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_5"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EmptyCollection.emptyCollection",
   "HEq",
   "Iff.rfl",
   "Nat.decLt",
   "Eq.refl",
   "heq_of_eq",
   "Mathlib.Data.Finset.Basic._auxLemma.154",
   "instLTNat",
   "True",
   "instDecidableEqNat",
   "iff_self",
   "Finset.instMembership",
   "ite",
   "Eq",
   "DecidablePred",
   "Eq.mpr",
   "Iff",
   "Lean.Meta.FastSubsingleton.elim",
   "Finset.range",
   "Finset",
   "Decidable",
   "Finset.filter",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "id",
   "Membership.mem",
   "Finset.decidableMem",
   "funext",
   "Finset.filter_eq",
   "eq_of_heq",
   "eq_comm",
   "Finset.instSingleton",
   "ite_congr",
   "Eq.ndrec",
   "of_eq_true",
   "HEq.refl",
   "Lean.Meta.instFastSubsingletonDecidable",
   "propext",
   "LT.lt",
   "HEq.casesOn",
   "Lean.Meta.instFastSubsingletonForall",
   "Not",
   "Singleton.singleton",
   "Eq.casesOn",
   "congrArg",
   "Finset.instEmptyCollection"],
  "name": "Finset.range_filter_eq",
  "constType":
  "∀ {n m : ℕ}, Finset.filter (fun x => x = m) (Finset.range n) = if m < n then {m} else ∅",
  "constCategory": "Theorem"},
 {"references":
  ["Ne", "Preorder.toLT", "LT.lt", "Ne.symm", "Preorder", "LT.lt.ne"],
  "name": "LT.lt.ne'",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] {x y : α}, x < y → y ≠ x",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_12",
   "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_6",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.comp_apply",
   "RingHom",
   "RingHom.comp",
   "DFunLike.coe",
   "Eq.symm",
   "RingHom.instFunLike",
   "NonAssocSemiring",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.11",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} {γ : Type u_4} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β}\n  {x_2 : NonAssocSemiring γ} (hnp : β →+* γ) (hmn : α →+* β) (x_3 : α), hnp (hmn x_3) = (hnp.comp hmn) x_3",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "DivisionRing.toRing",
   "Field.toEuclideanDomain",
   "Field",
   "Subalgebra",
   "Field.toDivisionRing",
   "algebraInt",
   "EuclideanDomain.toCommRing",
   "integralClosure",
   "Subalgebra.instSetLike",
   "Int",
   "SetLike.instMembership",
   "Subtype"],
  "name": "NumberField.RingOfIntegers",
  "constType": "(K : Type u_1) → [inst : Field K] → Type u_1",
  "constCategory": "Definition"},
 {"references":
  ["Units",
   "Monoid",
   "Units.instGroup.proof_1",
   "Group.mk",
   "Group",
   "Units.instDivInvMonoid"],
  "name": "Units.instGroup",
  "constType": "{α : Type u} → [inst : Monoid α] → Group αˣ",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Group"],
  "name": "Group.toDivInvMonoid",
  "constType": "{G : Type u} → [self : Group G] → DivInvMonoid G",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "propext",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "nonpos_iff_eq_zero",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.23",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a : α}, (a ≤ 0) = (a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.map", "CommMonoid", "Multiset.prod", "Finset", "Finset.val"],
  "name": "Finset.prod",
  "constType":
  "{α : Type u_3} → {β : Type u_4} → [inst : CommMonoid β] → Finset α → (α → β) → β",
  "constCategory": "Definition"},
 {"references":
  ["Nat.gcd_dvd_right",
   "Int.instDvd",
   "Int.ofNat_dvd",
   "Dvd.dvd",
   "Int.natAbs_dvd_self",
   "Int.gcd",
   "Int.dvd_trans",
   "Nat.cast",
   "instNatCastInt",
   "propext",
   "letFun",
   "Eq.mp",
   "Nat.gcd",
   "Nat.instDvd",
   "Nat",
   "congrArg",
   "Eq.symm",
   "Int",
   "Int.natAbs"],
  "name": "Int.gcd_dvd_right",
  "constType": "∀ {a b : ℤ}, ↑(a.gcd b) ∣ b",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_20",
   "_obj",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_21._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Nat"],
  "name": "Lean.MacroScope",
  "constType": "Type",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddLeftCancelMonoid.toAddMonoid",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "AddMonoid.toAddZeroClass",
   "add_right_eq_self",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.8",
  "constType":
  "∀ {M : Type u} [inst : AddLeftCancelMonoid M] {a b : M}, (a + b = a) = (b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Ideal.Quotient.commRing",
   "CommSemiring.toSemiring",
   "RingHom",
   "Submodule",
   "Submodule.Quotient.mk",
   "AddCommGroup.toAddCommMonoid",
   "Ring.toSemiring",
   "RingHom.instFunLike",
   "rfl",
   "CommRing",
   "Eq",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Submodule.hasQuotient",
   "CommRing.toRing",
   "Ideal.Quotient.mk",
   "Ring.toAddCommGroup",
   "HasQuotient.Quotient",
   "DFunLike.coe",
   "Ideal.instHasQuotient",
   "Ideal",
   "Semiring.toModule"],
  "name": "Ideal.Quotient.mk_eq_mk",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] {I : Ideal R} (x : R), Submodule.Quotient.mk x = (Ideal.Quotient.mk I) x",
  "constCategory": "Theorem"},
 {"references": ["NonUnitalNonAssocSemiring", "Mul"],
  "name": "NonUnitalNonAssocSemiring.toMul",
  "constType": "{α : Type u} → [self : NonUnitalNonAssocSemiring α] → Mul α",
  "constCategory": "Definition"},
 {"references": ["SemilatticeInf", "PartialOrder"],
  "name": "SemilatticeInf.toPartialOrder",
  "constType": "{α : Type u} → [self : SemilatticeInf α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_28._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["AddMonoidWithOne", "AddMonoid"],
  "name": "AddMonoidWithOne.toAddMonoid",
  "constType": "{R : Type u_2} → [self : AddMonoidWithOne R] → AddMonoid R",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Set.instSingletonSet",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Ideal.instMul",
   "Set",
   "CommSemiring",
   "HMul.hMul",
   "Singleton.singleton",
   "Ideal.span",
   "Ideal.span_singleton_mul_span_singleton",
   "NonUnitalNonAssocSemiring.toMul",
   "Eq.symm",
   "Ideal",
   "Eq"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.9",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] (r s : R), Ideal.span {r * s} = Ideal.span {r} * Ideal.span {s}",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_15._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Lean.Name._impl"],
  "name": "Lean.Name.anonymous._impl",
  "constType": "Lean.Name._impl",
  "constCategory": "Other"},
 {"references": ["AddMonoidWithOne", "AddGroupWithOne"],
  "name": "AddGroupWithOne.toAddMonoidWithOne",
  "constType": "{R : Type u} → [self : AddGroupWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "FunLike",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal.span",
   "DFunLike.coe",
   "Set.image",
   "Ideal",
   "Semiring.toModule",
   "Submodule.setLike",
   "SetLike.coe"],
  "name": "Ideal.map",
  "constType":
  "{R : Type u} →\n  {S : Type v} →\n    {F : Type u_1} → [inst : Semiring R] → [inst_1 : Semiring S] → [inst_2 : FunLike F R S] → F → Ideal R → Ideal S",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "Mul"],
  "name": "MulHomClass",
  "constType":
  "(F : Type u_10) →\n  (M : outParam (Type u_11)) →\n    (N : outParam (Type u_12)) → [inst : Mul M] → [inst : Mul N] → [inst : FunLike F M N] → Prop",
  "constCategory": "Other"},
 {"references": ["Zero", "AddLeftCancelMonoid"],
  "name": "AddLeftCancelMonoid.toZero",
  "constType": "{M : Type u} → [self : AddLeftCancelMonoid M] → Zero M",
  "constCategory": "Definition"},
 {"references":
  ["Associated",
   "Units",
   "Monoid",
   "propext",
   "Eq.symm",
   "associated_iff_eq",
   "Eq",
   "Unique"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.7",
  "constType":
  "∀ {α : Type u_1} [inst : Monoid α] [inst_1 : Unique αˣ] {x y : α}, (x = y) = Associated x y",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.cast", "instNatCastInt", "Nat", "Int", "rfl", "Eq", "Int.natAbs"],
  "name": "Int.natAbs_ofNat",
  "constType": "∀ (n : ℕ), (↑n).natAbs = n",
  "constCategory": "Theorem"},
 {"references":
  ["LieRing.ofAssociativeRing.proof_2",
   "LieRing.ofAssociativeRing.proof_4",
   "LieRing.mk",
   "Ring",
   "Ring.instBracket",
   "Ring.toAddCommGroup",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "LieRing",
   "LieRing.ofAssociativeRing.proof_3",
   "LieRing.ofAssociativeRing.proof_1",
   "Ring.toNonAssocRing"],
  "name": "LieRing.ofAssociativeRing",
  "constType": "{A : Type v} → [inst : Ring A] → LieRing A",
  "constCategory": "Definition"},
 {"references":
  ["Function.comp",
   "Eq.refl",
   "Multiset.map_map",
   "Monoid.toMulOneClass",
   "Eq",
   "Multiset.map",
   "MonoidHomClass",
   "Eq.mpr",
   "FunLike",
   "CommMonoid",
   "Multiset",
   "Finset",
   "Finset.prod",
   "Multiset.prod",
   "Finset.val",
   "map_multiset_prod",
   "CommMonoid.toMonoid",
   "DFunLike.coe",
   "congrArg",
   "Eq.trans",
   "id"],
  "name": "map_prod",
  "constType":
  "∀ {α : Type u_3} {β : Type u_4} {γ : Type u_5} [inst : CommMonoid β] [inst_1 : CommMonoid γ] {G : Type u_6}\n  [inst_2 : FunLike G β γ] [inst_3 : MonoidHomClass G β γ] (g : G) (f : α → β) (s : Finset α),\n  g (∏ x ∈ s, f x) = ∏ x ∈ s, g (f x)",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocSemiring.toAddCommMonoidWithOne",
   "PartialOrder.toPreorder",
   "Nat.cast_lt",
   "OrderedSemiring.zeroLEOneClass",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "instLTNat",
   "Iff.mpr",
   "Eq",
   "OrderedSemiring",
   "Semiring.toNonAssocSemiring",
   "Nat.ble",
   "Iff.mp",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "Mathlib.Meta.NormNum.isNat_lt_true.match_1",
   "CharZero",
   "Mathlib.Meta.NormNum.IsNat",
   "Bool.false",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "Bool",
   "Nat",
   "Mathlib.Meta.NormNum.ble_eq_false",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Meta.NormNum.isNat_lt_true",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedSemiring α] [inst_1 : CharZero α] {a b : α} {a' b' : ℕ},\n  Mathlib.Meta.NormNum.IsNat a a' → Mathlib.Meta.NormNum.IsNat b b' → b'.ble a' = false → a < b",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "AddCommMonoid.add_comm",
   "PartENat.instAddCommMonoidWithOne.proof_2",
   "PartENat.addCommMonoid",
   "One.mk",
   "PartENat.instAddCommMonoidWithOne.proof_1",
   "PartENat",
   "One.toOfNat1",
   "AddCommMonoid.toAddMonoid",
   "PartENat.some",
   "NatCast.mk",
   "AddMonoidWithOne.mk",
   "AddCommMonoidWithOne",
   "AddCommMonoidWithOne.mk",
   "PartENat.instOne",
   "AddCommMonoid"],
  "name": "PartENat.instAddCommMonoidWithOne",
  "constType": "AddCommMonoidWithOne PartENat",
  "constCategory": "Definition"},
 {"references":
  ["instCommGroupRelativeUnits",
   "CommGroup.toGroup",
   "DivisionRing.toRing",
   "Algebra.toModule",
   "MulOneClass.toOne",
   "Semifield.toCommSemiring",
   "LieRing.toAddCommGroup",
   "Field.toSemifield",
   "RelativeUnits",
   "MonoidHom",
   "DivInvMonoid.toMonoid",
   "AlgHom",
   "Monoid.toMulOneClass",
   "DivisionSemiring.toSemiring",
   "relativeUnitsMap",
   "AlgHom.End",
   "Monoid.End.inst",
   "relativeUnitsMapHom.proof_1",
   "Field",
   "NumberField",
   "Algebra",
   "relativeUnitsMapHom.proof_2",
   "OneHom.mk",
   "Semifield.toDivisionSemiring",
   "Group.toDivInvMonoid",
   "MonoidHom.mk",
   "LieRing.ofAssociativeRing",
   "Field.toDivisionRing",
   "Monoid.End",
   "FiniteDimensional"],
  "name": "relativeUnitsMapHom",
  "constType":
  "{K : Type u_1} →\n  [inst : Field K] →\n    [inst_1 : NumberField K] →\n      {k : Type u_2} →\n        [inst_2 : Field k] →\n          [inst_3 : NumberField k] →\n            [inst_4 : Algebra k K] → [inst_5 : FiniteDimensional k K] → (K →ₐ[k] K) →* Monoid.End (RelativeUnits k K)",
  "constCategory": "Definition"},
 {"references": ["Set.singleton", "Set", "Singleton", "Singleton.mk"],
  "name": "Set.instSingletonSet",
  "constType": "{α : Type u} → Singleton α (Set α)",
  "constCategory": "Definition"},
 {"references":
  ["Nat.Prime.one_lt",
   "Ne",
   "OfNat.ofNat",
   "LT.lt.ne'",
   "Nat.Prime",
   "Nat.instStrictOrderedSemiring",
   "PartialOrder.toPreorder",
   "StrictOrderedSemiring.toPartialOrder",
   "instOfNatNat",
   "Nat"],
  "name": "Nat.Prime.ne_one",
  "constType": "∀ {p : ℕ}, Nat.Prime p → p ≠ 1",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "Semigroup.toMul",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "IsCoprime",
   "Exists.casesOn",
   "Iff.mpr",
   "Int.instAdd",
   "instDecidableEqNat",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "mul_assoc",
   "Nat.Prime",
   "Iff",
   "Nat.cast",
   "Iff.mp",
   "Int.natCast_dvd",
   "Dvd.dvd.mul_left",
   "Nat.instDvd",
   "Nat",
   "And.casesOn",
   "instOfNat",
   "Int.instDistrib",
   "Int.instDvd",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Nat.Prime.not_coprime_iff_dvd",
   "CommMagma.toMul",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.gcd",
   "Iff.intro",
   "instHMul",
   "And",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "dvd_add",
   "Nat.gcd",
   "Not",
   "congrArg",
   "Int",
   "Int.natCast_dvd_natCast",
   "Int.exists_unit_of_abs",
   "Int.instSemigroup",
   "Exists",
   "CommRing.toNonUnitalCommRing",
   "Eq.refl",
   "Exists.intro",
   "mul_comm",
   "Nat.gcd_eq_gcd_ab",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "Int.ofNat_one",
   "Int.instCommSemigroup",
   "Nat.Prime.not_dvd_one",
   "instOfNatNat",
   "Eq.symm",
   "Decidable.byContradiction",
   "id",
   "Nat.gcdB",
   "False",
   "instHAdd",
   "Int.instMul",
   "One.toOfNat1",
   "Dvd.dvd",
   "Int.instMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "Nat.gcdA",
   "Distrib.leftDistribClass",
   "Semiring.toOne",
   "Int.instCommRing",
   "instNatCastInt",
   "HMul.hMul",
   "Nat.Coprime",
   "IsUnit",
   "Int.gcd_eq_natAbs",
   "Int.instCommSemiring",
   "Int.natAbs"],
  "name": "Int.gcd_eq_one_iff_coprime",
  "constType": "∀ {a b : ℤ}, a.gcd b = 1 ↔ IsCoprime a b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Sub",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["normalize.proof_3",
   "NormalizationMonoid",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "ZeroHom.mk",
   "MulZeroOneClass.toZero",
   "MulZeroOneClass.toMulZeroClass",
   "CancelCommMonoidWithZero",
   "MulZeroClass.toMul",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "normalize.proof_1",
   "MonoidWithZero.toMonoid",
   "NormalizationMonoid.normUnit",
   "normalize.proof_2",
   "Units.val",
   "HMul.hMul",
   "MonoidWithZeroHom",
   "MonoidWithZeroHom.mk",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "normalize",
  "constType":
  "{α : Type u_1} → [inst : CancelCommMonoidWithZero α] → [inst_1 : NormalizationMonoid α] → α →*₀ α",
  "constCategory": "Definition"},
 {"references": ["OmegaCompletePartialOrder", "PartialOrder"],
  "name": "OmegaCompletePartialOrder.toPartialOrder",
  "constType":
  "{α : Type u_1} → [self : OmegaCompletePartialOrder α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalRing.mk",
   "Semiring.toNonUnitalSemiring",
   "NonUnitalCommRing",
   "CommRing.toNonUnitalCommRing.proof_4",
   "CommRing.toNonUnitalCommRing.proof_11",
   "CommRing.toNonUnitalCommRing.proof_8",
   "CommRing.toNonUnitalCommRing.proof_2",
   "AddGroup.mk",
   "CommRing.toNonUnitalCommRing.proof_9",
   "CommRing.toNonUnitalCommRing.proof_1",
   "CommRing.mul_comm",
   "CommRing.toNonUnitalCommRing.proof_7",
   "AddCommMonoid.toAddMonoid",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocRing.mk",
   "Ring.toSemiring",
   "SubNegMonoid.mk",
   "CommRing.toNonUnitalCommRing.proof_5",
   "CommRing",
   "CommRing.toNonUnitalCommRing.proof_10",
   "Ring.zsmul",
   "Ring.toNeg",
   "NonUnitalCommRing.mk",
   "Ring.toSub",
   "CommRing.toRing",
   "CommRing.toNonUnitalCommRing.proof_6",
   "CommRing.toNonUnitalCommRing.proof_3",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "AddCommGroup.mk"],
  "name": "CommRing.toNonUnitalCommRing",
  "constType": "{α : Type u} → [s : CommRing α] → NonUnitalCommRing α",
  "constCategory": "Definition"},
 {"references": ["LinearOrderedRing", "StrictOrderedRing"],
  "name": "LinearOrderedRing.toStrictOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedRing α] → StrictOrderedRing α",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_35",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_36",
   "Lean.Syntax.Preresolved.decl"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_37._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Nat", "Int"],
  "name": "Int.ofNat",
  "constType": "ℕ → ℤ",
  "constCategory": "Other"},
 {"references":
  ["if_pos.match_1",
   "Subsingleton.intro",
   "Decidable.isFalse",
   "Subsingleton",
   "Decidable",
   "Not",
   "Decidable.isTrue",
   "absurd",
   "rfl",
   "Eq"],
  "name": "instSubsingletonDecidable",
  "constType": "∀ (p : Prop), Subsingleton (Decidable p)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_41._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulOneClass.mul_one",
   "MulOneClass",
   "MulOneClass.toOne",
   "HMul.hMul",
   "One.toOfNat1",
   "Eq"],
  "name": "mul_one",
  "constType": "∀ {M : Type u} [inst : MulOneClass M] (a : M), a * 1 = a",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "instHMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid",
   "instAddNat",
   "instHAdd",
   "instHPow",
   "HAdd.hAdd",
   "HMul.hMul",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Monoid.npow_succ",
   "Nat",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "pow_succ",
  "constType":
  "∀ {M : Type u_2} [inst : Monoid M] (a : M) (n : ℕ), a ^ (n + 1) = a ^ n * a",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq"],
  "name": "Eq.mp",
  "constType": "{α β : Sort u} → α = β → α → β",
  "constCategory": "Definition"},
 {"references": ["LinearOrder", "Max"],
  "name": "LinearOrder.toMax",
  "constType": "{α : Type u} → [self : LinearOrder α] → Max α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "AddZeroClass.toAdd",
   "AddLeftCancelMonoid.toZero",
   "OfNat.ofNat",
   "AddLeftCancelMonoid.toAddMonoid",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "AddMonoid.toAddZeroClass",
   "add_right_eq_self",
   "AddLeftCancelMonoid",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.32",
  "constType":
  "∀ {M : Type u} [inst : AddLeftCancelMonoid M] {a b : M}, (a + b = a) = (b = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "SetLike.mem_coe",
   "SetLike",
   "propext",
   "Set",
   "Set.instMembership",
   "SetLike.instMembership",
   "Eq",
   "SetLike.coe"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.3",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {p : A} {x : B}, (x ∈ ↑p) = (x ∈ p)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Nat.cast",
   "MonoidWithZero.toMonoid",
   "Nat.instMonoid",
   "instHPow",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "Monoid.toNatPow",
   "Nat.cast_pow",
   "Nat",
   "Eq.symm",
   "Eq",
   "Semiring.toNatCast"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.16",
  "constType":
  "∀ {α : Type u_1} [inst : Semiring α] (m n : ℕ), ↑m ^ n = ↑(m ^ n)",
  "constCategory": "Theorem"},
 {"references":
  ["eq_iff_true_of_subsingleton", "propext", "Subsingleton", "True", "Eq"],
  "name": "FltRegular.NumberTheory.RegularPrimes._auxLemma.1",
  "constType":
  "∀ {α : Sort u_1} [inst : Subsingleton α] (x y : α), (x = y) = True",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "ZMod.match_1",
   "HAdd.hAdd",
   "Unit",
   "instOfNatNat",
   "Nat",
   "Int",
   "Fin"],
  "name": "ZMod",
  "constType": "ℕ → Type",
  "constCategory": "Definition"},
 {"references":
  ["Multiset",
   "Finset",
   "Multiset.nodup_singleton",
   "Multiset.instSingleton",
   "Singleton.singleton",
   "Finset.mk",
   "Singleton",
   "Singleton.mk"],
  "name": "Finset.instSingleton",
  "constType": "{α : Type u_1} → Singleton α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["IsCyclotomicExtension.exists_prim_root",
   "PNat.val",
   "IsCyclotomicExtension",
   "CommRing.toCommMonoid",
   "Classical.choose_spec",
   "CommSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "Set.instSingletonSet",
   "Set.mem_singleton",
   "IsPrimitiveRoot",
   "Set",
   "Algebra",
   "Singleton.singleton",
   "CommRing",
   "IsCyclotomicExtension.zeta",
   "PNat"],
  "name": "IsCyclotomicExtension.zeta_spec",
  "constType":
  "∀ (n : ℕ+) (A : Type w) (B : Type z) [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B]\n  [inst_3 : IsCyclotomicExtension {n} A B], IsPrimitiveRoot (IsCyclotomicExtension.zeta n A B) ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Exists",
   "Iff",
   "Iff.rfl",
   "Subgroup",
   "Group",
   "MonoidHom.instFunLike",
   "Group.toDivInvMonoid",
   "MonoidHom",
   "DFunLike.coe",
   "MonoidHom.range",
   "DivInvMonoid.toMonoid",
   "Subgroup.instSetLike",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "Eq"],
  "name": "MonoidHom.mem_range",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] {N : Type u_5} [inst_1 : Group N] {f : G →* N} {y : N}, y ∈ f.range ↔ ∃ x, f x = y",
  "constCategory": "Theorem"},
 {"references": ["Or", "propext", "or_true_iff", "True", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.32",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_12",
   "Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lattice.toInf",
   "Lattice",
   "Lattice.le_inf",
   "Lattice.toSemilatticeSup",
   "Lattice.inf_le_right",
   "Lattice.inf_le_left",
   "SemilatticeInf",
   "SemilatticeSup.toPartialOrder",
   "SemilatticeInf.mk"],
  "name": "Lattice.toSemilatticeInf",
  "constType": "{α : Type u} → [self : Lattice α] → SemilatticeInf α",
  "constCategory": "Definition"},
 {"references":
  ["CancelCommMonoidWithZero.toCommMonoidWithZero",
   "GCDMonoid",
   "Dvd.dvd",
   "GCDMonoid.gcd_dvd_left",
   "semigroupDvd",
   "GCDMonoid.gcd_dvd_right",
   "CancelCommMonoidWithZero",
   "Iff.intro",
   "SemigroupWithZero.toSemigroup",
   "And",
   "GCDMonoid.gcd",
   "Iff",
   "MonoidWithZero.toSemigroupWithZero",
   "dvd_gcd_iff.match_1",
   "And.intro",
   "Dvd.dvd.trans",
   "GCDMonoid.dvd_gcd",
   "CommMonoidWithZero.toMonoidWithZero"],
  "name": "dvd_gcd_iff",
  "constType":
  "∀ {α : Type u_1} [inst : CancelCommMonoidWithZero α] [inst_1 : GCDMonoid α] (a b c : α), a ∣ gcd b c ↔ a ∣ b ∧ a ∣ c",
  "constCategory": "Theorem"},
 {"references": ["Int.emod", "Mod.mk", "Mod", "Int"],
  "name": "Int.instMod",
  "constType": "Mod ℤ",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "Exists",
   "Dvd.mk",
   "HMul.hMul",
   "instMulNat",
   "Nat",
   "Dvd",
   "Eq"],
  "name": "Nat.instDvd",
  "constType": "Dvd ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Int.cast_one",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "SubNegMonoid.toNeg",
   "neg_zero",
   "Distrib.rightDistribClass",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Int.cast_add",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Exists.casesOn",
   "AddGroupWithOne.toAddGroup",
   "Nat.cast_zero",
   "Eq",
   "Int.eq_nat_or_neg",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "Nat.recAux",
   "Int.cast_neg",
   "HasDistribNeg.toInvolutiveNeg",
   "Nat",
   "NonAssocRing.toNonAssocSemiring",
   "instOfNat",
   "Eq.trans",
   "Nat.cast_one",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "MulOneClass.toOne",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Or.casesOn",
   "Nat.cast_add",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Int.cast_zero",
   "instHMul",
   "NonAssocRing.toIntCast",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "Int.instAddCommGroup",
   "Eq.mp",
   "CommRing.toRing",
   "congr",
   "congrArg",
   "Int",
   "AddCommGroupWithOne.toAddGroupWithOne",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "NonAssocRing",
   "NonAssocRing.toAddCommGroupWithOne",
   "CommRing.toNonUnitalCommRing",
   "AddGroupWithOne.toIntCast",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "MulZeroClass.zero_mul",
   "Mathlib.Algebra.Group.Basic._auxLemma.18",
   "AddMonoid.toAddZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "True",
   "add_mul",
   "Zero.toOfNat0",
   "one_mul",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "forall_congr",
   "AddMonoid.toAddSemigroup",
   "AddMonoid.toZero",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Int.instNegInt",
   "neg_mul",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "eq_self",
   "Int.cast_natCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "instAddNat",
   "Int.instMul",
   "instHAdd",
   "AddSemigroup.toAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddGroupWithOne.toNeg",
   "implies_true",
   "Neg.neg",
   "One.toOfNat1",
   "SubNegZeroMonoid.toNegZeroClass",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "Eq.ndrec",
   "instNatCastInt",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "NegZeroClass.toZero",
   "neg_add_rev"],
  "name": "Int.cast_mul",
  "constType":
  "∀ {α : Type u_1} [inst : NonAssocRing α] (m n : ℤ), ↑(m * n) = ↑m * ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Subalgebra",
   "algebraRat",
   "algebraInt",
   "Subalgebra.instSetLike",
   "SetLike.instMembership",
   "IsCyclotomicExtension.zeta",
   "PNat.val",
   "IsPrimitiveRoot.adjoinEquivRingOfIntegers'",
   "Rat.commRing",
   "Set.instSingletonSet",
   "Nat.Prime",
   "Field",
   "Polynomial.instCommRingAdjoinSingleton",
   "Subtype",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "IsCyclotomicExtension.zeta_spec",
   "Rat",
   "Field.toSemifield",
   "EuclideanDomain.toCommRing",
   "IsCyclotomicExtension",
   "DivisionSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "IsCyclotomicExtension.equiv",
   "Int.instCommRing",
   "CharZero",
   "Field.toEuclideanDomain",
   "Subalgebra.algebra",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "Singleton.singleton",
   "IsPrimitiveRoot.adjoin_isCyclotomicExtension",
   "NumberField.RingOfIntegers",
   "Int.instCommSemiring",
   "Fact",
   "Field.toDivisionRing",
   "Algebra.adjoin",
   "Int",
   "PNat"],
  "name": "IsCyclotomicExtension.ring_of_integers'",
  "constType":
  "∀ {p : ℕ+} {K : Type u} [inst : Field K] [inst_1 : CharZero K] [hp : Fact (Nat.Prime ↑p)]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K], IsCyclotomicExtension {p} ℤ (NumberField.RingOfIntegers K)",
  "constCategory": "Definition"},
 {"references": ["Option"],
  "name": "Option.none",
  "constType": "{α : Type u} → Option α",
  "constCategory": "Other"},
 {"references":
  ["Int.instSemiring",
   "DistribMulAction.mk",
   "Semiring.toMonoidWithZero",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "AddCommGroup.intModule.proof_3",
   "AddCommGroup.intModule.proof_6",
   "AddCommGroup.intModule.proof_1",
   "SubNegMonoid.SMulInt",
   "AddGroup.toSubNegMonoid",
   "AddCommGroup.intModule.proof_2",
   "MonoidWithZero.toMonoid",
   "MulAction.mk",
   "AddCommGroup.intModule.proof_5",
   "AddCommGroup.toAddGroup",
   "Module",
   "AddCommGroup",
   "Int",
   "Module.mk",
   "AddCommGroup.intModule.proof_4"],
  "name": "AddCommGroup.intModule",
  "constType": "(M : Type u_5) → [inst : AddCommGroup M] → Module ℤ M",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_6",
   "List.cons",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_8",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Exists",
   "Int.eq_ofNat_of_zero_le",
   "OfNat.ofNat",
   "Int.le_of_lt",
   "Int.natAbs_lt_natAbs_of_nonneg_of_lt.match_1",
   "Int.ofNat_lt",
   "LE.le",
   "instLTNat",
   "Int.instLTInt",
   "Eq",
   "Int.le_trans",
   "Iff.mp",
   "Nat.cast",
   "instNatCastInt",
   "LT.lt",
   "Nat",
   "Int",
   "instOfNat",
   "Int.instLEInt",
   "Int.natAbs"],
  "name": "Int.natAbs_lt_natAbs_of_nonneg_of_lt",
  "constType": "∀ {a b : ℤ}, 0 ≤ a → a < b → a.natAbs < b.natAbs",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_one",
   "Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "Units.instInv",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "IsRegularPrime",
   "DivInvMonoid.Pow",
   "IsPrimitiveRoot.ne_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Insert.insert",
   "integralClosure",
   "Subalgebra.instSetLike",
   "Semiring.toNatCast",
   "NumberField.RingOfIntegers.val",
   "Decidable.decide",
   "IsPrimitiveRoot.zpow_eq_one_iff_dvd",
   "IsPrimitiveRoot.unit'",
   "map_mul",
   "instOfNat",
   "ZMod.intCast_mod",
   "Subtype",
   "Fin.mk",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "GroupWithZero.toInv",
   "IsPrimitiveRoot.coe_submonoidClass_iff",
   "instHDiv",
   "instOfNatPNatOfNeZeroNat",
   "Units.instMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NormedCommRing.toNormedRing",
   "Set.instMembership",
   "And",
   "Int.instCharZero",
   "RingHomClass.toMonoidHomClass",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "congr",
   "And.intro",
   "MonoidWithZero.toZero",
   "Field.toDivisionRing",
   "Int.emod_nonneg",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "HEq",
   "Set",
   "Eq.refl",
   "semigroupDvd",
   "NeZero.pnat",
   "zpow_sub₀",
   "Finset.gcd",
   "RingHomClass.toNonUnitalRingHomClass",
   "CyclotomicField.instField",
   "Mathlib.Data.Nat.Cast.Order.Ring._auxLemma.5",
   "Monoid.toNatPow",
   "absurd",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "mul_add",
   "FltRegular.is_principal",
   "of_decide_eq_false",
   "algebraMap",
   "Field.toSemifield",
   "SubmonoidClass.toCommMonoid",
   "Neg.neg",
   "NormedField.toNormedCommRing",
   "GroupWithZero.toMonoidWithZero",
   "LE.le",
   "GroupWithZero.toDiv",
   "Distrib.leftDistribClass",
   "CommRing.toCommSemiring",
   "Eq.ndrec",
   "instNatCastInt",
   "DivisionMonoid.toDivInvMonoid",
   "letFun",
   "PNat.mk_coe",
   "Semifield.toDivisionSemiring",
   "HSub",
   "Subtype.mk",
   "PNat",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "Subalgebra.SubsemiringClass",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Ideal.span",
   "NonUnitalRingHomClass.toMulHomClass",
   "LocalRing.toNontrivial",
   "Int.natAbs_lt_natAbs_of_nonneg_of_lt",
   "ZMod.instField",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Int.cast_mul",
   "Int.instMod",
   "not_false_eq_true",
   "DivisionRing.toDivInvMonoid",
   "Eq.trans",
   "NormedRing.toRing",
   "Int.instDvd",
   "Int.instHPowNat",
   "Finset.instSingleton",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NumberField.Units.coe_zpow",
   "GroupWithZero.toDivInvMonoid",
   "MulZeroOneClass.toMulZeroClass",
   "RingHom.instFunLike",
   "Int.instLTInt",
   "ZMod",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "ValuationRing.of_field",
   "of_eq_true",
   "HEq.refl",
   "Field.toEuclideanDomain",
   "Int.cast",
   "DivInvOneMonoid.toInvOneClass",
   "Eq.mp",
   "CommRing.toRing",
   "zpow_neg",
   "Singleton.singleton",
   "Units.instDivInvMonoid",
   "CommRing.toNonUnitalCommRing",
   "AddGroupWithOne.toIntCast",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Set.instSingletonSet",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "AddMonoid.toZero",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "DFunLike.coe",
   "Int.natAbs_ofNat",
   "id",
   "Membership.mem",
   "eq_self",
   "AddGroupWithOne.toAddMonoidWithOne",
   "False",
   "FltRegular.CaseI.Statement._auxLemma.7",
   "Int.instNormalizedGCDMonoid",
   "AddMonoidWithOne.toAddMonoid",
   "Dvd.dvd",
   "Field.isDomain",
   "NumberField.RingOfIntegers.ext",
   "Units.val",
   "OrderedCommSemiring.toOrderedSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Bool",
   "Eq.casesOn",
   "NumberField.RingOfIntegers",
   "OrderedSemiring.toPartialOrder",
   "map_units_inv",
   "Int.natAbs",
   "add_sub_assoc",
   "RingHom.instRingHomClass",
   "Distrib.toAdd",
   "CommSemiring.toSemiring",
   "sub_self",
   "Int.instDecidableEq",
   "Finset.instInsert",
   "Int.natAbs_of_nonneg",
   "Semifield.toCommGroupWithZero",
   "MulZeroClass.toMul",
   "Iff.mpr",
   "pow_one",
   "AddGroupWithOne.toAddGroup",
   "SubNegMonoid.toSub",
   "Nat.Prime",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "mul_assoc",
   "Nat.cast",
   "HDiv.hDiv",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Int.instSub",
   "InvOneClass.toInv",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "SubsemiringClass.toSubmonoidClass",
   "HPow.hPow",
   "instHSub",
   "eq_of_heq",
   "ValuationRing.localRing",
   "Int.instRing",
   "CommGroupWithZero.toCommMonoidWithZero",
   "CommMagma.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "CyclotomicField",
   "MonoidWithZero.toMulZeroOneClass",
   "CommRing.toCommMonoid",
   "eq_true",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "DivisionMonoid.toDivInvOneMonoid",
   "Int",
   "Fin",
   "Submodule.setLike",
   "NumberField.RingOfIntegers.instAlgebra_1",
   "SetLike.coe",
   "Inv.inv",
   "Exists",
   "Subtype.val",
   "Semiring.toMonoidWithZero",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "algebraInt",
   "True",
   "Field.toCommRing",
   "AddMonoidWithOne.toNatCast",
   "map_pow",
   "Eq.rec",
   "Finset",
   "CommGroupWithZero.toDivisionCommMonoid",
   "Semiring.toModule",
   "DivInvMonoid.toDiv",
   "NeZero.charZero",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Int.instMul",
   "zpow_one",
   "One.toOfNat1",
   "Int.cast_sub",
   "SubNegZeroMonoid.toNegZeroClass",
   "zpow_natCast",
   "DivInvMonoid.toMonoid",
   "InvOneClass.toOne",
   "Units",
   "Int.instCommRing",
   "Int.instLinearOrderedCommRing",
   "Fact.mk",
   "HMod.hMod",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Rat.instNormedField",
   "sub_sub",
   "CyclotomicField.instCharZero",
   "Monoid.toOne",
   "AddGroupWithOne.toSub",
   "Exists.casesOn",
   "instLTNat",
   "SetLike.instMembership",
   "Int.instAdd",
   "Eq",
   "eq_of_div_eq_one",
   "FltRegular.CaseI.Statement._auxLemma.6",
   "Eq.mpr",
   "DivisionCommMonoid.toDivisionMonoid",
   "Nat.Prime.ne_zero",
   "Nat",
   "Ne",
   "Nat.Prime.pos",
   "DivisionSemiring.toGroupWithZero",
   "Fin.val",
   "Int.ModEq",
   "EuclideanDomain.toCommRing",
   "instHMul",
   "NonAssocRing.toIntCast",
   "Int.emod_lt_of_pos",
   "Not",
   "Algebra.id",
   "congrArg",
   "Fact",
   "Ideal",
   "CommGroup.toDivisionCommMonoid",
   "RingHom",
   "DivisionRing.toRing",
   "NumberField.RingOfIntegers.instCommRing",
   "Subalgebra",
   "Fact.out",
   "CommSemiring.toNonUnitalCommSemiring",
   "Ring.toNonAssocRing",
   "PNat.val",
   "mul_comm",
   "Zero.toOfNat0",
   "outParam",
   "instLENat",
   "instHPow",
   "Preorder.toLT",
   "Ring.toSub",
   "Int.instNegInt",
   "Eq.symm",
   "HAdd",
   "Nat.decLe",
   "FltRegular.CaseI.exists_int_sum_eq_zero",
   "NeZero.succ",
   "Rat.instField",
   "instHAdd",
   "CyclotomicField.isCyclotomicExtension",
   "Rat",
   "HSub.hSub",
   "PNat.coe_inj",
   "Int.instCancelCommMonoidWithZero",
   "AddGroup.toSubNegMonoid",
   "Rat.instCharZero",
   "DivisionSemiring.toSemiring",
   "eq_false",
   "instHMod",
   "Units.instCommGroupUnits",
   "FltRegular.CaseI.Statement._auxLemma.8",
   "SubtractionMonoid.toSubNegMonoid",
   "OrderedSemiring.toSemiring",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "zpow_sub_one₀",
   "NegZeroClass.toZero",
   "Mathlib.Algebra.CharZero.Defs._auxLemma.3",
   "HMul",
   "Int.instNontrivial",
   "ZMod.commRing",
   "Dvd"],
  "name": "FltRegular.ex_fin_div",
  "constType":
  "∀ {p : ℕ} [hpri : Fact (Nat.Prime p)] {a b c : ℤ} {ζ : NumberField.RingOfIntegers (CyclotomicField ⟨p, ⋯⟩ ℚ)},\n  5 ≤ p →\n    IsRegularPrime p →\n      IsPrimitiveRoot ζ p →\n        {a, b, c}.gcd id = 1 →\n          ¬↑p ∣ a * b * c →\n            a ^ p + b ^ p = c ^ p → ∃ k₁ k₂, ↑↑k₂ ≡ ↑↑k₁ - 1 [ZMOD ↑p] ∧ ↑p ∣ ↑a + ↑b * ζ - ↑a * ζ ^ ↑k₁ - ↑b * ζ ^ ↑k₂",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_24._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "Iff.rfl",
   "instHAdd",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "Iff",
   "propext",
   "SubNegMonoid.toAddMonoid",
   "NegZeroClass.toNeg",
   "congrArg",
   "add_neg_eq_iff_eq_add",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_eq_iff_eq_add",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, a - b = c ↔ a = c + b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "SemigroupWithZero.toSemigroup",
   "OfNat.ofNat",
   "eq_true",
   "Dvd.dvd",
   "dvd_zero",
   "semigroupDvd",
   "SemigroupWithZero.toZero",
   "True",
   "Eq",
   "SemigroupWithZero"],
  "name": "Mathlib.Algebra.GroupWithZero.Divisibility._auxLemma.2",
  "constType":
  "∀ {α : Type u_1} [inst : SemigroupWithZero α] (a : α), (a ∣ 0) = True",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.matchesNull",
   "Lean.Syntax.isOfKind",
   "Lean.Name.anonymous._impl",
   "Lean.Name.mkStr4",
   "Lean.Syntax.atom",
   "_neutral",
   "Lean.Syntax.getArg",
   "EStateM.Result.error",
   "UInt8",
   "PUnit.unit",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "_obj",
   "Lean.Name.num._override",
   "Bool.false",
   "Lean.replaceRef",
   "Lean.Name.str._override",
   "Lean.SourceInfo.fromRef"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___unexpand_CyclotomicField_1._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Int.instNegInt",
   "Neg.neg",
   "instOfNatNat",
   "Nat",
   "instOfNat",
   "Int",
   "instDecidableEqNat",
   "Eq",
   "ite"],
  "name": "FltRegular.f",
  "constType": "ℤ → ℤ → ℕ → ℕ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references": ["Semiring", "IdemSemiring"],
  "name": "IdemSemiring.toSemiring",
  "constType": "{α : Type u} → [self : IdemSemiring α] → Semiring α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HSub",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references":
  ["Or",
   "OfNat.ofNat",
   "Dvd.dvd",
   "Eq",
   "Iff.intro",
   "Nat.Prime",
   "Iff",
   "Nat.instMonoid",
   "Eq.rec",
   "instOfNatNat",
   "Nat.instDvd",
   "one_dvd",
   "Nat",
   "dvd_rfl",
   "Nat.Prime.eq_one_or_self_of_dvd",
   "Eq.symm",
   "Or.elim"],
  "name": "Nat.dvd_prime",
  "constType": "∀ {p m : ℕ}, Nat.Prime p → (m ∣ p ↔ m = 1 ∨ m = p)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "letFun",
  "constType":
  "{α : Sort u} → {β : α → Sort v} → (v : α) → ((x : α) → β x) → β v",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instBot",
   "FractionalIdeal.coeIdeal",
   "CommSemiring.toSemiring",
   "Bot.bot",
   "OfNat.ofNat",
   "Semiring.toMonoidWithZero",
   "Field.toSemifield",
   "EuclideanDomain.toCommRing",
   "FractionalIdeal.instZero",
   "CommRing",
   "Eq",
   "nonZeroDivisors",
   "FractionalIdeal.coeIdeal_eq_zero",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toEuclideanDomain",
   "propext",
   "Field",
   "Algebra",
   "FractionalIdeal",
   "Semifield.toDivisionSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal",
   "Semiring.toModule",
   "IsFractionRing"],
  "name": "FltRegular.NumberTheory.Different._auxLemma.2",
  "constType":
  "∀ {R : Type u_1} [inst : CommRing R] {K : Type u_3} [inst_1 : Field K] [inst_2 : Algebra R K]\n  [inst_3 : IsFractionRing R K] {I : Ideal R}, (↑I = 0) = (I = ⊥)",
  "constCategory": "Theorem"},
 {"references":
  ["Finset.mem_singleton",
   "Membership.mem",
   "propext",
   "Finset",
   "Finset.instSingleton",
   "Singleton.singleton",
   "Eq",
   "Finset.instMembership"],
  "name": "Mathlib.Data.Finset.Basic._auxLemma.28",
  "constType": "∀ {α : Type u_1} {a b : α}, (b ∈ {a}) = (b = a)",
  "constCategory": "Theorem"},
 {"references":
  ["Distrib.toAdd",
   "LeftDistribClass.mk",
   "LeftDistribClass",
   "Distrib.left_distrib",
   "Distrib",
   "Distrib.toMul"],
  "name": "Distrib.leftDistribClass",
  "constType": "∀ (R : Type u_1) [inst : Distrib R], LeftDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Submodule.instBot",
   "Bot.bot",
   "OfNat.ofNat",
   "Semiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "Submodule.span_eq_bot",
   "Ideal.span",
   "Set.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Ideal",
   "Semiring.toModule"],
  "name": "Ideal.span_eq_bot",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] {s : Set α}, Ideal.span s = ⊥ ↔ ∀ x ∈ s, x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Preorder.toLT",
   "LT.lt",
   "not_le_of_lt",
   "Not",
   "Preorder",
   "LE.le",
   "Preorder.toLE"],
  "name": "LT.lt.not_le",
  "constType": "∀ {α : Type u_2} [inst : Preorder α] {a b : α}, a < b → ¬b ≤ a",
  "constCategory": "Theorem"},
 {"references": ["String", "Lean.SourceInfo", "Lean.Syntax"],
  "name": "Lean.Syntax.atom",
  "constType": "Lean.SourceInfo → String → Lean.Syntax",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "OneMemClass.one",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "Subtype.val",
   "Set",
   "Function.Injective.commMonoid",
   "SubmonoidClass.toCommMonoid.proof_1",
   "Set.instMembership",
   "SubmonoidClass.toCommMonoid.proof_3",
   "SubmonoidClass",
   "SubmonoidClass.toCommMonoid.proof_4",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "SubmonoidClass.toMonoid",
   "SetLike",
   "CommMonoid",
   "SubmonoidClass.toCommMonoid.proof_5",
   "CommMonoid.toMonoid",
   "SubmonoidClass.nPow",
   "Subtype",
   "SubmonoidClass.toCommMonoid.proof_2",
   "SetLike.coe"],
  "name": "SubmonoidClass.toCommMonoid",
  "constType":
  "{M : Type u_6} →\n  [inst : CommMonoid M] →\n    {A : Type u_5} → [inst_1 : SetLike A M] → [inst : SubmonoidClass A M] → (S : A) → CommMonoid ↥S",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Bool.false",
   "LT.lt",
   "Int.decLt",
   "Bool",
   "Lean.Omega.Constraint",
   "Int",
   "Lean.Omega.Constraint.isImpossible.match_1",
   "Int.instLTInt"],
  "name": "Lean.Omega.Constraint.isImpossible",
  "constType": "Lean.Omega.Constraint → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.decide",
   "Bool.false",
   "decide_eq_true",
   "Decidable",
   "of_decide_eq_true.match_1",
   "Not",
   "Bool",
   "absurd",
   "ne_false_of_eq_true",
   "Eq"],
  "name": "of_decide_eq_false",
  "constType": "∀ {p : Prop} [inst : Decidable p], decide p = false → ¬p",
  "constCategory": "Theorem"},
 {"references":
  ["instHMul",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "LeftDistribClass",
   "Add",
   "Mul",
   "left_distrib",
   "Eq"],
  "name": "mul_add",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : LeftDistribClass R] (a b c : R), a * (b + c) = a * b + a * c",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "Finset.instInsert",
   "Int.instDecidableEq",
   "Nat.Prime.odd_of_ne_two",
   "EmptyCollection.emptyCollection",
   "SubNegMonoid.toNeg",
   "HasDistribNeg",
   "IsRegularPrime",
   "FltRegular.CaseII.Statement._auxLemma.4",
   "Insert.insert",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "MulZeroClass.toMul",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.Prime",
   "Nat.cast",
   "MonoidWithZero.toSemigroupWithZero",
   "HasDistribNeg.toInvolutiveNeg",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "LinearOrderedCommSemiring.toLinearOrderedSemiring",
   "instOfNat",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "Or",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "FltRegular.CaseII.Statement._auxLemma.5",
   "neg_eq_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Int.instRing",
   "Int.gcd",
   "And",
   "propext",
   "congr",
   "Int.instStarRing",
   "And.intro",
   "Int",
   "Int.instSemigroup",
   "AddZeroClass.toAdd",
   "Exists",
   "CommMonoidWithZero.toZero",
   "Int.instAddGroup",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "semigroupDvd",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "StarOrderedRing.toExistsAddOfLE",
   "Finset.gcd",
   "True",
   "GCDMonoid.gcd",
   "InvolutiveNeg.toNeg",
   "Finset",
   "Monoid.toNatPow",
   "neg_add_cancel_right",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "CommMonoidWithZero.toMonoidWithZero",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Int.instMul",
   "Int.neg_gcd",
   "Odd.neg_pow",
   "Neg.neg",
   "Int.instMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "Monoid.toMulOneClass",
   "NormedCommRing.toSeminormedCommRing",
   "Int.instLinearOrderedCommRing",
   "Finset.instLawfulSingleton",
   "instNatCastInt",
   "letFun",
   "NegZeroClass.toNeg",
   "FltRegular.not_exists_Int_solution'",
   "Nat.prime_iff_prime_int",
   "MulOneClass.toMul",
   "HAdd.hAdd",
   "Int.instNormedCommRing",
   "ne_eq",
   "NormalizedGCDMonoid.toGCDMonoid",
   "Int.instAdd",
   "Eq",
   "add_neg_cancel_left",
   "Eq.mpr",
   "Iff.mp",
   "Nat",
   "Odd",
   "And.casesOn",
   "Ring.toSubtractionMonoid",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Ne",
   "Monoid",
   "Prime.dvd_or_dvd",
   "Int.instDvd",
   "Int.instHPowNat",
   "Nat.instSemiring",
   "Finset.instSingleton",
   "Int.instStarOrderedRing",
   "Or.casesOn",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Prime",
   "of_eq_true",
   "Eq.mp",
   "Not",
   "Singleton.singleton",
   "FltRegular.CaseII.Statement._auxLemma.11",
   "congrArg",
   "Fact",
   "Finset.instEmptyCollection",
   "LinearOrderedSemiring.noZeroDivisors",
   "FltRegular.Int.gcd_left_comm",
   "LinearOrderedRing.toStrictOrderedRing",
   "Fact.out",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "Zero.toOfNat0",
   "instHPow",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Int.instNegInt",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "id",
   "eq_self",
   "False",
   "instHAdd",
   "Int.instNormalizedGCDMonoid",
   "Dvd.dvd",
   "Int.instCancelCommMonoidWithZero",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "Finset.gcd_insert",
   "HMul.hMul",
   "dvd_neg",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Int.instCommSemiring",
   "NegZeroClass.toZero",
   "neg_add_rev"],
  "name": "FltRegular.caseII",
  "constType":
  "∀ {a b c : ℤ} {p : ℕ} [hpri : Fact (Nat.Prime p)],\n  IsRegularPrime p → p ≠ 2 → a * b * c ≠ 0 → {a, b, c}.gcd id = 1 → ↑p ∣ a * b * c → a ^ p + b ^ p ≠ c ^ p",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "Ne",
   "OfNat.ofNat",
   "Nat.sub_ne_zero_of_lt",
   "instSubNat",
   "LT.lt",
   "HSub.hSub",
   "Nat.pos_iff_ne_zero",
   "instOfNatNat",
   "Nat",
   "instLTNat",
   "Iff.mpr"],
  "name": "Nat.sub_pos_of_lt",
  "constType": "∀ {m n : ℕ}, m < n → 0 < n - m",
  "constCategory": "Theorem"},
 {"references":
  ["instHMod",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "HMod.hMod",
   "instOfNatNat",
   "Nat",
   "Nat.instMod",
   "Nat.succ",
   "Nat.add_lt_add_right",
   "Nat.mod_eq_of_lt",
   "Eq",
   "Nat.succ_pos"],
  "name": "Nat.one_mod",
  "constType": "∀ (n : ℕ), 1 % (n + 2) = 1",
  "constCategory": "Theorem"},
 {"references":
  ["False.elim", "False", "Decidable", "Not", "Decidable.byCases", "id"],
  "name": "Decidable.byContradiction",
  "constType": "∀ {p : Prop} [dec : Decidable p], (¬p → False) → p",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "CommSemiring.toSemiring",
   "Set",
   "Dvd.dvd",
   "CommSemiring.toNonUnitalCommSemiring",
   "Ideal.span",
   "semigroupDvd",
   "SetLike.instMembership",
   "Eq",
   "SemigroupWithZero.toSemigroup",
   "Semiring.toNonAssocSemiring",
   "Set.instSingletonSet",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Ideal.mem_span_singleton",
   "Ideal",
   "Submodule.setLike",
   "Semiring.toModule"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.7",
  "constType":
  "∀ {α : Type u} [inst : CommSemiring α] {x y : α}, (x ∈ Ideal.span {y}) = (y ∣ x)",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "Finsupp.instFunLike",
   "Finsupp",
   "propext",
   "Finset",
   "DFunLike.coe",
   "Finsupp.mem_support_iff",
   "Eq",
   "Finsupp.support",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.1",
  "constType":
  "∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {f : α →₀ M} {a : α}, (a ∈ f.support) = (f a ≠ 0)",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.symm",
   "Iff",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "LT.lt",
   "GE.ge",
   "Not",
   "LinearOrder.toPartialOrder",
   "LE.le",
   "Preorder.toLE",
   "lt_iff_not_ge"],
  "name": "not_le",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a ≤ b ↔ b < a",
  "constCategory": "Theorem"},
 {"references": ["False", "propext", "Not", "True", "Eq", "not_false_iff"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.13",
  "constType": "(¬False) = True",
  "constCategory": "Theorem"},
 {"references":
  ["inferInstance",
   "Int.instAddCommGroup",
   "SubNegMonoid.toAddMonoid",
   "AddCommGroup.toAddGroup",
   "AddGroup.toSubNegMonoid",
   "Int",
   "AddMonoid"],
  "name": "Int.instAddMonoid",
  "constType": "AddMonoid ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Iff",
   "instHAdd",
   "Iff.rfl",
   "LT.lt",
   "HAdd.hAdd",
   "instOfNat",
   "LE.le",
   "Int",
   "Int.instLTInt",
   "Int.instAdd",
   "Int.instLEInt"],
  "name": "Int.add_one_le_iff",
  "constType": "∀ {a b : ℤ}, a + 1 ≤ b ↔ a < b",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "NeZero",
   "One",
   "NeZero.ne'",
   "One.toOfNat1"],
  "name": "zero_ne_one",
  "constType":
  "∀ {α : Type u_2} [inst : Zero α] [inst_1 : One α] [inst_2 : NeZero 1], 0 ≠ 1",
  "constCategory": "Theorem"},
 {"references":
  ["CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_4",
   "Semiring.mk",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_2",
   "CanonicallyOrderedCommSemiring.toMul",
   "CanonicallyOrderedCommSemiring.natCast_succ",
   "CanonicallyOrderedCommSemiring.npow",
   "OrderedSemiring.mk",
   "CanonicallyOrderedCommSemiring",
   "CanonicallyOrderedCommSemiring.mul_comm",
   "CanonicallyOrderedCommSemiring.right_distrib",
   "CanonicallyOrderedCommSemiring.toNatCast",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_1",
   "CanonicallyOrderedCommSemiring.toOne",
   "OrderedCommSemiring",
   "NonUnitalNonAssocSemiring.mk",
   "CanonicallyOrderedCommSemiring.npow_zero",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.mul_one",
   "CanonicallyOrderedCommSemiring.npow_succ",
   "CanonicallyOrderedCommSemiring.mul_zero",
   "NonUnitalSemiring.mk",
   "CanonicallyOrderedCommSemiring.left_distrib",
   "CanonicallyOrderedCommSemiring.mul_assoc",
   "OrderedCommSemiring.mk",
   "CanonicallyOrderedCommSemiring.one_mul",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "CanonicallyOrderedCommSemiring.natCast_zero",
   "CanonicallyOrderedCommSemiring.zero_mul",
   "CanonicallyOrderedCommSemiring.toOrderedCommSemiring.proof_3",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "CanonicallyOrderedCommSemiring.toOrderedCommSemiring",
  "constType":
  "{α : Type u} → [inst : CanonicallyOrderedCommSemiring α] → OrderedCommSemiring α",
  "constCategory": "Definition"},
 {"references":
  ["PNat.val",
   "inferInstance",
   "DivisionRing.toRing",
   "Field",
   "Field.toDivisionRing",
   "CyclotomicField",
   "Polynomial.SplittingField",
   "Polynomial.SplittingField.instField",
   "Polynomial.cyclotomic",
   "id",
   "PNat"],
  "name": "CyclotomicField.instField",
  "constType":
  "(n : ℕ+) → (K : Type w) → [inst : Field K] → Field (CyclotomicField n K)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "AddZeroClass.toAdd",
   "Distrib.toAdd",
   "instHSub",
   "Ring.toAddGroupWithOne",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "True",
   "AddGroupWithOne.toAddGroup",
   "Ring.toNonAssocRing",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SubNegMonoid.toSub",
   "Ring.toNeg",
   "Eq.ndrec",
   "of_eq_true",
   "SubNegMonoid.toAddMonoid",
   "Ring",
   "Ring.toSub",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.sub_pf",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a b c d : R}, -b = c → a + c = d → a - b = d",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "CommRing",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_2",
   "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_1"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "GCDMonoid.gcd",
   "CancelCommMonoidWithZero.toCommMonoidWithZero",
   "instAssociativeGcd",
   "instCommutativeGcd",
   "Finset",
   "Finset.fold",
   "NormalizedGCDMonoid",
   "NormalizedGCDMonoid.toGCDMonoid",
   "CancelCommMonoidWithZero"],
  "name": "Finset.gcd",
  "constType":
  "{α : Type u_2} →\n  {β : Type u_3} → [inst : CancelCommMonoidWithZero α] → [inst : NormalizedGCDMonoid α] → Finset β → (β → α) → α",
  "constCategory": "Definition"},
 {"references":
  ["PNat.val",
   "NeZero",
   "NeZero.mk",
   "Zero.ofOfNat0",
   "PNat.ne_zero",
   "instOfNatNat",
   "Nat",
   "PNat"],
  "name": "NeZero.pnat",
  "constType": "∀ {a : ℕ+}, NeZero ↑a",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr1",
  "constType": "String → Lean.Name",
  "constCategory": "Definition"},
 {"references": ["Iff", "Iff.rfl", "GE.ge", "LE", "LE.le"],
  "name": "ge_iff_le",
  "constType": "∀ {α : Type u} [inst : LE α] {x y : α}, x ≥ y ↔ y ≤ x",
  "constCategory": "Theorem"},
 {"references":
  ["eq_true",
   "Fin.val",
   "LT.lt",
   "Fin.is_lt",
   "Nat",
   "instLTNat",
   "True",
   "Fin",
   "Eq"],
  "name": "Init.Data.Fin.Lemmas._auxLemma.1",
  "constType": "∀ {n : ℕ} (a : Fin n), (↑a < n) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "mul_assoc",
   "HMul.hMul",
   "Eq.symm",
   "Semigroup",
   "Eq"],
  "name": "FltRegular.CaseII.AuxLemmas._auxLemma.1",
  "constType":
  "∀ {G : Type u_1} [inst : Semigroup G] (a b c : G), a * (b * c) = a * b * c",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_17",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_10",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_18._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_10",
   "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_8"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "FltRegular.NumberTheory.Finrank._auxLemma.11",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congr",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {f₁ f₂ : α → β} {a₁ a₂ : α}, f₁ = f₂ → a₁ = a₂ → f₁ a₁ = f₂ a₂",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "Neg.neg",
   "neg_add_cancel_left",
   "AddMonoid.toAddZeroClass",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "add_neg_cancel_left",
   "Iff.intro",
   "Eq.mpr",
   "Iff",
   "AddGroup",
   "SubNegMonoid.toAddMonoid",
   "Eq.symm",
   "NegZeroClass.toNeg",
   "congrArg",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "neg_add_eq_iff_eq_add",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, -a + b = c ↔ b = a + c",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "instHSub",
   "SubNegMonoid.toSub",
   "OfNat.ofNat",
   "AddGroup",
   "propext",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_zero",
   "SubNegZeroMonoid.toNegZeroClass",
   "NegZeroClass.toZero",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.14",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, (a - b = 0) = (a = b)",
  "constCategory": "Theorem"},
 {"references": ["False", "False.rec"],
  "name": "False.elim",
  "constType": "{C : Sort u} → False → C",
  "constCategory": "Definition"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "Lean.Name.num",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.Name.str"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termR_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "MulZeroOneClass.toMulOneClass",
   "Module.Finite",
   "Submodule.completeLattice",
   "Ideal.span",
   "implies_congr",
   "SetLike.instMembership",
   "Preorder.toLE",
   "nonZeroDivisors",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "Algebra",
   "Set.image",
   "Algebra.toSMul",
   "Eq.trans",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "OreLocalization.instCommRing",
   "NoZeroSMulDivisors",
   "Submodule.instBot",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "OreLocalization.instRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Set.instMembership",
   "MonoidHom",
   "Module.Free",
   "And",
   "CommRing.toCommMonoid",
   "FltRegular.NumberTheory.IdealNorm._auxLemma.3",
   "FractionRing",
   "Submodule.instOrderBot",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "OrderBot.toBot",
   "CommRing.toRing",
   "congr",
   "FltRegular.NumberTheory.IdealNorm._auxLemma.1",
   "Ideal.spanIntNorm",
   "MonoidHom.instFunLike",
   "MonoidWithZero.toZero",
   "congrArg",
   "FltRegular.NumberTheory.IdealNorm._auxLemma.5",
   "Ideal",
   "Submodule.setLike",
   "SetLike.coe",
   "Exists",
   "CommMonoidWithZero.toZero",
   "Iff.rfl",
   "CommRing.toNonUnitalCommRing",
   "Set",
   "IsDomain",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "FractionRing.field",
   "FltRegular.NumberTheory.IdealNorm._auxLemma.7",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "Zero.toOfNat0",
   "FltRegular.NumberTheory.IdealNorm._auxLemma.6",
   "eq_bot_iff",
   "forall_congr",
   "OreLocalization.oreSetComm",
   "FractionRing.liftAlgebra",
   "IsIntegrallyClosed",
   "CommSemiring.toCommMonoidWithZero",
   "DFunLike.coe",
   "FltRegular.NumberTheory.IdealNorm._auxLemma.8",
   "Semiring.toModule",
   "Algebra.intNorm",
   "id",
   "Membership.mem",
   "funext",
   "Bot.bot",
   "Algebra.toModule",
   "FltRegular.NumberTheory.IdealNorm._auxLemma.4",
   "LE.le",
   "FltRegular.NumberTheory.IdealNorm._auxLemma.2",
   "OreLocalization.instAlgebra",
   "CommRing.toCommSemiring",
   "FractionRing.instNoZeroSMulDivisors",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.IsSeparable"],
  "name": "Ideal.spanIntNorm_eq_bot_iff",
  "constType":
  "∀ {R : Type u_1} [inst : CommRing R] {S : Type u_2} [inst_1 : CommRing S] [inst_2 : Algebra R S]\n  [inst_3 : IsIntegrallyClosed R] [inst_4 : IsDomain R] [inst_5 : IsDomain S] [inst_6 : NoZeroSMulDivisors R S]\n  [inst_7 : IsIntegrallyClosed S] [inst_8 : Algebra.IsSeparable (FractionRing R) (FractionRing S)] [inst_9 : IsDomain R]\n  [inst_10 : IsDomain S] [inst_11 : Module.Free R S] [inst_12 : Module.Finite R S] {I : Ideal S},\n  Ideal.spanIntNorm R I = ⊥ ↔ I = ⊥",
  "constCategory": "Theorem"},
 {"references": ["AddCommMagma", "Add"],
  "name": "AddCommMagma.toAdd",
  "constType": "{G : Type u} → [self : AddCommMagma G] → Add G",
  "constCategory": "Definition"},
 {"references":
  ["Array",
   "Lean.Syntax.missing",
   "Lean.SyntaxNodeKind",
   "Lean.Syntax.setKind.match_1",
   "Lean.SourceInfo",
   "Nat",
   "Lean.Syntax",
   "Array.getD"],
  "name": "Lean.Syntax.getArg",
  "constType": "Lean.Syntax → ℕ → Lean.Syntax",
  "constCategory": "Definition"},
 {"references": ["MulOneClass"],
  "name": "MonoidHom",
  "constType":
  "(M : Type u_10) → (N : Type u_11) → [inst : MulOneClass M] → [inst : MulOneClass N] → Type (max u_10 u_11)",
  "constCategory": "Other"},
 {"references": ["Set", "Set.Mem", "Membership.mk", "Membership"],
  "name": "Set.instMembership",
  "constType": "{α : Type u} → Membership α (Set α)",
  "constCategory": "Definition"},
 {"references": ["trivial", "Or", "eq_true", "Or.inr", "True", "Eq"],
  "name": "or_true",
  "constType": "∀ (p : Prop), (p ∨ True) = True",
  "constCategory": "Theorem"},
 {"references":
  ["instHMod", "Int.ModEq", "HMod.hMod", "Int.instMod", "Eq.symm", "Int"],
  "name": "Int.ModEq.symm",
  "constType": "∀ {n a b : ℤ}, a ≡ b [ZMOD n] → b ≡ a [ZMOD n]",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "Exists",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "Iff.rfl",
   "Subtype.val",
   "Set",
   "Semiring.toMonoidWithZero",
   "MulZeroClass.zero_mul",
   "NonAssocSemiring.toMulZeroOneClass",
   "MulZeroClass.toMul",
   "SetLike.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "IsLocalization.mk'_spec",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Iff",
   "MonoidWithZero.toMonoid",
   "CommSemiring",
   "Algebra",
   "MulZeroClass.toZero",
   "DFunLike.coe",
   "CommSemiring.toCommMonoidWithZero",
   "Eq.symm",
   "Submonoid.instSetLike",
   "Subtype",
   "id",
   "Membership.mem",
   "IsLocalization.map_units",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "IsLocalization.mk'",
   "algebraMap",
   "IsLocalization",
   "Set.instMembership",
   "NonUnitalNonAssocSemiring.toMul",
   "RingHom.instFunLike",
   "Monoid.toMulOneClass",
   "IsUnit.mul_left_inj",
   "IsLocalization.map_eq_zero_iff",
   "instHMul",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Submonoid",
   "HMul.hMul",
   "congrArg",
   "SetLike.coe"],
  "name": "IsLocalization.mk'_eq_zero_iff",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] (x : R) (s : ↥M), IsLocalization.mk' S x s = 0 ↔ ∃ m, ↑m * x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Name.num._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_13"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_14._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Distrib.toAdd",
   "add_assoc",
   "CommSemiring.toSemiring",
   "AddCommSemigroup.toAddCommMagma",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "AddCommMagma.toAdd",
   "add_left_comm",
   "True",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toNonAssocSemiring",
   "Eq.ndrec",
   "of_eq_true",
   "AddMonoid.toAddSemigroup",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "congr",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b₁ b₂ c₁ c₂ : R},\n  a₁ + b₁ = c₁ → a₂ + b₂ = c₂ → a₁ + a₂ + (b₁ + b₂) = c₁ + c₂",
  "constCategory": "Theorem"},
 {"references": ["Nat", "Lean.Name"],
  "name": "Lean.Name.num",
  "constType": "Lean.Name → ℕ → Lean.Name",
  "constCategory": "Other"},
 {"references":
  ["CommSemiring.toSemiring",
   "CommRing.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "Algebra",
   "IsLocalization",
   "CommRing",
   "nonZeroDivisors"],
  "name": "IsFractionRing",
  "constType":
  "(R : Type u_1) → [inst : CommRing R] → (K : Type u_5) → [inst_1 : CommRing K] → [inst : Algebra R K] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Int.ModEq",
   "Int.mod_modEq",
   "ZMod",
   "Eq",
   "Eq.mpr",
   "instHMod",
   "Nat.cast",
   "instNatCastInt",
   "propext",
   "Int.cast",
   "Ring.toIntCast",
   "CommRing.toRing",
   "HMod.hMod",
   "Nat",
   "Int.instMod",
   "congrArg",
   "Int",
   "ZMod.intCast_eq_intCast_iff",
   "ZMod.commRing",
   "id"],
  "name": "ZMod.intCast_mod",
  "constType": "∀ (a : ℤ) (b : ℕ), ↑(a % ↑b) = ↑a",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_12",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_11"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_13._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Top.top",
   "Set",
   "Semiring.toMonoidWithZero",
   "Submodule.instTop",
   "Ideal.span",
   "Eq",
   "Set.instSingletonSet",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Ideal.span_singleton_eq_top",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IsUnit",
   "Ideal",
   "Semiring.toModule"],
  "name": "FltRegular.NumberTheory.CyclotomicRing._auxLemma.1",
  "constType":
  "∀ {α : Type u} [inst : CommSemiring α] {x : α}, (Ideal.span {x} = ⊤) = IsUnit x",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "CommSemiring.mul_comm",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "Semiring.toOne",
   "Semiring.npow",
   "CommMonoid",
   "CommSemiring",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "CommSemiring.toCommMonoid",
  "constType": "{R : Type u} → [self : CommSemiring R] → CommMonoid R",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Subsingleton",
  "constType": "Sort u → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "IsPrimitiveRoot.unit'.proof_2",
   "CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "IsPrimitiveRoot",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "Subalgebra",
   "Field.toInv",
   "algebraInt",
   "EuclideanDomain.toCommRing",
   "integralClosure",
   "Subalgebra.instSetLike",
   "SetLike.instMembership",
   "PNat.val",
   "Units",
   "CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "IsPrimitiveRoot.unit'.proof_4",
   "MonoidWithZero.toMonoid",
   "IsPrimitiveRoot.unit'.proof_3",
   "Field.toEuclideanDomain",
   "Field",
   "IsPrimitiveRoot.unit'.proof_1",
   "Field.toDivisionRing",
   "NumberField.RingOfIntegers",
   "Int",
   "Units.mk",
   "Subtype.mk",
   "Inv.inv",
   "PNat"],
  "name": "IsPrimitiveRoot.unit'",
  "constType":
  "{p : ℕ+} → {K : Type u_1} → [inst : Field K] → {ζ : K} → IsPrimitiveRoot ζ ↑p → (NumberField.RingOfIntegers K)ˣ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "OfNat.ofNat",
   "Monoid.toOne",
   "PartialOrder.toPreorder",
   "IsPrimitiveRoot",
   "AddGroup.toSubtractionMonoid",
   "dite",
   "DivInvMonoid.Pow",
   "inv_one",
   "inv_inj",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Exists.casesOn",
   "Preorder.toLE",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "Iff",
   "DivisionCommMonoid.toDivisionMonoid",
   "HasDistribNeg.toInvolutiveNeg",
   "DivisionCommMonoid.toCommMonoid",
   "DivisionCommMonoid",
   "Nat.instDvd",
   "le_of_lt",
   "Nat",
   "Mathlib.RingTheory.RootsOfUnity.Basic._auxLemma.22",
   "InvOneClass.toInv",
   "instOfNat",
   "HPow.hPow",
   "StrictOrderedRing.toPartialOrder",
   "instCanLiftIntNatCastLeOfNat",
   "Mathlib.RingTheory.RootsOfUnity.Basic._auxLemma.21",
   "Int.instDvd",
   "IsPrimitiveRoot.pow_eq_one_iff_dvd",
   "propext",
   "DivInvOneMonoid.toInvOneClass",
   "LT.lt",
   "Eq.mp",
   "zpow_neg",
   "Not",
   "LinearOrder.toPartialOrder",
   "DivisionMonoid.toDivInvOneMonoid",
   "congrArg",
   "Int",
   "Int.instLEInt",
   "Inv.inv",
   "Int.instSemigroup",
   "Int.decLe",
   "Exists",
   "Int.instLinearOrder",
   "Int.instAddGroup",
   "LinearOrderedRing.toStrictOrderedRing",
   "Iff.rfl",
   "CommRing.toNonUnitalCommRing",
   "CanLift.prf",
   "semigroupDvd",
   "Zero.toOfNat0",
   "InvolutiveNeg.toNeg",
   "instHPow",
   "Int.instCovariantClassAddLE",
   "Preorder.toLT",
   "Monoid.toNatPow",
   "Init.Data.Int.DivModLemmas._auxLemma.1",
   "Int.instNegInt",
   "InvolutiveInv.toInv",
   "CommMonoid.toMonoid",
   "DivisionMonoid.toInvolutiveInv",
   "Eq.symm",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "Dvd.dvd",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "DivInvMonoid.toMonoid",
   "zpow_natCast",
   "LE.le",
   "InvOneClass.toOne",
   "Int.instCommRing",
   "Int.instLinearOrderedCommRing",
   "Eq.ndrec",
   "instNatCastInt",
   "DivisionMonoid.toDivInvMonoid",
   "letFun",
   "dvd_neg",
   "NegZeroClass.toZero"],
  "name": "IsPrimitiveRoot.zpow_eq_one_iff_dvd",
  "constType":
  "∀ {G : Type u_3} [inst : DivisionCommMonoid G] {k : ℕ} {ζ : G}, IsPrimitiveRoot ζ k → ∀ (l : ℤ), ζ ^ l = 1 ↔ ↑k ∣ l",
  "constCategory": "Theorem"},
 {"references": ["List", "Lean.Omega.Coeffs", "Int"],
  "name": "Lean.Omega.Coeffs.ofList",
  "constType": "List ℤ → Lean.Omega.Coeffs",
  "constCategory": "Definition"},
 {"references": ["propext", "Subtype.forall", "Subtype.mk", "Subtype", "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.13",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∀ (x : { a // p a }), q x) = ∀ (a : α) (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references": ["Decidable.casesOn", "Decidable", "Not"],
  "name": "ite",
  "constType": "{α : Sort u} → (c : Prop) → [h : Decidable c] → α → α → α",
  "constCategory": "Definition"},
 {"references":
  ["or_self",
   "Ne",
   "OfNat.ofNat",
   "Or",
   "False",
   "True",
   "Eq",
   "instHMul",
   "And",
   "eq_false",
   "Nat.Prime",
   "of_eq_true",
   "and_false",
   "congr",
   "HMul.hMul",
   "instOfNatNat",
   "Not",
   "Mathlib.Data.Nat.Prime.Defs._auxLemma.5",
   "Nat",
   "instMulNat",
   "not_false_eq_true",
   "congrArg",
   "Eq.trans"],
  "name": "Nat.not_prime_mul",
  "constType": "∀ {a b : ℕ}, a ≠ 1 → b ≠ 1 → ¬Nat.Prime (a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "DivisionRing.toRing",
   "Semifield.toCommSemiring",
   "algebraMap",
   "NumberField.RingOfIntegers.instCommRing",
   "Field.toSemifield",
   "RingHom.instFunLike",
   "CommRing.toCommSemiring",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "Field",
   "Semifield.toDivisionSemiring",
   "DFunLike.coe",
   "Algebra.id",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "NumberField.RingOfIntegers.instAlgebra_1"],
  "name": "NumberField.RingOfIntegers.val",
  "constType":
  "{K : Type u_1} → [inst : Field K] → NumberField.RingOfIntegers K → K",
  "constCategory": "Definition"},
 {"references":
  ["Ideal.Quotient.commRing",
   "Ideal.Quotient.algebra",
   "RingHom",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "algebraMap",
   "Ideal.Quotient.mk",
   "Algebra.id",
   "HasQuotient.Quotient",
   "Ideal.instHasQuotient",
   "rfl",
   "Ideal",
   "CommRing",
   "Eq"],
  "name": "Ideal.Quotient.algebraMap_eq",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] (I : Ideal R), algebraMap R (R ⧸ I) = Ideal.Quotient.mk I",
  "constCategory": "Theorem"},
 {"references":
  ["Submonoid.mk",
   "integralClosure.proof_1",
   "CommSemiring.toSemiring",
   "integralClosure.proof_3",
   "MulOneClass.toMul",
   "setOf",
   "MulZeroOneClass.toMulOneClass",
   "Subsemiring.mk",
   "IsIntegral.add",
   "Subalgebra",
   "IsIntegral.mul",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "Subalgebra.mk",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "Subsemigroup.mk",
   "Algebra",
   "CommRing.toRing",
   "integralClosure.proof_2",
   "IsIntegral"],
  "name": "integralClosure",
  "constType":
  "(R : Type u_1) → (A : Type u_2) → [inst : CommRing R] → [inst_1 : CommRing A] → [inst_2 : Algebra R A] → Subalgebra R A",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "Ne",
   "CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "Eq.rec",
   "CommMonoidWithZero.toCommMonoid",
   "IsPrimitiveRoot.unique",
   "instOfNatNat",
   "Nontrivial",
   "Nat",
   "Eq.symm",
   "mt",
   "IsPrimitiveRoot.zero",
   "CommMonoidWithZero",
   "Eq"],
  "name": "IsPrimitiveRoot.ne_zero",
  "constType":
  "∀ {k : ℕ} {M₀ : Type u_7} [inst : CommMonoidWithZero M₀] [inst_1 : Nontrivial M₀] {ζ : M₀},\n  IsPrimitiveRoot ζ k → k ≠ 0 → ζ ≠ 0",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Iff",
   "AddMonoid.toZero",
   "LE.le.le_iff_eq",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "zero_le",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toPartialOrder",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "nonpos_iff_eq_zero",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] {a : α}, a ≤ 0 ↔ a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["NormalizationMonoid", "NormalizedGCDMonoid", "CancelCommMonoidWithZero"],
  "name": "NormalizedGCDMonoid.toNormalizationMonoid",
  "constType":
  "{α : Type u_2} → [inst : CancelCommMonoidWithZero α] → [self : NormalizedGCDMonoid α] → NormalizationMonoid α",
  "constCategory": "Definition"},
 {"references": ["Or", "Not", "absurd", "Or.elim", "id"],
  "name": "Or.resolve_right",
  "constType": "∀ {a b : Prop}, a ∨ b → ¬b → a",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "String",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "RightDistribClass",
   "RightDistribClass.mk",
   "Distrib",
   "Distrib.right_distrib",
   "Distrib.toMul"],
  "name": "Distrib.rightDistribClass",
  "constType": "∀ (R : Type u_1) [inst : Distrib R], RightDistribClass R",
  "constCategory": "Definition"},
 {"references":
  ["Int.ofNat",
   "UInt8",
   "Bool.casesOn",
   "Nat.pred",
   "_obj",
   "Nat.decEq",
   "Int.neg"],
  "name": "FltRegular.CaseI.f0k₁._cstage2",
  "constType": "_obj → _obj → _obj → _obj",
  "constCategory": "Definition"},
 {"references":
  ["Int.instAddGroup",
   "Nat.cast",
   "instNatCastInt",
   "Int.abs_eq_natAbs",
   "abs",
   "Eq.symm",
   "Int",
   "Eq",
   "Int.natAbs",
   "instLatticeInt"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.15",
  "constType": "∀ (a : ℤ), ↑a.natAbs = |a|",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing",
   "NonUnitalCommRing.mul_comm",
   "NonUnitalNonAssocCommRing.mk",
   "NonUnitalNonAssocCommRing",
   "NonUnitalRing.toNonUnitalNonAssocRing",
   "NonUnitalCommRing.toNonUnitalRing"],
  "name": "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
  "constType":
  "{α : Type u} → [self : NonUnitalCommRing α] → NonUnitalNonAssocCommRing α",
  "constCategory": "Definition"},
 {"references": ["outParam"],
  "name": "HMul",
  "constType": "Type u → Type v → outParam (Type w) → Type (max (max u v) w)",
  "constCategory": "Other"},
 {"references": ["Or", "Iff", "False", "or_false", "iff_of_eq"],
  "name": "or_false_iff",
  "constType": "∀ (p : Prop), p ∨ False ↔ p",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM",
   "OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.MacroM",
   "Lean.Name.mkStr1",
   "Lean.Macro.instMonadQuotationMacroM",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Macro.instMonadRefMacroM",
   "Eq",
   "ite",
   "EStateM.instMonad",
   "Lean.MonadQuotation.getCurrMacroScope",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.true",
   "PUnit",
   "Lean.Macro.Exception",
   "instOfNatNat",
   "List.nil",
   "Bind.bind",
   "Nat",
   "Lean.Name.anonymous",
   "Applicative.toPure",
   "instDecidableEqBool",
   "Lean.Syntax.node2",
   "List.cons",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "Lean.Name.mkStr4",
   "Lean.TSyntax.raw",
   "Lean.Macro",
   "Lean.TSyntax.mk",
   "instMonadExceptOfMonadExceptOf",
   "Lean.Syntax.atom",
   "ReaderT.instMonadExceptOf",
   "Lean.Syntax.getArg",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "EStateM.instMonadExceptOfOfBacktrackable",
   "Lean.MacroScope",
   "Lean.MonadRef.mkInfoFromRefPos",
   "Lean.Name.mkStr2",
   "ReaderT.instApplicativeOfMonad",
   "Lean.MonadQuotation.getMainModule",
   "Lean.SyntaxNodeKind",
   "Lean.Name.mkNum",
   "letFun",
   "EStateM.nonBacktrackable",
   "MonadExcept.throw",
   "Lean.SourceInfo",
   "Bool",
   "ReaderT.instMonad",
   "Lean.Name"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termR_1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "Monoid.toOne",
   "Trans.trans",
   "MulZeroOneClass.toMulOneClass",
   "HAdd.hAdd",
   "Int.sub_add_cancel",
   "zpow_add_one₀",
   "Eq.refl",
   "DivInvMonoid.Pow",
   "Int.instAdd",
   "MulZeroClass.toMul",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "mul_assoc",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "MonoidWithZero.toSemigroupWithZero",
   "Eq.symm",
   "Int.instSub",
   "mul_inv_cancel",
   "instOfNat",
   "GroupWithZero.toInv",
   "id",
   "instHSub",
   "HPow.hPow",
   "Ne",
   "instHAdd",
   "MulOneClass.toOne",
   "HSub.hSub",
   "One.toOfNat1",
   "GroupWithZero.toDivInvMonoid",
   "GroupWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "MonoidWithZero.toMulZeroOneClass",
   "GroupWithZero",
   "instTransEq",
   "HMul.hMul",
   "mul_one",
   "MonoidWithZero.toZero",
   "congrArg",
   "Int",
   "Inv.inv"],
  "name": "zpow_sub_one₀",
  "constType":
  "∀ {G₀ : Type u_3} [inst : GroupWithZero G₀] {a : G₀}, a ≠ 0 → ∀ (n : ℤ), a ^ (n - 1) = a ^ n * a⁻¹",
  "constCategory": "Theorem"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "AlgEquiv.aut",
   "CommSemiring.toSemiring",
   "AlgEquiv",
   "OfNat.ofNat",
   "MulOneClass.toMul",
   "galConj.proof_1",
   "DivisionRing.toRing",
   "CommRing.toNonUnitalCommRing",
   "Set",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "algebraRat",
   "PNat.val",
   "Units.instNeg",
   "Rat.commRing",
   "Set.instSingletonSet",
   "MonoidWithZero.toMonoid",
   "Field",
   "EquivLike.toFunLike",
   "DFunLike.coe",
   "IsCyclotomicExtension.autEquivPow",
   "Units.instMul",
   "Units.instOne",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Rat.instField",
   "Ring.toAddGroupWithOne",
   "Rat.commSemiring",
   "Rat",
   "MulEquiv.instEquivLike",
   "Field.toSemifield",
   "One.toOfNat1",
   "Neg.neg",
   "MulEquiv",
   "DivInvMonoid.toMonoid",
   "EuclideanDomain.toCommRing",
   "Monoid.toMulOneClass",
   "ZMod",
   "IsCyclotomicExtension",
   "DivisionSemiring.toSemiring",
   "Field.isDomain",
   "Units",
   "CommRing.toCommSemiring",
   "CharZero",
   "Field.toEuclideanDomain",
   "Semifield.toDivisionSemiring",
   "Singleton.singleton",
   "Group.toDivInvMonoid",
   "Field.toDivisionRing",
   "MulEquiv.symm",
   "PNat",
   "ZMod.commRing"],
  "name": "galConj",
  "constType":
  "(K : Type u_1) →\n  (p : ℕ+) → [inst : Field K] → [inst_1 : CharZero K] → [inst_2 : IsCyclotomicExtension {p} ℚ K] → K ≃ₐ[ℚ] K",
  "constCategory": "Definition"},
 {"references": ["OfNat.ofNat", "instOfNatNat", "Nat.gcd", "Nat", "Eq"],
  "name": "Nat.Coprime",
  "constType": "ℕ → ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_10",
   "Lean.Name.str._override",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_17"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_18._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Nat.casesAuxOn",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "NeZero.ne",
   "False",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "instAddNat",
   "Fin.val_add",
   "instHAdd",
   "CommRing.toNonUnitalCommRing",
   "HAdd.hAdd",
   "Eq.refl",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "rfl",
   "ZMod",
   "Eq",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Zero.toOfNat0",
   "instHMod",
   "NeZero",
   "Eq.ndrec",
   "ZMod.val",
   "False.casesOn",
   "HMod.hMod",
   "LinearOrderedCommMonoidWithZero.toZero",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Nat.instMod",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "ZMod.commRing"],
  "name": "ZMod.val_add",
  "constType":
  "∀ {n : ℕ} [inst : NeZero n] (a b : ZMod n), (a + b).val = (a.val + b.val) % n",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "CommMagma",
   "CommMagma.mk",
   "CommSemigroup.mul_comm",
   "CommSemigroup",
   "CommSemigroup.toSemigroup"],
  "name": "CommSemigroup.toCommMagma",
  "constType": "{G : Type u} → [self : CommSemigroup G] → CommMagma G",
  "constCategory": "Definition"},
 {"references":
  ["Units",
   "Monoid",
   "Iff",
   "Units.ext",
   "Units.val",
   "Function.Injective.eq_iff",
   "Eq"],
  "name": "Units.eq_iff",
  "constType": "∀ {α : Type u} [inst : Monoid α] {a b : αˣ}, ↑a = ↑b ↔ a = b",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "EmptyCollection",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "CommRing.toNonUnitalCommRing",
   "IsNoetherian",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "IsDedekindRing",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Semiring.toModule",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "CommRing"],
  "name": "IsDedekindRing.toIsNoetherian",
  "constType":
  "∀ {A : Type u_2} [inst : CommRing A] [self : IsDedekindRing A], IsNoetherian A A",
  "constCategory": "Theorem"},
 {"references":
  ["FunLike",
   "instHAdd",
   "AddHomClass",
   "HAdd.hAdd",
   "DFunLike.coe",
   "Add",
   "AddHomClass.map_add",
   "Eq"],
  "name": "map_add",
  "constType":
  "∀ {M : Type u_4} {N : Type u_5} {F : Type u_9} [inst : Add M] [inst_1 : Add N] [inst_2 : FunLike F M N]\n  [inst_3 : AddHomClass F M N] (f : F) (x y : M), f (x + y) = f x + f y",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_10",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Add.add", "HAdd.mk", "Add", "HAdd"],
  "name": "instHAdd",
  "constType": "{α : Type u_1} → [inst : Add α] → HAdd α α α",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "InvolutiveNeg.toNeg",
   "propext",
   "HasDistribNeg.toInvolutiveNeg",
   "dvd_neg",
   "Neg.neg",
   "Dvd.dvd",
   "HasDistribNeg",
   "semigroupDvd",
   "Semigroup",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.11",
  "constType":
  "∀ {α : Type u_1} [inst : Semigroup α] [inst_1 : HasDistribNeg α] {a b : α}, (a ∣ -b) = (a ∣ b)",
  "constCategory": "Theorem"},
 {"references":
  ["instHDiv",
   "OfNat.ofNat",
   "Int.instDvd",
   "Int.instMul",
   "Eq.refl",
   "Dvd.dvd",
   "Eq",
   "Int.mul_zero",
   "instHMul",
   "Eq.mpr",
   "HMul.hMul",
   "HDiv.hDiv",
   "Int.instDiv",
   "congrArg",
   "Eq.symm",
   "Int",
   "instOfNat",
   "id",
   "Int.mul_ediv_cancel'"],
  "name": "Int.eq_zero_of_ediv_eq_zero",
  "constType": "∀ {d n : ℤ}, d ∣ n → n / d = 0 → n = 0",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "Eq.mpr",
   "AddGroup",
   "of_eq_true",
   "sub_add_eq_sub_sub_swap",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "Eq.trans",
   "add_sub_cancel_right",
   "id"],
  "name": "add_sub_add_right_eq_sub",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] (a b c : G), a + c - (b + c) = a - b",
  "constCategory": "Theorem"},
 {"references": ["And", "And.right", "eq_false", "False", "Eq"],
  "name": "and_false",
  "constType": "∀ (p : Prop), (p ∧ False) = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OreLocalization.OreSet",
   "CommMonoid",
   "OreLocalization.oreSetComm.proof_2",
   "OreLocalization.oreSetComm.proof_1",
   "Submonoid",
   "CommMonoid.toMonoid",
   "Submonoid.instSetLike",
   "OreLocalization.OreSet.mk",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "Subtype"],
  "name": "OreLocalization.oreSetComm",
  "constType":
  "{R : Type u_2} → [inst : CommMonoid R] → (S : Submonoid R) → OreLocalization.OreSet S",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "CanonicallyLinearOrderedAddCommMonoid.toCanonicallyOrderedAddCommMonoid",
   "AddCommSemigroup.toAddCommMagma",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "HSub.hSub",
   "AddCommMonoid.toAddMonoid",
   "Sub",
   "AddCommMagma.toAdd",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "tsub_pos_iff_lt",
   "OrderedSub",
   "propext",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "LT.lt",
   "CanonicallyLinearOrderedAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.6",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyLinearOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b : α},\n  (0 < a - b) = (b < a)",
  "constCategory": "Theorem"},
 {"references": ["dite_eq_left_iff", "Iff", "Decidable", "Not", "ite", "Eq"],
  "name": "ite_eq_left_iff",
  "constType":
  "∀ {α : Sort u_1} {a b : α} {P : Prop} [inst : Decidable P], (if P then a else b) = a ↔ ¬P → b = a",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Ring.toNonAssocRing.proof_5",
   "NonAssocRing",
   "AddCommMonoid.toAddMonoid",
   "Ring.toNonAssocRing.proof_2",
   "Ring.intCast_ofNat",
   "Ring.toNonAssocRing.proof_3",
   "Semiring.toNatCast",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.toSub",
   "Ring",
   "Ring.add_left_neg",
   "AddCommGroup.mk",
   "Ring.toNonAssocRing.proof_7",
   "AddGroup.mk",
   "Ring.intCast_negSucc",
   "Ring.toNonAssocRing.proof_8",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toNonAssocRing.proof_4",
   "Ring.toSemiring",
   "NonUnitalNonAssocRing.mk",
   "SubNegMonoid.mk",
   "Ring.zsmul_neg'",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNonAssocRing.proof_6",
   "Ring.zsmul_succ'",
   "NonAssocRing.mk",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.sub_eq_add_neg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.toNonAssocRing.proof_1",
   "Ring.toNonAssocRing.proof_9"],
  "name": "Ring.toNonAssocRing",
  "constType": "{α : Type u} → [inst : Ring α] → NonAssocRing α",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "Submodule",
   "Submodule.quotientRel",
   "AddCommGroup.toAddCommMonoid",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Ring.toSemiring",
   "Zero.toOfNat0",
   "Quotient.mk''",
   "Ring",
   "Submodule.hasQuotient",
   "Zero.mk",
   "AddCommGroup",
   "Module",
   "HasQuotient.Quotient",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid"],
  "name": "Submodule.Quotient.instZeroQuotient",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} →\n    [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → (p : Submodule R M) → Zero (M ⧸ p)",
  "constCategory": "Definition"},
 {"references": ["AddMonoid", "AddCommMonoid"],
  "name": "AddCommMonoid.toAddMonoid",
  "constType": "{M : Type u} → [self : AddCommMonoid M] → AddMonoid M",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "MonoidWithZero.toMulZeroOneClass",
   "instHMul",
   "mul_eq_mul_left_iff",
   "OfNat.ofNat",
   "Or",
   "CancelMonoidWithZero",
   "propext",
   "HMul.hMul",
   "MonoidWithZero.toZero",
   "CancelMonoidWithZero.toMonoidWithZero",
   "MulZeroOneClass.toMulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CaseI._auxLemma.2",
  "constType":
  "∀ {M₀ : Type u_2} [inst : CancelMonoidWithZero M₀] {a b c : M₀}, (a * b = a * c) = (b = c ∨ a = 0)",
  "constCategory": "Theorem"},
 {"references":
  ["NonAssocRing.toIntCast",
   "NonAssocRing",
   "NonAssocRing.intCast_negSucc",
   "AddCommGroupWithOne.mk",
   "NonAssocRing.natCast_succ",
   "NonAssocRing.intCast_ofNat",
   "AddCommGroupWithOne",
   "NonAssocRing.toNatCast",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "NonAssocRing.natCast_zero",
   "NonAssocRing.toOne",
   "NonUnitalNonAssocRing.toAddCommGroup"],
  "name": "NonAssocRing.toAddCommGroupWithOne",
  "constType":
  "{α : Type u_1} → [self : NonAssocRing α] → AddCommGroupWithOne α",
  "constCategory": "Definition"},
 {"references": ["Ne", "Eq.refl", "Not", "Eq"],
  "name": "Ne.eq_def",
  "constType": "∀ {α : Sort u} (a b : α), (a ≠ b) = ¬a = b",
  "constCategory": "Theorem"},
 {"references":
  ["trivial",
   "iff_false_intro",
   "False",
   "Iff",
   "Not",
   "not_not_intro",
   "True"],
  "name": "not_true",
  "constType": "¬True ↔ False",
  "constCategory": "Theorem"},
 {"references":
  ["Zero.toOfNat0",
   "Membership.mem",
   "Zero",
   "Ne",
   "OfNat.ofNat",
   "Finsupp.instFunLike",
   "Finsupp",
   "Iff",
   "Finset",
   "DFunLike.coe",
   "Finsupp.support",
   "Finset.instMembership",
   "Finsupp.mem_support_toFun"],
  "name": "Finsupp.mem_support_iff",
  "constType":
  "∀ {α : Type u_1} {M : Type u_5} [inst : Zero M] {f : α →₀ M} {a : α}, a ∈ f.support ↔ f a ≠ 0",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "rfl", "Eq"],
  "name": "congrArg",
  "constType":
  "∀ {α : Sort u} {β : Sort v} {a₁ a₂ : α} (f : α → β), a₁ = a₂ → f a₁ = f a₂",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "MonoidWithZero.toMulZeroOneClass",
   "FunLike",
   "map_zpow'",
   "instHPow",
   "MonoidWithZeroHomClass",
   "GroupWithZero",
   "DivInvMonoid.Pow",
   "MonoidWithZeroHomClass.toMonoidHomClass",
   "DFunLike.coe",
   "map_inv₀",
   "GroupWithZero.toDivInvMonoid",
   "Int",
   "GroupWithZero.toMonoidWithZero",
   "Eq"],
  "name": "map_zpow₀",
  "constType":
  "∀ {F : Type u_8} {G₀ : Type u_9} {G₀' : Type u_10} [inst : GroupWithZero G₀] [inst_1 : GroupWithZero G₀']\n  [inst_2 : FunLike F G₀ G₀'] [inst_3 : MonoidWithZeroHomClass F G₀ G₀'] (f : F) (x : G₀) (n : ℤ), f (x ^ n) = f x ^ n",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Lean.SourceInfo",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["AddZeroClass.toAdd",
   "AddLeftCancelSemigroup.add_left_cancel",
   "AddRightCancelMonoid.toAddRightCancelSemigroup",
   "AddCancelMonoid.toAddRightCancelMonoid",
   "AddRightCancelMonoid.toAddMonoid",
   "AddCancelMonoid",
   "AddCancelMonoid.toAddLeftCancelMonoid",
   "IsCancelAdd",
   "IsCancelAdd.mk",
   "IsRightCancelAdd.mk",
   "AddMonoid.toAddZeroClass",
   "AddRightCancelSemigroup.add_right_cancel",
   "AddLeftCancelMonoid.toAddLeftCancelSemigroup",
   "IsLeftCancelAdd.mk"],
  "name": "AddCancelMonoid.toIsCancelAdd",
  "constType": "∀ (M : Type u) [inst : AddCancelMonoid M], IsCancelAdd M",
  "constCategory": "Definition"},
 {"references":
  ["LinearOrderedAddCommMonoid.toLinearOrder",
   "AddCommSemigroup.toAddCommMagma",
   "CanonicallyLinearOrderedAddCommMonoid.toCanonicallyOrderedAddCommMonoid",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "AddCommMonoid.toAddMonoid",
   "Sub",
   "Preorder.toLE",
   "Eq",
   "Zero.toOfNat0",
   "tsub_pos_iff_not_le",
   "Eq.mpr",
   "Iff",
   "OrderedSub",
   "Preorder.toLT",
   "AddMonoid.toZero",
   "CanonicallyLinearOrderedAddCommMonoid",
   "not_le",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "AddCommMonoid.toAddCommSemigroup",
   "OrderedAddCommMonoid.toPartialOrder",
   "id",
   "instHSub",
   "CanonicallyLinearOrderedAddCommMonoid.toLinearOrderedAddCommMonoid",
   "HSub.hSub",
   "AddCommMagma.toAdd",
   "LE.le",
   "propext",
   "LT.lt",
   "Not",
   "LinearOrder.toPartialOrder",
   "congrArg",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "tsub_pos_iff_lt",
  "constType":
  "∀ {α : Type u_1} [inst : CanonicallyLinearOrderedAddCommMonoid α] [inst_1 : Sub α] [inst_2 : OrderedSub α] {a b : α},\n  0 < a - b ↔ b < a",
  "constCategory": "Theorem"},
 {"references": ["NonAssocRing", "IntCast"],
  "name": "NonAssocRing.toIntCast",
  "constType": "{α : Type u_1} → [self : NonAssocRing α] → IntCast α",
  "constCategory": "Definition"},
 {"references": ["cond.match_1", "Bool.true", "Unit", "Bool"],
  "name": "or",
  "constType": "Bool → Bool → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Zero",
   "CommSemiring.toSemiring",
   "FractionalIdeal.coeIdeal",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Submodule.pointwiseZero",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Algebra",
   "Submonoid",
   "Zero.mk",
   "FractionalIdeal",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal",
   "Semiring.toModule"],
  "name": "FractionalIdeal.instZero",
  "constType":
  "{R : Type u_1} →\n  [inst : CommRing R] →\n    (S : Submonoid R) → {P : Type u_2} → [inst_1 : CommRing P] → [inst_2 : Algebra R P] → Zero (FractionalIdeal S P)",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "Submodule",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "Set",
   "Ideal.span",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.span",
   "rfl",
   "Semiring.toModule",
   "Eq"],
  "name": "Ideal.submodule_span_eq",
  "constType":
  "∀ {α : Type u} [inst : Semiring α] {s : Set α}, Submodule.span α s = Ideal.span s",
  "constCategory": "Theorem"},
 {"references": ["AddMonoidWithOne", "AddCommMonoidWithOne"],
  "name": "AddCommMonoidWithOne.toAddMonoidWithOne",
  "constType":
  "{R : Type u_2} → [self : AddCommMonoidWithOne R] → AddMonoidWithOne R",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.ParserDescr.node",
   "Lean.Name.mkNum",
   "instOfNatNat",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termK._@.FltRegular.CaseI.AuxLemmas._hyg.250",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_30",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_1"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_31._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toOne",
   "OrderedSemiring",
   "ZeroLEOneClass",
   "PartialOrder.toPreorder",
   "OrderedSemiring.toSemiring",
   "Semiring.toMonoidWithZero",
   "OrderedSemiring.zero_le_one",
   "MonoidWithZero.toZero",
   "ZeroLEOneClass.mk",
   "OrderedSemiring.toPartialOrder",
   "Preorder.toLE"],
  "name": "OrderedSemiring.zeroLEOneClass",
  "constType": "∀ {α : Type u} [inst : OrderedSemiring α], ZeroLEOneClass α",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "DivisionSemiring.mul_inv_cancel",
   "DivisionSemiring",
   "Semiring.mul_one",
   "DivisionSemiring.inv_zero",
   "Semiring.npow_succ",
   "AddCommMonoid.toAddMonoid",
   "DivisionSemiring.toDiv",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Semiring.one_mul",
   "DivisionSemiring.div_eq_mul_inv",
   "DivisionSemiring.zpow_succ'",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "DivisionSemiring.zpow_zero'",
   "MonoidWithZero.mk",
   "Semiring.npow",
   "NonUnitalNonAssocSemiring.zero_mul",
   "AddMonoid.toZero",
   "GroupWithZero",
   "DivisionSemiring.toNontrivial",
   "DivisionSemiring.zpow_neg'",
   "DivisionSemiring.zpow",
   "DivisionSemiring.toInv",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "GroupWithZero.mk",
   "NonUnitalNonAssocSemiring.mul_zero",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "DivisionSemiring.toGroupWithZero",
  "constType": "{α : Type u_4} → [self : DivisionSemiring α] → GroupWithZero α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Ne",
   "CommMonoidWithZero.toZero",
   "Finsupp",
   "OfNat.ofNat",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "MvPolynomial",
   "MvPolynomial.mem_support_iff",
   "MvPolynomial.coeff",
   "Eq",
   "Finset.instMembership",
   "Zero.toOfNat0",
   "MvPolynomial.support",
   "propext",
   "CommSemiring",
   "Finset",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Nat",
   "CommSemiring.toCommMonoidWithZero"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.17",
  "constType":
  "∀ {R : Type u} {σ : Type u_1} [inst : CommSemiring R] {p : MvPolynomial σ R} {m : σ →₀ ℕ},\n  (m ∈ p.support) = (MvPolynomial.coeff m p ≠ 0)",
  "constCategory": "Theorem"},
 {"references": ["SMul", "Semiring", "CommSemiring", "Algebra"],
  "name": "Algebra.toSMul",
  "constType":
  "{R : Type u} → {A : Type v} → [inst : CommSemiring R] → [inst_1 : Semiring A] → [self : Algebra R A] → SMul R A",
  "constCategory": "Definition"},
 {"references": ["OrderedCommMonoid", "PartialOrder"],
  "name": "OrderedCommMonoid.toPartialOrder",
  "constType": "{α : Type u_3} → [self : OrderedCommMonoid α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["CommMonoidWithZero.toZero",
   "OfNat.ofNat",
   "Int.instDvd",
   "Dvd.dvd",
   "ZMod",
   "Eq",
   "Zero.toOfNat0",
   "CommRing.toCommSemiring",
   "Nat.cast",
   "instNatCastInt",
   "propext",
   "Int.cast",
   "Ring.toIntCast",
   "ZMod.intCast_zmod_eq_zero_iff_dvd",
   "CommRing.toRing",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "Int",
   "ZMod.commRing"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.8",
  "constType": "∀ (a : ℤ) (b : ℕ), (↑a = 0) = (↑b ∣ a)",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "Fintype",
  "constType": "Type u_4 → Type u_4",
  "constCategory": "Other"},
 {"references":
  ["MulOneClass.toMul",
   "instHDiv",
   "OfNat.ofNat",
   "Monoid.toOne",
   "div_eq_mul_inv",
   "One.toOfNat1",
   "inv_eq_of_mul_eq_one_right",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "DivInvMonoid.toInv",
   "Eq",
   "DivisionMonoid",
   "instHMul",
   "inv_injective",
   "Eq.mpr",
   "DivisionMonoid.toDivInvMonoid",
   "HMul.hMul",
   "HDiv.hDiv",
   "InvolutiveInv.toInv",
   "Eq.symm",
   "congrArg",
   "DivisionMonoid.toInvolutiveInv",
   "id",
   "DivInvMonoid.toDiv",
   "Inv.inv"],
  "name": "eq_of_div_eq_one",
  "constType":
  "∀ {α : Type u_1} [inst : DivisionMonoid α] {a b : α}, a / b = 1 → a = b",
  "constCategory": "Theorem"},
 {"references":
  ["AddMonoidWithOne",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "CharZero",
   "propext",
   "Nat.cast_inj",
   "Nat",
   "Eq"],
  "name": "FltRegular.MayAssume.Lemmas._auxLemma.8",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] {m n : ℕ}, (↑m = ↑n) = (m = n)",
  "constCategory": "Theorem"},
 {"references":
  ["outParam",
   "Semiring.toNonAssocSemiring",
   "AlgHomClass",
   "FunLike",
   "RingHomClass",
   "Semiring",
   "CommSemiring",
   "Algebra"],
  "name": "AlgHomClass.toRingHomClass",
  "constType":
  "∀ {F : Type u_1} {R : outParam (Type u_2)} {A : outParam (Type u_3)} {B : outParam (Type u_4)} [inst : CommSemiring R]\n  [inst_1 : Semiring A] [inst_2 : Semiring B] [inst_3 : Algebra R A] [inst_4 : Algebra R B] [inst_5 : FunLike F A B]\n  [self : AlgHomClass F R A B], RingHomClass F A B",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.AtLeastTwo.ne_one",
   "Ne",
   "AddMonoidWithOne",
   "OfNat.ofNat",
   "Nat.AtLeastTwo",
   "AddMonoidWithOne.toNatCast",
   "Nat.cast",
   "AddMonoidWithOne.toOne",
   "CharZero",
   "instOfNatNat",
   "One.toOfNat1",
   "Nat.cast_ne_one",
   "Nat",
   "Iff.mpr",
   "instOfNatAtLeastTwo"],
  "name": "OfNat.ofNat_ne_one",
  "constType":
  "∀ {R : Type u_1} [inst : AddMonoidWithOne R] [inst_1 : CharZero R] (n : ℕ) [inst_2 : n.AtLeastTwo], OfNat.ofNat n ≠ 1",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_7",
   "List.cons",
   "_obj",
   "List.nil",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset",
   "HasSubset",
   "HasSubset.mk",
   "Finset.instMembership"],
  "name": "Finset.instHasSubset",
  "constType": "{α : Type u_1} → HasSubset (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "inferInstance",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Ring"],
  "name": "Mathlib.Meta.NormNum.instAddMonoidWithOne",
  "constType": "{α : Type u} → [inst : Ring α] → AddMonoidWithOne α",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "instHSub",
   "AddZeroClass.toAdd",
   "add_assoc",
   "AddCommSemigroup.toAddCommMagma",
   "add_comm",
   "SubtractionCommMonoid.toAddCommMonoid",
   "SubtractionCommMonoid",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMagma.toAdd",
   "True",
   "Eq",
   "SubNegMonoid.toSub",
   "of_eq_true",
   "SubtractionMonoid.toSubNegMonoid",
   "AddMonoid.toAddSemigroup",
   "SubNegMonoid.toAddMonoid",
   "congr",
   "congrArg",
   "AddCommMonoid.toAddCommSemigroup",
   "Eq.trans",
   "neg_add_rev"],
  "name": "sub_sub",
  "constType":
  "∀ {α : Type u_1} [inst : SubtractionCommMonoid α] (a b c : α), a - b - c = a - (b + c)",
  "constCategory": "Theorem"},
 {"references": ["outParam"],
  "name": "Insert",
  "constType": "outParam (Type u) → Type v → Type (max u v)",
  "constCategory": "Other"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_8",
   "_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_7",
   "Lean.Name.str._override"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_9._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "instHSub",
   "SubNegMonoid.toSub",
   "AddGroup",
   "instHAdd",
   "propext",
   "HAdd.hAdd",
   "SubNegMonoid.toAddMonoid",
   "HSub.hSub",
   "sub_eq_iff_eq_add",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.12",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b c : G}, (a - b = c) = (a = c + b)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "EuclideanDomain.to_principal_ideal_domain",
   "Module.Finite",
   "Eq",
   "nonZeroDivisors",
   "Monoid.toMulAction",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "IsDomain.to_noZeroDivisors",
   "Iff",
   "IsFractionRing.injective",
   "MonoidWithZero.toMonoid",
   "_private.Mathlib.FieldTheory.IsAlgClosed.Basic.0.IsAlgClosed.FractionRing.isAlgebraic",
   "RingHomClass.toMonoidWithZeroHomClass",
   "OreLocalization.instSemiring",
   "Algebra",
   "IsDomain.toNontrivial",
   "IsIntegralClosure.isLocalization",
   "Algebra.toSMul",
   "Eq.trans",
   "MulActionWithZero.toMulAction",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "OreLocalization.instCommRing",
   "Module.Free.of_divisionRing",
   "FractionRing.isScalarTower_liftAlgebra",
   "NoZeroSMulDivisors",
   "IsScalarTower.right",
   "OreLocalization.instIsScalarTower",
   "OreLocalization.instRing",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Mathlib.RingTheory.IntegralClosure.IntegralRestrict._auxLemma.5",
   "MonoidHom",
   "Module.toMulActionWithZero",
   "RingHom.instFunLike",
   "CommRing.toCommMonoid",
   "MulAction.toSMul",
   "FractionRing",
   "of_eq_true",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Field.toEuclideanDomain",
   "propext",
   "CommRing.toRing",
   "congr",
   "Module.free_of_finite_type_torsion_free'",
   "MonoidHom.instFunLike",
   "IsIntegralClosure.of_isIntegrallyClosed",
   "Algebra.id",
   "MonoidWithZero.toZero",
   "congrArg",
   "CommMonoidWithZero.toZero",
   "RingHom",
   "OreLocalization.instZero",
   "CommRing.toNonUnitalCommRing",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "FractionRing.field",
   "AddCommMonoid.toAddMonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "CommRing",
   "True",
   "iff_self",
   "Algebra.norm",
   "Zero.toOfNat0",
   "OreLocalization.oreSetComm",
   "AddMonoid.toZero",
   "FractionRing.liftAlgebra",
   "map_zero",
   "OreLocalization.instDivisionRingNonZeroDivisors",
   "IsIntegrallyClosed",
   "CommSemiring.toCommMonoidWithZero",
   "DFunLike.coe",
   "CommMonoid.toMonoid",
   "Eq.symm",
   "Algebra.intNorm",
   "Module.Finite_of_isLocalization",
   "id",
   "Algebra.toModule",
   "algebraMap",
   "Algebra.IsIntegral.of_finite",
   "Localization.isLocalization",
   "Ring.toSemiring",
   "Function.Injective.eq_iff",
   "OreLocalization.instAlgebra",
   "Algebra.algebraMap_intNorm_fractionRing",
   "Field.isDomain",
   "CommRing.toCommSemiring",
   "Algebra.IsIntegral.isAlgebraic",
   "Module.Free.noZeroSMulDivisors",
   "Ring.toAddCommGroup",
   "FractionRing.instNoZeroSMulDivisors",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Algebra.IsSeparable",
   "MonoidWithZeroHomClass.toZeroHomClass"],
  "name": "Algebra.intNorm_eq_zero",
  "constType":
  "∀ {A : Type u_1} {B : Type u_4} [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] [inst_3 : IsDomain A]\n  [inst_4 : IsIntegrallyClosed A] [inst_5 : IsDomain B] [inst_6 : IsIntegrallyClosed B] [inst_7 : Module.Finite A B]\n  [inst_8 : NoZeroSMulDivisors A B] [inst_9 : Algebra.IsSeparable (FractionRing A) (FractionRing B)] {x : B},\n  (Algebra.intNorm A B) x = 0 ↔ x = 0",
  "constCategory": "Theorem"},
 {"references": ["List.cons", "List", "List.Mem"],
  "name": "List.Mem.head",
  "constType": "∀ {α : Type u} {a : α} (as : List α), List.Mem a (a :: as)",
  "constCategory": "Other"},
 {"references":
  ["FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_8",
   "Lean.ParserDescr.node",
   "_obj",
   "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_10"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["CanonicallyOrderedAddCommMonoid", "CanonicallyOrderedCommSemiring"],
  "name": "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
  "constType":
  "{α : Type u_2} → [self : CanonicallyOrderedCommSemiring α] → CanonicallyOrderedAddCommMonoid α",
  "constCategory": "Definition"},
 {"references": ["Zero", "SetLike"],
  "name": "ZeroMemClass",
  "constType":
  "(S : Type u_4) → (M : Type u_5) → [inst : Zero M] → [inst : SetLike S M] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "DecidableEq",
   "propext",
   "Finset",
   "Finset.mem_sdiff",
   "Not",
   "SDiff.sdiff",
   "Finset.instSDiff",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.CaseII.InductionStep._auxLemma.12",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {s t : Finset α} {a : α}, (a ∈ s \\ t) = (a ∈ s ∧ a ∉ t)",
  "constCategory": "Theorem"},
 {"references":
  ["FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_1",
   "_obj",
   "Lean.Name.mkStr4",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_4",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_3",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_2"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_5._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_7",
   "_obj",
   "Lean.Name.num._override"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.Statement._hyg.256._closed_8._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "Trans.trans",
   "DivInvMonoid.zpow_succ'",
   "HAdd.hAdd",
   "DivInvMonoid.Pow",
   "Eq",
   "PProd",
   "Nat.cast",
   "instHPow",
   "PUnit",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "Eq.trans",
   "instOfNat",
   "Nat.succ",
   "HPow.hPow",
   "Nat.below",
   "Nat.brecOn",
   "instAddNat",
   "instHAdd",
   "Unit",
   "DivInvMonoid",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "pow_zero",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "instNatCastInt",
   "zpow_zero",
   "instTransEq",
   "HMul.hMul",
   "pow_succ",
   "pow_succ'.match_1",
   "congrArg",
   "Int"],
  "name": "zpow_natCast",
  "constType":
  "∀ {G : Type u_1} [inst : DivInvMonoid G] (a : G) (n : ℕ), a ^ ↑n = a ^ n",
  "constCategory": "Theorem"},
 {"references": ["Lean.Omega.Coeffs", "Lean.Omega.LinearCombo", "Int"],
  "name": "Lean.Omega.LinearCombo.mk",
  "constType": "ℤ → Lean.Omega.Coeffs → Lean.Omega.LinearCombo",
  "constCategory": "Other"},
 {"references":
  ["RingHom",
   "Polynomial",
   "Semiring.toNonAssocSemiring",
   "Polynomial.coeff_map",
   "Semiring",
   "Polynomial.coeff",
   "DFunLike.coe",
   "Nat",
   "Eq.symm",
   "RingHom.instFunLike",
   "Polynomial.map",
   "Eq"],
  "name": "FltRegular.NumberTheory.KummersLemma.Field._auxLemma.3",
  "constType":
  "∀ {R : Type u} {S : Type v} [inst : Semiring R] {p : Polynomial R} [inst_1 : Semiring S] (f : R →+* S) (n : ℕ),\n  f (p.coeff n) = (Polynomial.map f p).coeff n",
  "constCategory": "Theorem"},
 {"references":
  ["Int.cast_one",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "MulOneClass.toMul",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "AddGroupWithOne.toIntCast",
   "Int.rawCast",
   "NonAssocSemiring.toMulZeroOneClass",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "one_mul",
   "Ring.toNeg",
   "InvolutiveNeg.toNeg",
   "Int.cast_neg",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "Int.instNegInt",
   "neg_mul",
   "instOfNat",
   "Eq.trans",
   "eq_self",
   "NonUnitalNonAssocRing.toMul",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "Int.negOfNat",
   "MulOneClass.toOne",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "One.toOfNat1",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "instHMul",
   "Eq.ndrec",
   "of_eq_true",
   "AddMonoidWithOne.toOne",
   "Int.cast",
   "HMul.hMul",
   "congrArg",
   "Int"],
  "name": "Mathlib.Tactic.Ring.neg_one_mul",
  "constType":
  "∀ {R : Type u_2} [inst : Ring R] {a b : R}, (Int.negOfNat 1).rawCast * a = b → -a = b",
  "constCategory": "Theorem"},
 {"references":
  ["AddGroupWithOne.mk",
   "Semiring.toNonUnitalSemiring",
   "Semiring.natCast_zero",
   "Semiring.natCast_succ",
   "Ring.intCast_negSucc",
   "AddCommMonoid.toAddMonoid",
   "Ring.intCast_ofNat",
   "Ring.toSemiring",
   "Ring.zsmul_neg'",
   "Semiring.toNatCast",
   "Ring.zsmul_zero'",
   "Semiring.toOne",
   "Ring.zsmul",
   "Ring.toNeg",
   "Ring.toIntCast",
   "Ring.zsmul_succ'",
   "Ring",
   "Ring.toSub",
   "AddGroupWithOne",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ring.add_left_neg",
   "AddMonoidWithOne.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ring.sub_eq_add_neg"],
  "name": "Ring.toAddGroupWithOne",
  "constType": "{R : Type u} → [self : Ring R] → AddGroupWithOne R",
  "constCategory": "Definition"},
 {"references": ["DivInvMonoid", "Div"],
  "name": "DivInvMonoid.toDiv",
  "constType": "{G : Type u} → [self : DivInvMonoid G] → Div G",
  "constCategory": "Definition"},
 {"references":
  ["DistribMulAction.mk",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Semiring.toModule.proof_1",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "MonoidWithZero.toMulActionWithZero",
   "Semiring.toModule.proof_2",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Semiring.toModule.proof_4",
   "Module",
   "Semiring.toModule.proof_3",
   "MulActionWithZero.toMulAction",
   "Module.mk"],
  "name": "Semiring.toModule",
  "constType": "{R : Type u_2} → [inst : Semiring R] → Module R R",
  "constCategory": "Definition"},
 {"references":
  ["instHMul",
   "InvolutiveNeg.toNeg",
   "HasDistribNeg.neg_mul",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "Neg.neg",
   "HasDistribNeg",
   "Mul",
   "Eq"],
  "name": "neg_mul",
  "constType":
  "∀ {α : Type u} [inst : Mul α] [inst_1 : HasDistribNeg α] (a b : α), -a * b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "CommSemiring.toSemiring",
   "Submodule.idemSemiring",
   "Set",
   "Semiring.toMonoidWithZero",
   "Ideal.span",
   "Eq",
   "Set.instSingletonSet",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "CommSemiring",
   "Monoid.toNatPow",
   "Ideal.span_singleton_pow",
   "Singleton.singleton",
   "IdemSemiring.toSemiring",
   "Nat",
   "Algebra.id",
   "Eq.symm",
   "Ideal"],
  "name": "FltRegular.CaseI.Statement._auxLemma.4",
  "constType":
  "∀ {R : Type u} [inst : CommSemiring R] (s : R) (n : ℕ), Ideal.span {s ^ n} = Ideal.span {s} ^ n",
  "constCategory": "Theorem"},
 {"references":
  ["Submodule.quotientRel",
   "Submodule",
   "Ring",
   "AddCommGroup.toAddCommMonoid",
   "HasQuotient",
   "Quotient",
   "Module",
   "AddCommGroup",
   "Ring.toSemiring",
   "HasQuotient.mk"],
  "name": "Submodule.hasQuotient",
  "constType":
  "{R : Type u_1} →\n  {M : Type u_2} → [inst : Ring R] → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → HasQuotient M (Submodule R M)",
  "constCategory": "Definition"},
 {"references": ["Eq.refl", "Eq"],
  "name": "Eq.rec",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → motive a ⋯ → {a_1 : α} → (t : a = a_1) → motive a_1 t",
  "constCategory": "Other"},
 {"references":
  ["Lean.Omega.UpperBound", "Lean.Omega.Constraint", "Lean.Omega.LowerBound"],
  "name": "Lean.Omega.Constraint.mk",
  "constType":
  "Lean.Omega.LowerBound → Lean.Omega.UpperBound → Lean.Omega.Constraint",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_5",
   "Lean.Syntax.Preresolved.decl",
   "List.nil",
   "_neutral"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Int.instSemiring",
   "Iff.rfl",
   "Even",
   "Int.not_even_iff",
   "Int.instAdd",
   "Eq",
   "Eq.mpr",
   "instHMod",
   "Iff",
   "propext",
   "Int.odd_iff",
   "HMod.hMod",
   "Not",
   "Odd",
   "Int.instMod",
   "congrArg",
   "Int",
   "instOfNat",
   "id"],
  "name": "Int.odd_iff_not_even",
  "constType": "∀ {n : ℤ}, Odd n ↔ ¬Even n",
  "constCategory": "Theorem"},
 {"references":
  ["NeZero.succ",
   "Nat.casesAuxOn",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "instAddNat",
   "instHAdd",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.mod_zero",
   "ZMod",
   "Eq",
   "Semiring.toNatCast",
   "CommRing.toCommSemiring",
   "instHMod",
   "Eq.mpr",
   "Nat.cast",
   "Eq.ndrec",
   "ZMod.val",
   "HMod.hMod",
   "instOfNatNat",
   "Nat",
   "Eq.symm",
   "congrArg",
   "Int.natAbs_ofNat",
   "Nat.instMod",
   "Fin.val_natCast",
   "id",
   "ZMod.commRing"],
  "name": "ZMod.val_natCast",
  "constType": "∀ {n : ℕ} (a : ℕ), (↑a).val = a % n",
  "constCategory": "Theorem"},
 {"references":
  ["Finsupp.support_single_subset",
   "Finsupp.single",
   "Mathlib.Data.Finset.Basic._auxLemma.39",
   "Finset.instHasSubset",
   "OfNat.ofNat",
   "Eq.refl",
   "FltRegular.ReadyForMathlib.Homogenization._auxLemma.2",
   "AddCommMonoid.toAddMonoid",
   "Mathlib.Data.Finsupp.Defs._auxLemma.1",
   "implies_congr",
   "True",
   "Eq",
   "Finset.instMembership",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Finsupp.support_sum",
   "Finset.biUnion",
   "FltRegular.ReadyForMathlib.Homogenization._auxLemma.1",
   "forall_congr",
   "AddMonoid.toZero",
   "Finsupp.sum",
   "Finset",
   "Function.Embedding",
   "DFunLike.coe",
   "not_false_eq_true",
   "Mathlib.Data.Finset.Image._auxLemma.3",
   "Eq.trans",
   "AddCommMonoid",
   "id",
   "Membership.mem",
   "Ne",
   "Finsupp",
   "Finsupp.instFunLike",
   "False",
   "Classical.propDecidable",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "Finset.Subset.trans",
   "Finset.map",
   "eq_false",
   "Finsupp.instAddCommMonoid",
   "Finsupp.mapDomain",
   "of_eq_true",
   "Singleton.singleton",
   "Not",
   "congrArg",
   "Function.instFunLikeEmbedding",
   "Finsupp.support",
   "Finsupp.mapDomain.eq_1"],
  "name": "MvPolynomial.Finsupp.support_mapDomain",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {M : Type u_3} [inst : AddCommMonoid M] (f : α ↪ β) (v : α →₀ M),\n  (Finsupp.mapDomain (⇑f) v).support ⊆ Finset.map f v.support",
  "constCategory": "Theorem"},
 {"references": ["EStateM.Result"],
  "name": "EStateM.Result.error",
  "constType": "{ε σ α : Type u} → ε → σ → EStateM.Result ε σ α",
  "constCategory": "Other"},
 {"references":
  ["not_isEmpty_of_nonempty", "eq_false", "False", "IsEmpty", "Nonempty", "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.8",
  "constType": "∀ (α : Sort u_1) [h : Nonempty α], IsEmpty α = False",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Multiset.mem_toFinset",
   "DecidableEq",
   "propext",
   "Finset",
   "Multiset",
   "Multiset.toFinset",
   "Eq",
   "Multiset.instMembership",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.3",
  "constType":
  "∀ {α : Type u_1} [inst : DecidableEq α] {a : α} {s : Multiset α}, (a ∈ s.toFinset) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references": ["Nat.cast", "instNatCastInt", "Nat", "congrArg", "Int", "Eq"],
  "name": "Lean.Omega.Int.ofNat_congr",
  "constType": "∀ {a b : ℕ}, a = b → ↑a = ↑b",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "IdemCommSemiring.mk",
   "Submodule",
   "Algebra.toModule",
   "IdemCommSemiring",
   "Submodule.idemSemiring",
   "CommSemiring.mk",
   "Submodule.mul_comm",
   "Submodule.instIdemCommSemiring.proof_1",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "IdemSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "IdemSemiring.toSemiring",
   "IdemSemiring.toSemilatticeSup",
   "Submodule.instIdemCommSemiring.proof_2",
   "IdemSemiring.bot"],
  "name": "Submodule.instIdemCommSemiring",
  "constType":
  "{R : Type u} →\n  [inst : CommSemiring R] →\n    {A : Type v} → [inst_1 : CommSemiring A] → [inst_2 : Algebra R A] → IdemCommSemiring (Submodule R A)",
  "constCategory": "Definition"},
 {"references":
  ["zero_smul",
   "Distrib.toAdd",
   "AddZeroClass.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "AddCommGroup.toDivisionAddCommMonoid",
   "OfNat.ofNat",
   "instHSMul",
   "SubNegMonoid.toNeg",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "AddCommGroup.toAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "AddMonoid.toAddZeroClass",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "Eq.mpr",
   "Ring.toNeg",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Ring",
   "Module",
   "Eq.symm",
   "eq_neg_of_add_eq_zero_left",
   "AddCommMonoid.toAddCommSemigroup",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "add_smul",
   "Ring.toAddGroupWithOne",
   "instHAdd",
   "add_left_neg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Module.toMulActionWithZero",
   "AddCommMagma.toAdd",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "SubtractionMonoid.toSubNegMonoid",
   "SubNegMonoid.toAddMonoid",
   "MonoidWithZero.toZero",
   "AddCommGroup",
   "NegZeroClass.toNeg",
   "congrArg",
   "NegZeroClass.toZero"],
  "name": "neg_smul",
  "constType":
  "∀ {R : Type u_2} {M : Type u_5} [inst : Ring R] [inst_1 : AddCommGroup M] [inst_2 : Module R M] (r : R) (x : M),\n  -r • x = -(r • x)",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "Lean.Name.mkStr",
   "Lean.ParserDescr.node",
   "Lean.Name.mkNum",
   "instOfNatNat",
   "Nat",
   "Lean.Name.anonymous",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termK._@.FltRegular.CaseI.Statement._hyg.256",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["LinearMapClass",
   "NonUnitalNonAssocSemiring",
   "RingHom",
   "Module.toDistribMulAction",
   "DistribMulActionSemiHomClass.toMulActionSemiHomClass",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "RingHom.id",
   "SemilinearMapClass.mk",
   "outParam",
   "Semiring.toNonAssocSemiring",
   "SMulWithZero.toSMulZeroClass",
   "DistribMulActionSemiHomClass.toAddMonoidHomClass",
   "FunLike",
   "MonoidWithZero.toMonoid",
   "AddMonoid.toZero",
   "MonoidHom.id",
   "DFunLike.coe",
   "Module",
   "NonUnitalAlgHomClass",
   "Semiring",
   "MonoidHom",
   "Module.toMulActionWithZero",
   "Monoid.toMulOneClass",
   "RingHom.instFunLike",
   "SMulZeroClass.toSMul",
   "MulActionWithZero.toSMulWithZero",
   "MulActionSemiHomClass.mk",
   "NonUnitalAlgSemiHomClass.toDistribMulActionSemiHomClass",
   "MulActionSemiHomClass.map_smulₛₗ",
   "AddMonoidHomClass.toAddHomClass",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidHom.instFunLike",
   "MonoidWithZero.toZero"],
  "name": "NonUnitalAlgHomClass.instLinearMapClass",
  "constType":
  "∀ {R : Type u} [inst : Semiring R] {A : Type u_1} {B : Type u_2} [inst_1 : NonUnitalNonAssocSemiring A]\n  [inst_2 : Module R A] [inst_3 : NonUnitalNonAssocSemiring B] {F : Type u_3} [inst_4 : FunLike F A B]\n  [inst_5 : Module R B] [inst_6 : NonUnitalAlgHomClass F R A B], LinearMapClass F R A B",
  "constCategory": "Definition"},
 {"references":
  ["AddZeroClass.toAdd",
   "SetLike",
   "SetLike.mk",
   "Submodule",
   "Submodule.toAddSubmonoid",
   "Semiring",
   "AddSubmonoid.toAddSubsemigroup",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "Module",
   "AddSubsemigroup.carrier",
   "Submodule.setLike.proof_1",
   "AddCommMonoid"],
  "name": "Submodule.setLike",
  "constType":
  "{R : Type u} →\n  {M : Type v} → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst_2 : Module R M] → SetLike (Submodule R M) M",
  "constCategory": "Definition"},
 {"references": ["And", "propext", "Not", "not_and", "Eq"],
  "name": "FltRegular.CaseI.AuxLemmas._auxLemma.7",
  "constType": "∀ {a b : Prop}, (¬(a ∧ b)) = (a → ¬b)",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "SubNegMonoid.toSub",
   "HSub.hSub",
   "AddCommGroup.toAddGroup",
   "AddCommGroup",
   "sub_sub_self",
   "AddGroup.toSubNegMonoid",
   "Eq"],
  "name": "sub_sub_cancel",
  "constType":
  "∀ {G : Type u_3} [inst : AddCommGroup G] (a b : G), a - (a - b) = b",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Monoid.mk",
   "Int.instHPowNat",
   "Int.instMul",
   "One.ofOfNat1",
   "Int.mul_comm",
   "Int.mul_one",
   "Int.instCommMonoid.proof_2",
   "CommMonoid",
   "Int.one_mul",
   "Int.instCommMonoid.proof_1",
   "Nat",
   "CommMonoid.mk",
   "Int.mul_assoc",
   "Int",
   "instOfNat",
   "Semigroup.mk"],
  "name": "Int.instCommMonoid",
  "constType": "CommMonoid ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Mathlib.Meta.NormNum.isNat_eq_false",
   "IsRegularPrime",
   "Insert.insert",
   "Finset.instMembership",
   "Semiring.toNatCast",
   "Nat.not_prime_mul",
   "instOfNat",
   "StrictOrderedCommSemiring.toOrderedCommSemiring",
   "instHDiv",
   "Mathlib.Tactic.Ring.add_overlap_pf_zero",
   "Mathlib.Tactic.Ring.add_pf_add_overlap",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "or_true",
   "And",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "False.elim",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "congr",
   "instNatAtLeastTwo",
   "LinearOrder.toPartialOrder",
   "And.intro",
   "Int.even_pow'",
   "Nat.instCharZero",
   "Int.instSemigroup",
   "AddZeroClass.toAdd",
   "AddCommGroup.toDivisionAddCommMonoid",
   "CommMonoidWithZero.toZero",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Int.instSemiring",
   "sub_nonpos_of_le",
   "HEq",
   "GE.ge",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Eq.refl",
   "Int.rawCast",
   "semigroupDvd",
   "NonAssocSemiring.toMulZeroOneClass",
   "IsCancelAdd.toIsRightCancelAdd",
   "rfl",
   "Finset.gcd",
   "Mathlib.Tactic.Ring.sub_pf",
   "Int.instAddMonoid",
   "Int.add_one_le_iff",
   "Int.instCommSemigroup",
   "AddGroup.toAddCancelMonoid",
   "Monoid.toNatPow",
   "zero_lt_one",
   "Nat.instAddCommMonoidWithOne",
   "List.nil",
   "Decidable.byContradiction",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "LinearOrderedCommRing.toLinearOrderedRing",
   "List.cons",
   "OrderedAddCommMonoid.toCovariantClassLeft",
   "FltRegular.CaseI.Statement",
   "List.Mem.tail",
   "Neg.neg",
   "LE.le",
   "NormedCommRing.toSeminormedCommRing",
   "Mathlib.Data.Finset.Basic._auxLemma.28",
   "Eq.ndrec",
   "instNatCastInt",
   "Finset.mem_Ioo",
   "letFun",
   "Finset.gcd_dvd",
   "not_true_eq_false",
   "NegZeroClass.toNeg",
   "HAdd.hAdd",
   "canonicallyOrderedAddCommMonoid.toZeroLeOneClass",
   "Mathlib.Algebra.GroupWithZero.Divisibility._auxLemma.2",
   "AddGroup.toSubtractionMonoid",
   "Int.Odd.of_mul_right",
   "Nat.Prime.two_le",
   "optParam",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "StrictOrderedRing.toOrderedAddCommGroup",
   "true_or",
   "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
   "List.Mem.casesOn",
   "Int.instDiv",
   "Odd.pow",
   "And.casesOn",
   "Eq.trans",
   "StrictOrderedRing.toPartialOrder",
   "Int.instHPowNat",
   "Int.instDvd",
   "neg_neg_of_pos",
   "Finset.instSingleton",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "lt_of_not_ge",
   "Int.instLTInt",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "Mathlib.Tactic.Ring.neg_mul",
   "Nat.instOrderedSemiring",
   "Mathlib.Tactic.Ring.cast_zero",
   "Mathlib.Tactic.Ring.of_eq",
   "of_eq_true",
   "HEq.refl",
   "Eq.mp",
   "Singleton.singleton",
   "Int.ofNat",
   "LinearOrderedRing.toStrictOrderedRing",
   "Linarith.lt_irrefl",
   "instSubNat",
   "Mathlib.Tactic.Zify._auxLemma.2",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "NonUnitalSeminormedCommRing.toNonUnitalCommRing",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "FltRegular.MayAssume.p_ne_three",
   "instOfNatNat",
   "CommSemiring.toCommMonoidWithZero",
   "Int.mul_ediv_cancel'",
   "id",
   "instOfNatAtLeastTwo",
   "eq_self",
   "Membership.mem",
   "AddGroupWithOne.toAddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "False",
   "IsCancelAdd.toIsLeftCancelAdd",
   "instAddNat",
   "Int.instNormalizedGCDMonoid",
   "AddMonoidWithOne.toAddMonoid",
   "FltRegular.MayAssume.coprime",
   "List.Mem",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "CommSemigroup.toSemigroup",
   "StrictOrderedSemiring.toPartialOrder",
   "List",
   "OrderedCommSemiring.toOrderedSemiring",
   "Nat.instLinearOrder",
   "Nat.instCanonicallyOrderedCommSemiring",
   "NonUnitalSemiring.toSemigroupWithZero",
   "SeminormedCommRing.toNonUnitalSeminormedCommRing",
   "Bool",
   "instMulNat",
   "Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "IsLeftCancelAdd.covariant_add_lt_of_covariant_add_le",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "LT.lt.ne'",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "Finset.instInsert",
   "Int.instDecidableEq",
   "even_iff_two_dvd",
   "Iff.mpr",
   "Mathlib.Meta.NormNum.isInt_add",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "Nat.lt_of_le_of_ne",
   "SubNegMonoid.toSub",
   "mul_assoc",
   "Nat.Prime",
   "LinearOrderedCommRing.toLinearOrderedCommSemiring",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "Mathlib.Tactic.PushNeg.not_le_eq",
   "HDiv.hDiv",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "HPow.hPow",
   "instHSub",
   "Or",
   "List.range'",
   "Odd.add_odd",
   "Int.instRing",
   "CommMagma.toMul",
   "LinearOrderedCommSemiring.toStrictOrderedCommSemiring",
   "Nat.instLocallyFiniteOrder",
   "Mathlib.Tactic.Ring.neg_zero",
   "eq_true",
   "Nat.zero",
   "AddMonoidWithOne.toOne",
   "LT.lt",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "Finset.Ioo",
   "Exists",
   "Int.instAddGroup",
   "Nat.instStrictOrderedSemiring",
   "Semiring.toMonoidWithZero",
   "Mathlib.Tactic.Ring.sub_congr",
   "IsRightCancelAdd.covariant_swap_add_lt_of_covariant_swap_add_le",
   "NeZero.one",
   "AddMonoid.toAddZeroClass",
   "True",
   "one_lt_two",
   "Nat.instAddCancelCommMonoid",
   "Int.odd_iff_not_even",
   "AddMonoidWithOne.toNatCast",
   "AddMonoid.toAddSemigroup",
   "Int.instCovariantClassAddLE",
   "Finset",
   "AddCancelCommMonoid.toAddCancelMonoid",
   "FltRegular.a_not_cong_b",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "covariant_swap_add_of_covariant_add",
   "Int.negOfNat",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.instMul",
   "Mathlib.Tactic.Ring.cast_pos",
   "One.toOfNat1",
   "Even",
   "Ne.symm",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "CanonicallyOrderedCommSemiring.toCanonicallyOrderedAddCommMonoid",
   "Int.instLinearOrderedCommRing",
   "Bool.false",
   "List.Mem.head",
   "Mathlib.Tactic.Ring.atom_pf",
   "Int.ediv_mul_cancel",
   "Int.instNormedCommRing",
   "Exists.casesOn",
   "instLTNat",
   "Preorder.toLE",
   "Int.instAdd",
   "Eq",
   "Eq.mpr",
   "Dvd.dvd.mul_left",
   "Odd",
   "Nat",
   "Ne",
   "Mathlib.Meta.NormNum.IsInt.to_isNat",
   "FltRegular.CaseI.SlightlyEasier",
   "Int.ModEq",
   "Nat.rawCast",
   "OrderedSemiring.zeroLEOneClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "Mathlib.Tactic.Zify._auxLemma.3",
   "Int.instAddCommSemigroup",
   "instHMul",
   "AddCancelMonoid.toIsCancelAdd",
   "Int.Odd.of_mul_left",
   "Not",
   "congrArg",
   "Fact",
   "Int.instLEInt",
   "OrderedAddCommGroup.toAddCommGroup",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "Mathlib.Data.Finset.Basic._auxLemma.64",
   "Fact.out",
   "OrderedSemiring.toOrderedAddCommMonoid",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "Ring.toNonAssocRing",
   "mul_comm",
   "Zero.toOfNat0",
   "instLENat",
   "Preorder.toLT",
   "instHPow",
   "add_lt_of_neg_of_le",
   "Eq.symm",
   "Nat.decLe",
   "NeZero.succ",
   "AddSemigroup.toAdd",
   "instHAdd",
   "HSub.hSub",
   "Mathlib.Meta.NormNum.isNat_ofNat",
   "AddGroup.toSubNegMonoid",
   "Int.instCancelCommMonoidWithZero",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "CommSemigroup.toCommMagma",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "HMul.hMul",
   "List.noConfusion",
   "Int.instCommSemiring",
   "NegZeroClass.toZero",
   "dvd_mul_of_dvd_right",
   "Int.instNontrivial"],
  "name": "FltRegular.CaseI.may_assume",
  "constType": "FltRegular.CaseI.SlightlyEasier → FltRegular.CaseI.Statement",
  "constCategory": "Theorem"},
 {"references": ["Nat"],
  "name": "Nat.zero",
  "constType": "ℕ",
  "constCategory": "Other"},
 {"references":
  ["CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "CommRing.toCommMonoid",
   "Semiring.toMonoidWithZero",
   "Localization",
   "CommRing",
   "nonZeroDivisors"],
  "name": "FractionRing",
  "constType": "(R : Type u_1) → [inst : CommRing R] → Type u_1",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_1._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Semiring.toNonUnitalSemiring",
   "Monoid.mk",
   "NonUnitalSemiring.mul_assoc",
   "Semiring.mul_one",
   "Semiring.npow_succ",
   "CommRing.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "Semiring.npow_zero",
   "Ring.toSemiring",
   "Semiring.one_mul",
   "CommRing",
   "Semiring.toOne",
   "CommMonoid",
   "Semiring.npow",
   "CommRing.toRing",
   "CommMonoid.mk",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Semigroup.mk"],
  "name": "CommRing.toCommMonoid",
  "constType": "{α : Type u} → [self : CommRing α] → CommMonoid α",
  "constCategory": "Definition"},
 {"references": ["CommRing"],
  "name": "IsDedekindDomain",
  "constType": "(A : Type u_2) → [inst : CommRing A] → Prop",
  "constCategory": "Other"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_3",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_2"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "OfNat.ofNat",
   "eq_true",
   "PartialOrder.toPreorder",
   "AddMonoid.toZero",
   "CanonicallyOrderedAddCommMonoid",
   "AddCommMonoid.toAddMonoid",
   "zero_le",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "LE.le",
   "True",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "Eq",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.29",
  "constType":
  "∀ {α : Type u} [inst : CanonicallyOrderedAddCommMonoid α] (a : α), (0 ≤ a) = True",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "LinearOrderedCommMonoidWithZero",
  "constType": "Type u_2 → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["Distrib.toAdd",
   "Lean.Data.AC.Expr.op",
   "AddCommSemigroup.toAddCommMagma",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "two_mul",
   "HAdd.hAdd",
   "PLift",
   "Eq.refl",
   "Exists.intro",
   "Exists.casesOn",
   "Odd.proof_1",
   "Semiring.toNatCast",
   "Eq",
   "Lean.Data.AC.Variable.mk",
   "Lean.Data.AC.Variable",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "PLift.up",
   "Lean.Data.AC.Context",
   "Option.none",
   "AddMonoid.toAddSemigroup",
   "Bool.true",
   "Lean.Data.AC.Context.eq_of_norm",
   "Option.some",
   "instOfNatNat",
   "List.nil",
   "Odd",
   "Nat",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "instOfNatAtLeastTwo",
   "id",
   "List.cons",
   "instHAdd",
   "Semiring",
   "Lean.Data.AC.eval",
   "AddMonoidWithOne.toAddMonoid",
   "One.toOfNat1",
   "Even",
   "Std.Commutative",
   "NonUnitalNonAssocSemiring.toMul",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Semiring.toOne",
   "instHMul",
   "Std.LawfulIdentity",
   "Lean.Data.AC.instEvalInformationContext",
   "Eq.ndrec",
   "Std.IdempotentOp",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonAssocSemiring.toNatCast",
   "instNatAtLeastTwo",
   "congr",
   "AddCommMagma.to_isCommutative",
   "Bool",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "AddSemigroup.to_isAssociative",
   "Lean.Data.AC.Context.mk",
   "congrArg",
   "Lean.Data.AC.Expr.var"],
  "name": "Odd.add_odd",
  "constType":
  "∀ {α : Type u_2} [inst : Semiring α] {a b : α}, Odd a → Odd b → Even (a + b)",
  "constCategory": "Theorem"},
 {"references": ["Ne", "Ne.eq_def", "Not", "Eq.symm", "Eq"],
  "name": "FltRegular.CaseI.AuxLemmas._auxLemma.5",
  "constType": "∀ {α : Sort u} (a b : α), (¬a = b) = (a ≠ b)",
  "constCategory": "Theorem"},
 {"references": ["HSub.mk", "HSub", "Sub.sub", "Sub"],
  "name": "instHSub",
  "constType": "{α : Type u_1} → [inst : Sub α] → HSub α α α",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHSub",
   "SubNegMonoid.toSub",
   "OfNat.ofNat",
   "AddGroup",
   "propext",
   "HSub.hSub",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_zero",
   "SubNegZeroMonoid.toNegZeroClass",
   "NegZeroClass.toZero",
   "AddGroup.toSubNegMonoid",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.9",
  "constType":
  "∀ {G : Type u_3} [inst : AddGroup G] {a b : G}, (a - b = 0) = (a = b)",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Ne",
   "OfNat.ofNat",
   "Monoid",
   "isUnit_pow_iff",
   "instHPow",
   "propext",
   "Monoid.toNatPow",
   "instOfNatNat",
   "IsUnit",
   "Nat",
   "Eq"],
  "name": "FltRegular.NumberTheory.Cyclotomic.MoreLemmas._auxLemma.14",
  "constType":
  "∀ {M : Type u_1} [inst : Monoid M] {n : ℕ} {a : M}, n ≠ 0 → IsUnit (a ^ n) = IsUnit a",
  "constCategory": "Theorem"},
 {"references":
  ["Nat.Prime",
   "instFactLtNatOfNatOfPrime_fltRegular",
   "Eq.refl",
   "IsRegularPrime",
   "IsRegularNumber",
   "Nat",
   "Fact",
   "Eq"],
  "name": "IsRegularPrime.eq_1",
  "constType":
  "∀ (p : ℕ) [inst : Fact (Nat.Prime p)], IsRegularPrime p = IsRegularNumber p",
  "constCategory": "Theorem"},
 {"references":
  ["PartialOrder.toPreorder",
   "LinearOrder",
   "Preorder.toLT",
   "propext",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "not_le",
   "LE.le",
   "Preorder.toLE",
   "Eq"],
  "name": "Mathlib.Tactic.PushNeg.not_le_eq",
  "constType":
  "∀ {β : Type u_2} [inst : LinearOrder β] (a b : β), (¬a ≤ b) = (b < a)",
  "constCategory": "Theorem"},
 {"references":
  ["Monoid.toSemigroup",
   "SemigroupWithZero.mk",
   "MonoidWithZero.toMonoid",
   "MonoidWithZero.mul_zero",
   "MonoidWithZero.zero_mul",
   "MonoidWithZero.toZero",
   "SemigroupWithZero",
   "MonoidWithZero"],
  "name": "MonoidWithZero.toSemigroupWithZero",
  "constType":
  "{M₀ : Type u} → [self : MonoidWithZero M₀] → SemigroupWithZero M₀",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "AddGroupWithOne.toIntCast",
   "neg_zero",
   "HAdd.hAdd",
   "AddGroup.toSubtractionMonoid",
   "Eq.refl",
   "neg_neg",
   "AddGroupWithOne.toAddGroup",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "InvolutiveNeg.toNeg",
   "AddGroupWithOne",
   "instOfNatNat",
   "Int.instNegInt",
   "Int.cast_negSucc",
   "Nat",
   "Nat.succ",
   "instOfNat",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id",
   "Int.cast_natCast",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instAddNat",
   "instHAdd",
   "Unit",
   "AddGroupWithOne.toNeg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "SubtractionMonoid.toInvolutiveNeg",
   "Int.cast_zero",
   "Int.cast_neg.match_1",
   "instNatCastInt",
   "Int.negSucc",
   "Int.cast",
   "NegZeroClass.toZero",
   "congrArg",
   "NegZeroClass.toNeg",
   "Int"],
  "name": "Int.cast_neg",
  "constType": "∀ {R : Type u} [inst : AddGroupWithOne R] (n : ℤ), ↑(-n) = -↑n",
  "constCategory": "Theorem"},
 {"references": ["Nat.instMonoid", "Irreducible", "Nat"],
  "name": "Nat.Prime",
  "constType": "ℕ → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Decidable.isFalse",
   "Decidable",
   "Decidable.isTrue",
   "Not",
   "Decidable.rec"],
  "name": "Decidable.casesOn",
  "constType":
  "{p : Prop} →\n  {motive : Decidable p → Sort u} →\n    (t : Decidable p) → ((h : ¬p) → motive (isFalse h)) → ((h : p) → motive (isTrue h)) → motive t",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "_obj",
   "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_8",
   "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_10"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_11._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["EStateM",
   "Lean.Macro.Context.mk",
   "Lean.Macro.Context",
   "Lean.Macro.Context.currMacroScope",
   "Lean.MacroM",
   "Lean.MonadRef",
   "Lean.Macro.Context.ref",
   "Pure.pure",
   "Monad.toBind",
   "Lean.Syntax",
   "MonadReader.read",
   "Lean.Macro.Context.methods",
   "instMonadWithReaderOfReaderT",
   "EStateM.instMonad",
   "ReaderT.instApplicativeOfMonad",
   "instMonadReaderOfReaderTOfMonad",
   "Lean.Macro.State",
   "Lean.Macro.Context.mainModule",
   "Lean.MonadRef.mk",
   "Lean.Macro.Exception",
   "Lean.Macro.Context.maxRecDepth",
   "ReaderT.instMonad",
   "Lean.Macro.Context.currRecDepth",
   "Bind.bind",
   "MonadWithReader.withReader",
   "instMonadReaderOfMonadReaderOf",
   "instMonadWithReaderOfMonadWithReaderOf",
   "Applicative.toPure"],
  "name": "Lean.Macro.instMonadRefMacroM",
  "constType": "Lean.MonadRef Lean.MacroM",
  "constCategory": "Definition"},
 {"references": ["Iff"],
  "name": "Iff.mpr",
  "constType": "∀ {a b : Prop}, (a ↔ b) → b → a",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "Lean.ParserDescr.node",
   "Lean.Name.num._override",
   "_obj",
   "Lean.Name.str._override",
   "Lean.ParserDescr.symbol"],
  "name": "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["DecidableEq", "Int.decEq", "Int"],
  "name": "Int.instDecidableEq",
  "constType": "DecidableEq ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Iff.intro",
   "Iff",
   "not_lt_of_ge",
   "PartialOrder.toPreorder",
   "LinearOrder",
   "le_of_not_gt",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toPartialOrder",
   "Not",
   "LE.le",
   "Preorder.toLE"],
  "name": "not_lt",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b : α}, ¬a < b ↔ b ≤ a",
  "constCategory": "Theorem"},
 {"references":
  ["DecidableEq",
   "Finset.instInsert.proof_1",
   "Finset",
   "Finset.val",
   "Multiset.ndinsert",
   "Finset.mk",
   "Insert",
   "Insert.mk"],
  "name": "Finset.instInsert",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → Insert α (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["AddMonoidWithOne",
   "Mathlib.Meta.NormNum.IsNat",
   "Nat.rawCast",
   "Nat",
   "Mathlib.Meta.NormNum.IsNat.mk",
   "rfl"],
  "name": "Mathlib.Meta.NormNum.IsNat.of_raw",
  "constType":
  "∀ (α : Type u_1) [inst : AddMonoidWithOne α] (n : ℕ), Mathlib.Meta.NormNum.IsNat n.rawCast n",
  "constCategory": "Theorem"},
 {"references":
  ["instHSub",
   "AddZeroClass.toAdd",
   "OfNat.ofNat",
   "SubNegMonoid.toNeg",
   "instHAdd",
   "HAdd.hAdd",
   "HSub.hSub",
   "Eq.refl",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "AddMonoid.toAddZeroClass",
   "AddGroup.toSubNegMonoid",
   "Eq",
   "Zero.toOfNat0",
   "SubNegMonoid.toSub",
   "add_right_neg",
   "Eq.mpr",
   "AddGroup",
   "AddMonoid.toZero",
   "SubNegMonoid.toAddMonoid",
   "congrArg",
   "NegZeroClass.toZero",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "id"],
  "name": "sub_self",
  "constType": "∀ {G : Type u_3} [inst : AddGroup G] (a : G), a - a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "ZeroHomClass.mk",
   "RingHomClass.mk",
   "RingHom",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "MulOneClass.toMul",
   "MulZeroOneClass.toMulOneClass",
   "OneHom.map_one'",
   "RingHomClass",
   "OneHomClass.mk",
   "MulOneClass.toOne",
   "MonoidHom.map_mul'",
   "AddMonoidWithOne.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHom.instFunLike",
   "MulHomClass.mk",
   "NonAssocSemiring",
   "AddZeroClass.toZero",
   "AddHomClass.mk",
   "MonoidHom.toOneHom",
   "RingHom.map_zero'",
   "RingHom.map_add'",
   "RingHom.toMonoidHom",
   "AddMonoidHomClass.mk",
   "MonoidHomClass.mk"],
  "name": "RingHom.instRingHomClass",
  "constType":
  "∀ {α : Type u_2} {β : Type u_3} {x : NonAssocSemiring α} {x_1 : NonAssocSemiring β}, RingHomClass (α →+* β) α β",
  "constCategory": "Definition"},
 {"references":
  ["Units.instInv",
   "Monoid",
   "Units.coeHom",
   "MonoidHom.comp",
   "MonoidHomClass.toMonoidHom",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "Eq",
   "DivisionMonoid",
   "MonoidHomClass",
   "Units",
   "FunLike",
   "DivInvOneMonoid.toInvOneClass",
   "Units.val",
   "DivisionMonoid.toDivInvMonoid",
   "Units.instMulOneClass",
   "DFunLike.coe",
   "DivisionMonoid.toDivInvOneMonoid",
   "InvOneClass.toInv",
   "MonoidHom.map_inv",
   "Units.instGroup",
   "Inv.inv"],
  "name": "map_units_inv",
  "constType":
  "∀ {α : Type u_1} {M : Type u} [inst : Monoid M] [inst_1 : DivisionMonoid α] {F : Type u_2} [inst_2 : FunLike F M α]\n  [inst_3 : MonoidHomClass F M α] (f : F) (u : Mˣ), f ↑u⁻¹ = (f ↑u)⁻¹",
  "constCategory": "Theorem"},
 {"references": ["OrderedSemiring", "PartialOrder"],
  "name": "OrderedSemiring.toPartialOrder",
  "constType": "{α : Type u} → [self : OrderedSemiring α] → PartialOrder α",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "SetLike.instPartialOrder",
   "SetLike",
   "Iff",
   "PartialOrder.toPreorder",
   "Iff.rfl",
   "LE.le",
   "SetLike.instMembership",
   "Preorder.toLE"],
  "name": "SetLike.le_def",
  "constType":
  "∀ {A : Type u_1} {B : Type u_2} [i : SetLike A B] {S T : A}, S ≤ T ↔ ∀ ⦃x : B⦄, x ∈ S → x ∈ T",
  "constCategory": "Theorem"},
 {"references": ["Eq.rec", "Eq.refl", "Eq"],
  "name": "Eq.casesOn",
  "constType":
  "{α : Sort u_1} →\n  {a : α} → {motive : (a_1 : α) → a = a_1 → Sort u} → {a_1 : α} → (t : a = a_1) → motive a ⋯ → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Unique.instSubsingleton",
   "OfNat.ofNat",
   "Finsupp",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "linearIndependent_iff",
   "AddCommMonoid.toAddMonoid",
   "LinearMap.instFunLike",
   "Finsupp.module",
   "Finsupp.total",
   "IsEmpty",
   "RingHom.id",
   "Iff.mpr",
   "Subsingleton.elim",
   "LinearIndependent",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Finsupp.instAddCommMonoid",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "AddMonoid.toZero",
   "Finsupp.uniqueOfLeft",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Module",
   "MonoidWithZero.toZero",
   "DFunLike.coe",
   "Finsupp.instZero",
   "LinearMap",
   "Semiring.toModule",
   "AddCommMonoid"],
  "name": "linearIndependent_empty_type",
  "constType":
  "∀ {ι : Type u'} {R : Type u_2} {M : Type u_4} {v : ι → M} [inst : Semiring R] [inst_1 : AddCommMonoid M]\n  [inst_2 : Module R M] [inst_3 : IsEmpty ι], LinearIndependent R v",
  "constCategory": "Theorem"},
 {"references": ["true_and", "And", "Iff", "iff_of_eq", "True"],
  "name": "true_and_iff",
  "constType": "∀ (p : Prop), True ∧ p ↔ p",
  "constCategory": "Theorem"},
 {"references": ["AddMonoid.nsmul", "SMul", "SMul.mk", "Nat", "AddMonoid"],
  "name": "AddMonoid.toNatSMul",
  "constType": "{M : Type u_2} → [inst : AddMonoid M] → SMul ℕ M",
  "constCategory": "Definition"},
 {"references":
  ["Submodule.instBot",
   "Bot.bot",
   "Finsupp",
   "Submodule",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "LinearMap.instFunLike",
   "LinearIndependent.proof_1",
   "Finsupp.module",
   "Finsupp.total",
   "RingHom.id",
   "Eq",
   "Finsupp.instAddCommMonoid",
   "Semiring.toNonAssocSemiring",
   "LinearMap.ker",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Module",
   "MonoidWithZero.toZero",
   "LinearMap",
   "Semiring.toModule",
   "AddCommMonoid"],
  "name": "LinearIndependent",
  "constType":
  "{ι : Type u'} →\n  (R : Type u_2) →\n    {M : Type u_4} → (ι → M) → [inst : Semiring R] → [inst_1 : AddCommMonoid M] → [inst : Module R M] → Prop",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "propext",
   "Set",
   "Set.mem_image",
   "Set.instMembership",
   "Set.image",
   "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.2",
  "constType":
  "∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β), (y ∈ f '' s) = ∃ x ∈ s, f x = y",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.Name.anonymous._impl",
   "_obj",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_1"],
  "name":
  "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Dvd"],
  "name": "Dvd.dvd",
  "constType": "{α : Type u_1} → [self : Dvd α] → α → α → Prop",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr4",
  "constType": "String → String → String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references":
  ["IsLocalization.toLocalizationMap",
   "Membership.mem",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "MulZeroOneClass.toMulOneClass",
   "CommSemiring",
   "Algebra",
   "Submonoid",
   "CommSemiring.toCommMonoid",
   "Submonoid.LocalizationMap.mk'",
   "IsLocalization",
   "NonAssocSemiring.toMulZeroOneClass",
   "Submonoid.instSetLike",
   "SetLike.instMembership",
   "Subtype"],
  "name": "IsLocalization.mk'",
  "constType":
  "{R : Type u_1} →\n  [inst : CommSemiring R] →\n    {M : Submonoid R} →\n      (S : Type u_2) → [inst_1 : CommSemiring S] → [inst_2 : Algebra R S] → [inst_3 : IsLocalization M S] → R → ↥M → S",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Algebra.toModule.proof_5",
   "DistribMulAction.mk",
   "Algebra.toModule.proof_6",
   "Semiring",
   "Semiring.toMonoidWithZero",
   "AddCommMonoid.toAddMonoid",
   "Algebra.toModule.proof_3",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "MulAction.mk",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommSemiring",
   "Algebra",
   "Algebra.toModule.proof_4",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Module",
   "Algebra.toModule.proof_2",
   "Algebra.toSMul",
   "Algebra.toModule.proof_1",
   "Module.mk"],
  "name": "Algebra.toModule",
  "constType":
  "{R : Type u} → {A : Type w} → [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → Module R A",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Exists",
   "CommMonoidWithZero.toZero",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "MulZeroOneClass.toMulOneClass",
   "Subtype.val",
   "IsLocalization.mk'",
   "Set",
   "IsLocalization.mk'_eq_zero_iff",
   "IsLocalization",
   "Set.instMembership",
   "NonUnitalNonAssocSemiring.toMul",
   "NonAssocSemiring.toMulZeroOneClass",
   "SetLike.instMembership",
   "Eq",
   "Zero.toOfNat0",
   "instHMul",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "propext",
   "CommSemiring",
   "Algebra",
   "HMul.hMul",
   "Submonoid",
   "CommSemiring.toCommMonoidWithZero",
   "Submonoid.instSetLike",
   "Subtype",
   "SetLike.coe"],
  "name": "FltRegular.NumberTheory.QuotientTrace._auxLemma.4",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {M : Submonoid R} {S : Type u_2} [inst_1 : CommSemiring S]\n  [inst_2 : Algebra R S] [inst_3 : IsLocalization M S] (x : R) (s : ↥M),\n  (IsLocalization.mk' S x s = 0) = ∃ m, ↑m * x = 0",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "Multiset.prod_nsmul",
   "instHSMul",
   "AddCommMonoid.toAddMonoid",
   "Eq",
   "AddMonoid.toNatSMul",
   "CommMonoid",
   "instHPow",
   "Multiset",
   "Multiset.prod",
   "HSMul.hSMul",
   "Monoid.toNatPow",
   "Nat",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoid",
   "CommMonoid.toMonoid",
   "Eq.symm",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.6",
  "constType":
  "∀ {α : Type u_3} [inst : CommMonoid α] (m : Multiset α) (n : ℕ), m.prod ^ n = (n • m).prod",
  "constCategory": "Theorem"},
 {"references":
  ["CommMagma",
   "CommMagma.mk",
   "NonUnitalNonAssocCommSemiring",
   "NonUnitalNonAssocCommSemiring.mul_comm",
   "NonUnitalNonAssocSemiring.toMul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring"],
  "name": "NonUnitalNonAssocCommSemiring.toCommMagma",
  "constType":
  "{α : Type u} → [self : NonUnitalNonAssocCommSemiring α] → CommMagma α",
  "constCategory": "Definition"},
 {"references":
  ["right_distrib",
   "instHMul",
   "RightDistribClass",
   "instHAdd",
   "HAdd.hAdd",
   "HMul.hMul",
   "Add",
   "Mul",
   "Eq"],
  "name": "add_mul",
  "constType":
  "∀ {R : Type x} [inst : Mul R] [inst_1 : Add R] [inst_2 : RightDistribClass R] (a b c : R), (a + b) * c = a * c + b * c",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Iff.rfl",
   "CommRing.toNonUnitalCommRing",
   "Set",
   "CommSemiring.toNonUnitalCommSemiring",
   "Ideal.span",
   "semigroupDvd",
   "SetLike.instMembership",
   "CommRing",
   "Submodule.Quotient.instZeroQuotient",
   "Eq",
   "Zero.toOfNat0",
   "Semiring.toNonAssocSemiring",
   "Set.instSingletonSet",
   "Eq.mpr",
   "Iff",
   "DFunLike.coe",
   "HasQuotient.Quotient",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Ideal.instHasQuotient",
   "Semiring.toModule",
   "id",
   "Ideal.Quotient.commRing",
   "Membership.mem",
   "Dvd.dvd",
   "Ideal.Quotient.eq_zero_iff_mem",
   "RingHom.instFunLike",
   "SemigroupWithZero.toSemigroup",
   "CommRing.toCommSemiring",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "CommRing.toRing",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Singleton.singleton",
   "Ideal.Quotient.mk",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal.mem_span_singleton",
   "congrArg",
   "Ideal",
   "Submodule.setLike"],
  "name": "Ideal.Quotient.eq_zero_iff_dvd",
  "constType":
  "∀ {R : Type u} [inst : CommRing R] (x y : R), (Ideal.Quotient.mk (Ideal.span {x})) y = 0 ↔ x ∣ y",
  "constCategory": "Theorem"},
 {"references":
  ["HPow.hPow",
   "MonoidHomClass",
   "Monoid",
   "FunLike",
   "map_pow",
   "instHPow",
   "Monoid.toNatPow",
   "DFunLike.coe",
   "Nat",
   "Eq.symm",
   "Monoid.toMulOneClass",
   "Eq"],
  "name": "FltRegular.NumberTheory.Unramified._auxLemma.2",
  "constType":
  "∀ {G : Type u_7} {H : Type u_8} {F : Type u_9} [inst : FunLike F G H] [inst_1 : Monoid G] [inst_2 : Monoid H]\n  [inst_3 : MonoidHomClass F G H] (f : F) (a : G) (n : ℕ), f a ^ n = f (a ^ n)",
  "constCategory": "Theorem"},
 {"references":
  ["Finsupp",
   "MvPolynomial.support",
   "Nat.instLinearOrderedCommMonoidWithZero",
   "MvPolynomial",
   "CommSemiring",
   "Finsupp.sum",
   "LinearOrderedCommMonoidWithZero.toZero",
   "Lattice.toSemilatticeSup",
   "Nat",
   "Nat.instOrderBot",
   "Nat.instLattice",
   "Finset.sup",
   "Nat.instAddCommMonoid"],
  "name": "MvPolynomial.totalDegree",
  "constType":
  "{R : Type u} → {σ : Type u_1} → [inst : CommSemiring R] → MvPolynomial σ R → ℕ",
  "constCategory": "Definition"},
 {"references":
  ["Zero.toOfNat0",
   "instHMul",
   "OfNat.ofNat",
   "MulZeroClass.toZero",
   "HMul.hMul",
   "MulZeroClass",
   "MulZeroClass.toMul",
   "Eq"],
  "name": "MulZeroClass.zero_mul",
  "constType": "∀ {M₀ : Type u} [self : MulZeroClass M₀] (a : M₀), 0 * a = 0",
  "constCategory": "Theorem"},
 {"references":
  ["CommRing.toCommMonoid",
   "inferInstance",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "FractionRing",
   "OreLocalization.oreSetComm",
   "Field",
   "IsDomain",
   "Semiring.toMonoidWithZero",
   "OreLocalization.instFieldNonZeroDivisors",
   "FractionRing.field.proof_1",
   "CommRing",
   "nonZeroDivisors",
   "FractionRing.field.proof_2"],
  "name": "FractionRing.field",
  "constType":
  "(A : Type u_4) → [inst : CommRing A] → [inst_1 : IsDomain A] → Field (FractionRing A)",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_10",
   "Lean.Name.str._override",
   "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_5"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.AuxLemmas._hyg.717._closed_6._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["gcd_div_div_zeta_sub_one",
   "Semigroup.toMul",
   "Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "Ideal.span",
   "NormalizedGCDMonoid.toGCDMonoid",
   "algebraRat",
   "MulZeroClass.toMul",
   "Finset.instMembership",
   "Eq",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "Nat",
   "Subtype",
   "HPow.hPow",
   "instHSub",
   "NumberField.RingOfIntegers.instIsDedekindDomain",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NumberField.to_charZero",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NumberField.RingOfIntegers.instIsDomain",
   "Field.toEuclideanDomain",
   "NumberField.inst_ringOfIntegersAlgebra",
   "NumberField",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Algebra.id",
   "Fact",
   "Field.toDivisionRing",
   "Ideal",
   "div_zeta_sub_one_dvd_gcd.proof_1",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Submodule.idemSemiring",
   "PNat.Prime",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "semigroupDvd",
   "PNat.val",
   "GCDMonoid.gcd",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instHPow",
   "Finset",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "div_zeta_sub_one",
   "NeZero.succ",
   "Membership.mem",
   "Ideal.cancelCommMonoidWithZero",
   "instAddNat",
   "instHAdd",
   "Ideal.instNormalizedGCDMonoid",
   "Rat",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Dvd.dvd",
   "Ring.toSemiring",
   "Polynomial.nthRootsFinset",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "Exists.choose",
   "Units.val",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IdemSemiring.toSemiring",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "div_zeta_sub_one_dvd_gcd",
  "constType":
  "{K : Type u_1} →\n  {p : ℕ+} →\n    [hpri : Fact p.Prime] →\n      [inst : Field K] →\n        [inst_1 : NumberField K] →\n          [inst_2 : IsCyclotomicExtension {p} ℚ K] →\n            p ≠ 2 →\n              {ζ : K} →\n                (hζ : IsPrimitiveRoot ζ ↑p) →\n                  {x y z : NumberField.RingOfIntegers K} →\n                    {ε : (NumberField.RingOfIntegers K)ˣ} →\n                      {m : ℕ} →\n                        x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p →\n                          ¬↑hζ.unit' - 1 ∣ y →\n                            { x // x ∈ Polynomial.nthRootsFinset (↑p) (NumberField.RingOfIntegers K) } →\n                              Ideal (NumberField.RingOfIntegers K)",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termP_1._closed_7._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Monoid",
   "Units.instInv",
   "Units.instMonoid",
   "DivInvMonoid",
   "DivInvMonoid.mk",
   "Units.instDivInvMonoid.proof_1",
   "Units",
   "Units.instDivInvMonoid.match_1",
   "instHPow",
   "Units.instDiv",
   "Monoid.toNatPow",
   "Units.instDivInvMonoid.proof_2",
   "Units.instDivInvMonoid.proof_4",
   "Nat",
   "Int",
   "Nat.succ",
   "Units.instDivInvMonoid.proof_3",
   "Inv.inv"],
  "name": "Units.instDivInvMonoid",
  "constType": "{α : Type u} → [inst : Monoid α] → DivInvMonoid αˣ",
  "constCategory": "Definition"},
 {"references":
  ["Finset.empty", "EmptyCollection.mk", "Finset", "EmptyCollection"],
  "name": "Finset.instEmptyCollection",
  "constType": "{α : Type u_1} → EmptyCollection (Finset α)",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Semigroup",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["LinearOrderedCommMonoid.toOrderedCommMonoid",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "zero_le'",
   "LinearOrderedCommMonoidWithZero",
   "le_rfl",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Iff.intro",
   "Zero.toOfNat0",
   "Iff",
   "Eq.rec",
   "OrderedCommMonoid.toPartialOrder",
   "LinearOrderedCommMonoidWithZero.toZero",
   "LinearOrderedCommMonoidWithZero.toLinearOrderedCommMonoid",
   "le_antisymm"],
  "name": "le_zero_iff",
  "constType":
  "∀ {α : Type u_1} [inst : LinearOrderedCommMonoidWithZero α] {a : α}, a ≤ 0 ↔ a = 0",
  "constCategory": "Theorem"},
 {"references": ["outParam", "Singleton"],
  "name": "Singleton.singleton",
  "constType":
  "{α : outParam (Type u)} → {β : Type v} → [self : Singleton α β] → α → β",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "CommSemiring.toSemiring",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "Units.instInv",
   "OfNat.ofNat",
   "Nat.Prime.odd_of_ne_two",
   "SubNegMonoid.toNeg",
   "HasDistribNeg",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "algebraRat",
   "AddGroupWithOne.toAddGroup",
   "Nat.Prime",
   "NumberField.Embeddings.pow_eq_one_of_norm_eq_one",
   "Iff",
   "normedAlgebraRat",
   "IsPrimitiveRoot.unit'",
   "Field",
   "HasDistribNeg.toInvolutiveNeg",
   "map_mul",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "HPow.hPow",
   "Or",
   "instOfNatPNatOfNeZeroNat",
   "MulOneClass.toOne",
   "Units.instMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "MonoidHom",
   "NumberField.to_charZero",
   "CommMagma.toMul",
   "CommRing.toCommMonoid",
   "False.elim",
   "RingHomClass.toMonoidHomClass",
   "unit_inv_conj_not_neg_zeta_runity",
   "LT.lt",
   "NumberField",
   "Field.toDivisionRing",
   "Int",
   "NumberField.RingOfIntegers.instAlgebra_1",
   "Inv.inv",
   "RingHom.IsIntegralElem.mul",
   "AddCommGroup.toDivisionAddCommMonoid",
   "Exists",
   "Set",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "NonAssocSemiring.toMulZeroOneClass",
   "algebraInt",
   "True",
   "RingHomClass.toNonUnitalRingHomClass",
   "RingHomClass.toAddMonoidHomClass",
   "Units.instNeg",
   "zeta_runity_pow_even",
   "NumberField.RingOfIntegers.isIntegral_coe",
   "map_pow",
   "InvolutiveNeg.toNeg",
   "Monoid.toNatPow",
   "neg_mul",
   "RCLike.toNormedAlgebra",
   "NonUnitalNonAssocRing.toMul",
   "Ring.toAddGroupWithOne",
   "Or.inr",
   "Odd.neg_one_pow",
   "algebraMap",
   "Field.toSemifield",
   "One.toOfNat1",
   "Neg.neg",
   "Even",
   "Monoid.toMulOneClass",
   "IsCyclotomicExtension",
   "Units",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "Or.inl",
   "letFun",
   "not_true_eq_false",
   "Ring.toAddCommGroup",
   "Semifield.toDivisionSemiring",
   "Nat.even_or_odd",
   "PNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "MulZeroOneClass.toMulOneClass",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "Units.val_mul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Exists.casesOn",
   "instLTNat",
   "unit_lemma_val_one",
   "Classical.byContradiction",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Mathlib.Algebra.Group.Units._auxLemma.1",
   "Iff.mp",
   "Ring.toNeg",
   "MonoidWithZero.toMonoid",
   "FltRegular.NumberTheory.Cyclotomic.UnitLemmas._auxLemma.15",
   "Nat",
   "Odd",
   "Eq.trans",
   "Even.neg_one_pow",
   "Units.instMul",
   "Ne",
   "Monoid",
   "Complex.instNormedField",
   "Nat.instSemiring",
   "Or.casesOn",
   "EuclideanDomain.toCommRing",
   "RingHom.instFunLike",
   "unitGalConj",
   "instHMul",
   "Mathlib.RingTheory.Localization.FractionRing._auxLemma.3",
   "norm_cast_ne_two",
   "Field.toEuclideanDomain",
   "Complex.instRCLike",
   "Eq.mp",
   "CommRing.toRing",
   "Nat.instCommSemigroup",
   "Not",
   "Singleton.singleton",
   "MonoidHom.instFunLike",
   "Algebra.id",
   "congrArg",
   "NormedField.toNormedDivisionRing",
   "NumberField.RingOfIntegers.instIsFractionRing",
   "RingHom",
   "DivisionRing.toRing",
   "Iff.rfl",
   "CommRing.toNonUnitalCommRing",
   "roots_of_unity_in_cyclo",
   "Complex.instCharZero",
   "NumberField.RingOfIntegers.instCommRing",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Complex.isAlgClosed",
   "mul_comm",
   "PNat.val",
   "Rat.commRing",
   "Set.instSingletonSet",
   "one_mul",
   "instHPow",
   "instOfNatNat",
   "Units.instMulOneClass",
   "Units.val_pow_eq_pow_val",
   "DFunLike.coe",
   "Eq.symm",
   "id",
   "eq_self",
   "NeZero.succ",
   "funext",
   "False",
   "instAddNat",
   "Rat",
   "Algebra.cast",
   "exists_congr",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "Semiring.toOne",
   "DivisionSemiring.toSemiring",
   "SubtractionMonoid.toSubNegMonoid",
   "CommSemigroup.toCommMagma",
   "map_neg",
   "Units.val",
   "HMul.hMul",
   "Complex",
   "instMulNat",
   "NumberField.RingOfIntegers"],
  "name": "unit_inv_conj_is_root_of_unity",
  "constType":
  "∀ {p : ℕ+} {K : Type u_1} [inst : Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p) [inst_1 : NumberField K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K],\n  p ≠ 2 → Nat.Prime ↑p → ∀ (u : (NumberField.RingOfIntegers K)ˣ), ∃ m, u * ((unitGalConj K p) u)⁻¹ = (hζ.unit' ^ m) ^ 2",
  "constCategory": "Theorem"},
 {"references":
  ["CancelCommMonoidWithZero.toCommMonoidWithZero",
   "HEq",
   "Eq.refl",
   "Multiset.map_id",
   "normalize",
   "normalize_eq",
   "CancelCommMonoidWithZero",
   "Eq",
   "Multiset.map_congr",
   "Multiset.instMembership",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "Multiset",
   "UniqueFactorizationMonoid.factors",
   "MonoidWithZeroHom",
   "DFunLike.coe",
   "Eq.symm",
   "MonoidWithZeroHom.funLike",
   "id",
   "CommMonoidWithZero.toMonoidWithZero",
   "Membership.mem",
   "funext",
   "eq_of_heq",
   "UniqueFactorizationMonoid.normalizedFactors",
   "Unique",
   "Multiset.map",
   "Units",
   "UniqueFactorizationMonoid",
   "MonoidWithZero.toMulZeroOneClass",
   "Eq.ndrec",
   "HEq.refl",
   "Eq.casesOn",
   "normalizationMonoidOfUniqueUnits"],
  "name": "UniqueFactorizationMonoid.factors_eq_normalizedFactors",
  "constType":
  "∀ {M : Type u_2} [inst : CancelCommMonoidWithZero M] [inst_1 : UniqueFactorizationMonoid M] [inst_2 : Unique Mˣ]\n  (x : M), UniqueFactorizationMonoid.factors x = UniqueFactorizationMonoid.normalizedFactors x",
  "constCategory": "Theorem"},
 {"references":
  ["InvOneClass.mk",
   "DivInvOneMonoid",
   "Monoid.toOne",
   "DivInvOneMonoid.inv_one",
   "InvOneClass",
   "DivInvMonoid.toMonoid",
   "DivInvOneMonoid.toDivInvMonoid",
   "DivInvMonoid.toInv"],
  "name": "DivInvOneMonoid.toInvOneClass",
  "constType": "{G : Type u_2} → [self : DivInvOneMonoid G] → InvOneClass G",
  "constCategory": "Definition"},
 {"references":
  ["inferInstance",
   "Monoid",
   "Nat.instCommMonoid",
   "CommMonoid.toMonoid",
   "Nat"],
  "name": "Nat.instMonoid",
  "constType": "Monoid ℕ",
  "constCategory": "Definition"},
 {"references":
  ["SMulZeroClass.mk",
   "Zero",
   "MulAction.toSMul",
   "SMulWithZero",
   "MonoidWithZero.toMonoid",
   "MulActionWithZero.smul_zero",
   "MulActionWithZero",
   "MulActionWithZero.zero_smul",
   "MonoidWithZero.toZero",
   "SMulWithZero.mk",
   "MulActionWithZero.toMulAction",
   "MonoidWithZero"],
  "name": "MulActionWithZero.toSMulWithZero",
  "constType":
  "(R : Type u_1) →\n  (M : Type u_3) → [inst : MonoidWithZero R] → [inst_1 : Zero M] → [m : MulActionWithZero R M] → SMulWithZero R M",
  "constCategory": "Definition"},
 {"references": ["Ne", "Ne.eq_def", "Not", "Eq.symm", "Eq"],
  "name": "FltRegular.CaseI.Statement._auxLemma.9",
  "constType": "∀ {α : Sort u} (a b : α), (¬a = b) = (a ≠ b)",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.mem_cons",
   "Or",
   "propext",
   "Finset",
   "Finset.cons",
   "Not",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.31",
  "constType":
  "∀ {α : Type u_1} {s : Finset α} {a b : α} {h : a ∉ s}, (b ∈ Finset.cons a s h) = (b = a ∨ b ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "CommSemiring.toSemiring",
   "RingHom",
   "DivisionRing.toRing",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "Semiring.toMonoidWithZero",
   "NumberField.RingOfIntegers.instCommRing",
   "IsPrimitiveRoot.of_map_of_injective",
   "rfl",
   "Eq",
   "PNat.val",
   "Semiring.toNonAssocSemiring",
   "IsFractionRing.injective",
   "MonoidWithZero.toMonoid",
   "IsPrimitiveRoot.unit'",
   "Field",
   "DFunLike.coe",
   "Eq.symm",
   "algebraMap",
   "Field.toSemifield",
   "EuclideanDomain.toCommRing",
   "RingHom.instFunLike",
   "CommRing.toCommSemiring",
   "CommRing.toCommMonoid",
   "DivisionSemiring.toSemiring",
   "RingHomClass.toMonoidHomClass",
   "Field.toEuclideanDomain",
   "Units.val",
   "Eq.mp",
   "letFun",
   "NumberField",
   "Semifield.toDivisionSemiring",
   "Algebra.id",
   "congrArg",
   "NumberField.RingOfIntegers",
   "Field.toDivisionRing",
   "NumberField.RingOfIntegers.instIsFractionRing",
   "NumberField.RingOfIntegers.instAlgebra_1",
   "PNat"],
  "name": "IsPrimitiveRoot.unit'_coe",
  "constType":
  "∀ {p : ℕ+} {K : Type u_1} [inst : Field K] {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p) [inst_1 : NumberField K],\n  IsPrimitiveRoot ↑hζ.unit' ↑p",
  "constCategory": "Theorem"},
 {"references":
  ["Set.range",
   "Subgroup.copy",
   "MonoidHom.range.proof_1",
   "Top.top",
   "Subgroup.instTop",
   "Subgroup",
   "Group",
   "MonoidHom.instFunLike",
   "Group.toDivInvMonoid",
   "MonoidHom",
   "DFunLike.coe",
   "Subgroup.map",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass"],
  "name": "MonoidHom.range",
  "constType":
  "{G : Type u_1} → [inst : Group G] → {N : Type u_5} → [inst_1 : Group N] → (G →* N) → Subgroup N",
  "constCategory": "Definition"},
 {"references":
  ["Monoid.toSemigroup",
   "OfNat.ofNat",
   "Monoid",
   "Monoid.toOne",
   "Dvd.dvd",
   "mul_one",
   "One.toOfNat1",
   "semigroupDvd",
   "Dvd.intro",
   "Monoid.toMulOneClass"],
  "name": "dvd_refl",
  "constType": "∀ {α : Type u_1} [inst : Monoid α] (a : α), a ∣ a",
  "constCategory": "Theorem"},
 {"references":
  ["eq_self",
   "NonUnitalNonAssocRing.toHasDistribNeg",
   "NonUnitalNonAssocRing.toMul",
   "mul_neg",
   "Neg.neg",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toNonAssocRing",
   "True",
   "Eq",
   "instHMul",
   "Ring.toNeg",
   "of_eq_true",
   "InvolutiveNeg.toNeg",
   "Ring",
   "HasDistribNeg.toInvolutiveNeg",
   "HMul.hMul",
   "congrArg",
   "Eq.trans"],
  "name": "Mathlib.Tactic.RingNF.mul_neg",
  "constType": "∀ {R : Type u_2} [inst : Ring R] (a b : R), a * -b = -(a * b)",
  "constCategory": "Theorem"},
 {"references":
  ["Mathlib.Tactic.Ring.one_pow",
   "Int.cast_one",
   "RingHom.instRingHomClass",
   "Distrib.toAdd",
   "sub_add_eq_sub_sub",
   "CommSemiring.toSemiring",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "Mathlib.Meta.NormNum.IsNat.of_raw",
   "sub_self",
   "SubNegMonoid.toNeg",
   "Mathlib.Tactic.Ring.pow_zero",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocRing",
   "Subalgebra.instSetLike",
   "AddGroupWithOne.toAddGroup",
   "Semiring.toNatCast",
   "Mathlib.Tactic.Ring.add_pf_add_gt",
   "mul_pow",
   "SubNegMonoid.toSub",
   "Nat.Prime",
   "Nat.cast",
   "Mathlib.Tactic.Ring.neg_congr",
   "Int.castRingHom",
   "map_mul",
   "Mathlib.Tactic.Ring.pow_add",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Ideal.instHasQuotient",
   "instOfNat",
   "NonUnitalNonAssocRing.toAddCommGroup",
   "NonUnitalNonAssocCommSemiring.toNonUnitalNonAssocSemiring",
   "instHSub",
   "HPow.hPow",
   "add_assoc",
   "add_comm",
   "eq_of_heq",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "Set.instMembership",
   "AddCommMagma.toAdd",
   "CommRing.toCommMonoid",
   "Mathlib.Tactic.Ring.neg_zero",
   "Mathlib.Meta.NormNum.IsNat.to_isInt",
   "And",
   "AddMonoidWithOne.toOne",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.mul_pf_right",
   "congr",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "Int",
   "Submodule.setLike",
   "AddZeroClass.toAdd",
   "CommMonoidWithZero.toZero",
   "Exists",
   "AddCommGroup.toDivisionAddCommMonoid",
   "HEq",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Set",
   "Mathlib.Meta.NormNum.isInt_mul",
   "Semiring.toMonoidWithZero",
   "Int.rawCast",
   "Eq.refl",
   "Mathlib.Tactic.Ring.sub_congr",
   "semigroupDvd",
   "Exists.intro",
   "AddMonoid.toAddZeroClass",
   "algebraInt",
   "CommRing",
   "True",
   "Mathlib.Tactic.Ring.sub_pf",
   "RingHomClass.toNonUnitalRingHomClass",
   "RingHomClass.toAddMonoidHomClass",
   "IsCyclotomicExtension.adjoin_roots",
   "AddMonoid.toAddSemigroup",
   "Eq.rec",
   "Monoid.toNatPow",
   "HasQuotient.Quotient",
   "Semiring.toModule",
   "SubtractionMonoid.toSubNegZeroMonoid",
   "NonUnitalNonAssocRing.toMul",
   "Mathlib.Tactic.Ring.mul_pf_left",
   "Ring.toAddGroupWithOne",
   "Mathlib.Tactic.Ring.neg_one_mul",
   "Int.negOfNat",
   "Int.instMul",
   "Mathlib.Tactic.Ring.mul_pow",
   "algebraMap",
   "Mathlib.Tactic.Ring.mul_add",
   "Mathlib.Algebra.Module.Submodule.Basic._auxLemma.6",
   "One.toOfNat1",
   "Neg.neg",
   "SubNegZeroMonoid.toNegZeroClass",
   "Mathlib.Tactic.Ring.neg_add",
   "Monoid.toMulOneClass",
   "IsCyclotomicExtension",
   "CommRing.toCommSemiring",
   "Int.instCommRing",
   "Mathlib.Tactic.Ring.zero_mul",
   "Eq.ndrec",
   "Mathlib.Tactic.Ring.one_mul",
   "letFun",
   "HSub",
   "Ring.toAddCommGroup",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Mathlib.Tactic.Ring.add_mul",
   "Mathlib.Tactic.Ring.atom_pf",
   "Ideal.mem_span_singleton",
   "PNat",
   "FltRegular.NumberTheory.Cyclotomic.CyclRat._auxLemma.1",
   "MulOneClass.toMul",
   "Int.cast_pow",
   "HAdd.hAdd",
   "dvd_mul_right",
   "AddGroup.toSubtractionMonoid",
   "sub_eq_add_neg",
   "Ideal.span",
   "NonUnitalRingHomClass.toMulHomClass",
   "Int.cast_add",
   "Exists.casesOn",
   "SetLike.instMembership",
   "Int.instAdd",
   "Eq",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Iff.mp",
   "MonoidWithZero.toMonoid",
   "Ring.toIntCast",
   "Int.cast_mul",
   "Nat",
   "Ring.toSubtractionMonoid",
   "And.casesOn",
   "Eq.trans",
   "exists_add_pow_prime_eq",
   "setOf",
   "Int.instHPowNat",
   "Nat.rawCast",
   "Ideal.add_mem",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ideal.Quotient.eq_zero_iff_mem",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "Mathlib.Tactic.Ring.add_congr",
   "RingHom.instFunLike",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Mathlib.Tactic.Ring.neg_mul",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Mathlib.Tactic.Ring.mul_zero",
   "NonAssocRing.toIntCast",
   "Mathlib.Tactic.Ring.of_eq",
   "HEq.refl",
   "of_eq_true",
   "Int.cast",
   "Eq.mp",
   "CommRing.toRing",
   "Ideal.Quotient.mk",
   "Singleton.singleton",
   "sub_eq_zero",
   "congrArg",
   "Fact",
   "Ideal",
   "Int.ofNat",
   "RingHom",
   "Mathlib.Meta.NormNum.IsInt.to_raw_eq",
   "AddGroupWithOne.toIntCast",
   "CommRing.toNonUnitalCommRing",
   "Subalgebra",
   "Fact.out",
   "Mathlib.Tactic.Ring.add_pf_add_lt",
   "CommSemiring.toNonUnitalCommSemiring",
   "SubtractionCommMonoid.toSubtractionMonoid",
   "Membership",
   "Submodule.Quotient.instZeroQuotient",
   "Ring.toNonAssocRing",
   "PNat.val",
   "Zero.toOfNat0",
   "outParam",
   "Set.instSingletonSet",
   "instHPow",
   "Ring.toSub",
   "AddCommGroup.toAddGroup",
   "Algebra.adjoin_induction",
   "CommMonoid.toMonoid",
   "Mathlib.Tactic.Ring.pow_congr",
   "CommSemiring.toCommMonoidWithZero",
   "DFunLike.coe",
   "Eq.symm",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Ideal.Quotient.commRing",
   "Membership.mem",
   "Mathlib.Meta.NormNum.IsInt.of_raw",
   "funext",
   "AddGroupWithOne.toAddMonoidWithOne",
   "instHAdd",
   "AddSemigroup.toAdd",
   "HSub.hSub",
   "AddMonoidWithOne.toAddMonoid",
   "eq_intCast",
   "Mathlib.Tactic.Ring.single_pow",
   "Dvd.dvd",
   "NonUnitalNonAssocSemiring.toMul",
   "Ring.toSemiring",
   "AddGroup.toSubNegMonoid",
   "Ideal.mul_mem_left",
   "Semiring.toOne",
   "Mathlib.Tactic.Ring.add_pf_add_zero",
   "mul_sub",
   "SubtractionMonoid.toSubNegMonoid",
   "Mathlib.Tactic.Ring.instCommSemiringNat",
   "SubNegMonoid.toAddMonoid",
   "NonUnitalSemiring.toSemigroupWithZero",
   "HMul.hMul",
   "Eq.casesOn",
   "Int.instCommSemiring",
   "Algebra.adjoin",
   "NegZeroClass.toZero",
   "HMul",
   "map_sub"],
  "name": "exists_int_sub_pow_prime_dvd",
  "constType":
  "∀ (p : ℕ+) {A : Type u_1} [inst : CommRing A] [inst_1 : IsCyclotomicExtension {p} ℤ A] [hp : Fact (Nat.Prime ↑p)]\n  (a : A), ∃ m, a ^ ↑p - ↑m ∈ Ideal.span {↑↑p}",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "Finset.instHasSubset",
   "Iff",
   "Multiset",
   "Finset",
   "Finset.instSingleton",
   "HasSubset.Subset",
   "Finset.val",
   "Singleton.singleton",
   "Finset.singleton_subset_set_iff",
   "Finset.instMembership",
   "Multiset.instMembership"],
  "name": "Finset.singleton_subset_iff",
  "constType": "∀ {α : Type u_1} {s : Finset α} {a : α}, {a} ⊆ s ↔ a ∈ s",
  "constCategory": "Theorem"},
 {"references":
  ["OreLocalization.OreSet",
   "Module.toDistribMulAction",
   "OreLocalization.instRing.proof_6",
   "MulZeroOneClass.toMulOneClass",
   "SubNegMonoid.toNeg",
   "Semiring.toMonoidWithZero",
   "NonUnitalNonAssocRing.toNonUnitalNonAssocSemiring",
   "NonAssocSemiring.toMulZeroOneClass",
   "OreLocalization.instRing.proof_4",
   "AddGroupWithOne.toAddGroup",
   "Ring.toNonAssocRing",
   "Semiring.toNatCast",
   "SubNegMonoid.toSub",
   "Semiring.toNonAssocSemiring",
   "AddGroup",
   "MonoidWithZero.toMonoid",
   "Int.castDef",
   "OreLocalization.instSemiring",
   "MonoidWithZero.toMulActionWithZero",
   "Ring",
   "MulActionWithZero.toMulAction",
   "Semiring.toModule",
   "Ring.toAddGroupWithOne",
   "OreLocalization.instRing.proof_5",
   "Semiring",
   "NonAssocRing.toNonUnitalNonAssocRing",
   "Ring.toSemiring",
   "OreLocalization.instAddGroupOreLocalization",
   "AddGroup.toSubNegMonoid",
   "OreLocalization.instRing.proof_3",
   "OreLocalization.instRing.proof_1",
   "OreLocalization.instRing.proof_7",
   "IntCast.mk",
   "OreLocalization",
   "SubNegMonoid.zsmul",
   "inferInstanceAs",
   "Submonoid",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "MonoidWithZero.toZero",
   "Ring.mk",
   "OreLocalization.instRing.proof_2"],
  "name": "OreLocalization.instRing",
  "constType":
  "{R : Type u_1} → [inst : Ring R] → {S : Submonoid R} → [inst_1 : OreLocalization.OreSet S] → Ring (OreLocalization S R)",
  "constCategory": "Definition"},
 {"references": ["HPow", "Nat", "Int.pow", "Int", "HPow.mk"],
  "name": "Int.instHPowNat",
  "constType": "HPow ℤ ℕ ℤ",
  "constCategory": "Definition"},
 {"references":
  ["RingHom.instRingHomClass",
   "Semigroup.toMul",
   "Semiring.toNonUnitalSemiring",
   "Distrib.toAdd",
   "NonUnitalCommRing.toNonUnitalNonAssocCommRing",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "PartialOrder.toPreorder",
   "Associated.symm",
   "algebraRat",
   "AddGroupWithOne.toAddGroup",
   "Iff.mpr",
   "MulZeroClass.toMul",
   "Semiring.toNatCast",
   "Nat.instAddCommSemigroup",
   "SubNegMonoid.toSub",
   "mul_pow",
   "pow_mul",
   "mul_assoc",
   "Nat.cast",
   "IsPrimitiveRoot.unit'",
   "Field",
   "map_mul",
   "CommSemiring.toCommMonoid",
   "HDiv.hDiv",
   "eq_pow_prime_of_unit_of_congruent",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Ideal.instHasQuotient",
   "instHSub",
   "HPow.hPow",
   "add_comm",
   "instHDiv",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "instOfNatPNatOfNeZeroNat",
   "Nat.sub_le",
   "MulOneClass.toOne",
   "eq_of_heq",
   "Units.instMonoid",
   "NonUnitalNonAssocCommRing.toNonUnitalNonAssocCommSemiring",
   "NumberField.to_charZero",
   "CommMagma.toMul",
   "AddCommMagma.toAdd",
   "MonoidWithZero.toMulZeroOneClass",
   "And",
   "NumberField.RingOfIntegers.instIsDomain",
   "instCommGroupUnitsRingOfIntegers_fltRegular",
   "propext",
   "dvd_add",
   "NumberField",
   "And.intro",
   "Field.toDivisionRing",
   "Int",
   "AddZeroClass.toAdd",
   "Exists",
   "HEq",
   "NonUnitalCommRing.toNonUnitalCommSemiring",
   "Nat.instStrictOrderedSemiring",
   "Set",
   "PNat.Prime",
   "Semiring.toMonoidWithZero",
   "Eq.refl",
   "Exists.intro",
   "semigroupDvd",
   "AddMonoid.toAddZeroClass",
   "NonAssocSemiring.toMulZeroOneClass",
   "RingHomClass.toNonUnitalRingHomClass",
   "Monoid.toNatPow",
   "HasQuotient.Quotient",
   "Semiring.toModule",
   "DivInvMonoid.toDiv",
   "IsUnit.ne_zero",
   "CommGroup.toGroup",
   "mul_add",
   "Ring.toAddGroupWithOne",
   "LE.le.trans",
   "Field.toSemifield",
   "One.toOfNat1",
   "DivInvMonoid.toMonoid",
   "LE.le",
   "Monoid.toMulOneClass",
   "pow_add",
   "Distrib.leftDistribClass",
   "IsCyclotomicExtension",
   "CommRing.toCommSemiring",
   "Units",
   "Eq.ndrec",
   "letFun",
   "Ring.toAddCommGroup",
   "PNat",
   "Associated",
   "MulOneClass.toMul",
   "Int.cast_pow",
   "MulZeroOneClass.toMulOneClass",
   "IsPrimitiveRoot",
   "HAdd.hAdd",
   "Semifield.toCommSemiring",
   "sub_add_sub_cancel",
   "Ideal.span",
   "Units.val_mul",
   "NonUnitalRingHomClass.toMulHomClass",
   "Exists.casesOn",
   "ClassGroup",
   "Eq",
   "Units.isUnit",
   "Eq.mpr",
   "Fintype",
   "Semiring.toNonAssocSemiring",
   "MonoidWithZero.toMonoid",
   "Nat.mul_le_mul_right",
   "Ring.toIntCast",
   "Associated.dvd",
   "Nat",
   "exists_solution'_aux",
   "And.casesOn",
   "Units.instMul",
   "Ne",
   "Int.instHPowNat",
   "Nat.instSemiring",
   "NumberField.RingOfIntegers.instNontrivial",
   "EuclideanDomain.toCommRing",
   "mul_right_inj'",
   "MulZeroOneClass.toMulZeroClass",
   "RingHom.instFunLike",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "exists_dvd_pow_sub_Int_pow",
   "HEq.refl",
   "Field.toEuclideanDomain",
   "Int.cast",
   "one_le_m",
   "Eq.mp",
   "CommRing.toRing",
   "Not",
   "Singleton.singleton",
   "Ideal.Quotient.mk",
   "CancelMonoidWithZero.toMonoidWithZero",
   "Fact",
   "congrArg",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ideal",
   "DFunLike",
   "RingHom",
   "instSubNat",
   "CommRing.toNonUnitalCommRing",
   "NumberField.RingOfIntegers.instCommRing",
   "MulZeroClass.zero_mul",
   "le_of_eq",
   "Ideal.Quotient.eq_zero_iff_dvd",
   "Submodule.Quotient.instZeroQuotient",
   "mul_div_cancel",
   "mul_comm",
   "PNat.val",
   "Zero.toOfNat0",
   "Nat.sub_add_cancel",
   "outParam",
   "Rat.commRing",
   "Set.instSingletonSet",
   "instLENat",
   "one_mul",
   "NonUnitalNonAssocCommSemiring.toCommMagma",
   "instHPow",
   "Units.instDiv",
   "Ring.toSub",
   "MulZeroClass.toZero",
   "instOfNatNat",
   "Units.val_pow_eq_pow_val",
   "CommMonoid.toMonoid",
   "DFunLike.coe",
   "Eq.symm",
   "associated_zeta_sub_one_pow_prime",
   "id",
   "NeZero.succ",
   "Ideal.Quotient.commRing",
   "instAddNat",
   "instHAdd",
   "IsDomain.toCancelMonoidWithZero",
   "HSub.hSub",
   "Rat",
   "Dvd.dvd",
   "Fintype.card",
   "Ring.toSemiring",
   "exists_solution",
   "AddGroup.toSubNegMonoid",
   "Semiring.toOne",
   "StrictOrderedSemiring.toPartialOrder",
   "Units.val",
   "SubNegMonoid.toAddMonoid",
   "HMul.hMul",
   "Nat.Coprime",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Group.toDivInvMonoid",
   "Eq.casesOn",
   "instMulNat",
   "NumberField.RingOfIntegers"],
  "name": "exists_solution'",
  "constType":
  "∀ {K : Type u_1} {p : ℕ+} [hpri : Fact p.Prime] [inst : Field K] [inst_1 : NumberField K]\n  [inst_2 : IsCyclotomicExtension {p} ℚ K],\n  p ≠ 2 →\n    ∀ [inst_3 : Fintype (ClassGroup (NumberField.RingOfIntegers K))],\n      (↑p).Coprime (Fintype.card (ClassGroup (NumberField.RingOfIntegers K))) →\n        ∀ {ζ : K} (hζ : IsPrimitiveRoot ζ ↑p) {x y z : NumberField.RingOfIntegers K}\n          {ε : (NumberField.RingOfIntegers K)ˣ} {m : ℕ},\n          x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p →\n            ¬↑hζ.unit' - 1 ∣ y →\n              ¬↑hζ.unit' - 1 ∣ z →\n                ∃ x' y' z' ε₃,\n                  ¬↑hζ.unit' - 1 ∣ y' ∧ ¬↑hζ.unit' - 1 ∣ z' ∧ x' ^ ↑p + y' ^ ↑p = ↑ε₃ * ((↑hζ.unit' - 1) ^ m * z') ^ ↑p",
  "constCategory": "Theorem"},
 {"references":
  ["SMul",
   "instHSMul",
   "dite_smul",
   "HSMul.hSMul",
   "Decidable",
   "Not",
   "ite",
   "Eq"],
  "name": "ite_smul",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} [inst : SMul β α] (p : Prop) [inst_1 : Decidable p] (a : α) (b c : β),\n  (if p then b else c) • a = if p then b • a else c • a",
  "constCategory": "Theorem"},
 {"references":
  ["OfNat.ofNat",
   "MulOneClass.toMul",
   "Monoid.toOne",
   "HAdd.hAdd",
   "Semiring.toMonoidWithZero",
   "Eq",
   "PProd",
   "Eq.mpr",
   "MonoidWithZero.toMonoid",
   "instHPow",
   "PUnit",
   "Monoid.toNatPow",
   "instOfNatNat",
   "Nat",
   "Odd",
   "Nat.succ",
   "id",
   "HPow.hPow",
   "Nat.below",
   "Nat.brecOn",
   "odd_one",
   "instAddNat",
   "Semiring",
   "instHAdd",
   "Unit",
   "One.toOfNat1",
   "pow_zero",
   "Monoid.toMulOneClass",
   "instHMul",
   "Nat.rec",
   "PProd.fst",
   "Odd.pow.match_1",
   "HMul.hMul",
   "pow_succ",
   "congrArg",
   "Odd.mul"],
  "name": "Odd.pow",
  "constType":
  "∀ {α : Type u_2} [inst : Semiring α] {a : α}, Odd a → ∀ {n : ℕ}, Odd (a ^ n)",
  "constCategory": "Theorem"},
 {"references":
  ["List.cons",
   "List",
   "List.Mem.tail",
   "List.Mem.head",
   "List.Mem",
   "List.Mem.rec"],
  "name": "List.Mem.casesOn",
  "constType":
  "∀ {α : Type u} {a : α} {motive : (a_1 : List α) → List.Mem a a_1 → Prop} {a_1 : List α} (t : List.Mem a a_1),\n  (∀ (as : List α), motive (a :: as) ⋯) →\n    (∀ (b : α) {as : List α} (a_2 : List.Mem a as), motive (b :: as) ⋯) → motive a_1 t",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "AddCommSemigroup.toAddCommMagma",
   "CommSemiring.toSemiring",
   "CommMonoidWithZero.toZero",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "OfNat.ofNat",
   "HAdd.hAdd",
   "Eq.refl",
   "Nat.cast_zero",
   "Eq",
   "Zero.toOfNat0",
   "Eq.mpr",
   "Semiring.toNonAssocSemiring",
   "Nat.cast",
   "AddMonoidWithOne.toNatCast",
   "CommSemiring",
   "AddMonoid.toZero",
   "instOfNatNat",
   "Nat",
   "CommSemiring.toCommMonoidWithZero",
   "AddCommMonoid.toAddCommSemigroup",
   "id",
   "Mathlib.Meta.NormNum.IsNat.out",
   "instHAdd",
   "AddMonoidWithOne.toAddMonoid",
   "AddCommMagma.toAdd",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "NonUnitalNonAssocSemiring.toDistrib",
   "Eq.ndrec",
   "Mathlib.Meta.NormNum.IsNat",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Mathlib.Tactic.Ring.add_pf_zero_add",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "add_add_add_comm"],
  "name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero",
  "constType":
  "∀ {R : Type u_1} [inst : CommSemiring R] {a₁ a₂ b₁ b₂ c : R},\n  Mathlib.Meta.NormNum.IsNat (a₁ + b₁) 0 → a₂ + b₂ = c → a₁ + a₂ + (b₁ + b₂) = c",
  "constCategory": "Theorem"},
 {"references": ["Ring", "IntCast"],
  "name": "Ring.toIntCast",
  "constType": "{R : Type u} → [self : Ring R] → IntCast R",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Finset.ext_iff",
   "Iff",
   "Finset",
   "Iff.mpr",
   "Finset.instMembership",
   "Eq"],
  "name": "Finset.ext",
  "constType":
  "∀ {α : Type u_1} {s₁ s₂ : Finset α}, (∀ (a : α), a ∈ s₁ ↔ a ∈ s₂) → s₁ = s₂",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.Result.ok",
   "Lean.Syntax.node2",
   "Lean.Macro.Context",
   "Lean.Syntax.isOfKind",
   "Lean.Name.num",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "EStateM.Result",
   "Lean.Syntax",
   "EStateM.Result.error",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Lean.Syntax.node1",
   "Lean.Macro.State",
   "Bool.false",
   "Lean.Macro.Exception",
   "Lean.SourceInfo",
   "Bool",
   "Lean.SourceInfo.fromRef",
   "Lean.Name",
   "Lean.Name.anonymous",
   "Lean.Name.str"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termR_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_8",
   "_obj",
   "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_31",
   "Lean.Name.str._override"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_32._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Semiring", "Nontrivial", "LocalRing"],
  "name": "LocalRing.toNontrivial",
  "constType":
  "∀ {R : Type u_1} [inst : Semiring R] [self : LocalRing R], Nontrivial R",
  "constCategory": "Theorem"},
 {"references": [],
  "name": "AddLeftCancelMonoid",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references": [],
  "name": "optParam",
  "constType": "(α : Sort u) → α → Sort u",
  "constCategory": "Definition"},
 {"references":
  ["Multiset.card",
   "OfNat.ofNat",
   "instHSMul",
   "AddCommMonoid.toAddMonoid",
   "Nat.instAddMonoid",
   "AddMonoid.toAddZeroClass",
   "True",
   "Eq",
   "Zero.toOfNat0",
   "AddMonoid.toZero",
   "HSMul.hSMul",
   "Finset",
   "Multiset",
   "Finset.val",
   "nsmul_zero",
   "Nat",
   "DFunLike.coe",
   "CanonicallyOrderedAddCommMonoid.toOrderedAddCommMonoid",
   "Multiset.instCanonicallyOrderedAddCommMonoid",
   "Eq.trans",
   "Multiset.map_const'",
   "Multiset.sum_replicate",
   "AddCommMonoid",
   "eq_self",
   "Finset.sum",
   "Multiset.sum",
   "Multiset.replicate",
   "AddMonoid.toNatSMul",
   "Multiset.map",
   "of_eq_true",
   "congrArg",
   "AddMonoidHom",
   "AddMonoidHom.instFunLike",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "Finset.sum_const_zero",
  "constType":
  "∀ {α : Type u_3} {β : Type u_4} {s : Finset α} [inst : AddCommMonoid β], ∑ _x ∈ s, 0 = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "Semiring",
   "Set",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Submodule.span",
   "Ideal",
   "Semiring.toModule"],
  "name": "Ideal.span",
  "constType": "{α : Type u} → [inst : Semiring α] → Set α → Ideal α",
  "constCategory": "Definition"},
 {"references":
  ["Lean.ParserDescr.node",
   "Lean.Name.num",
   "Lean.Name.anonymous",
   "Lean.Name",
   "Lean.ParserDescr",
   "Lean.ParserDescr.symbol",
   "Lean.Name.str"],
  "name": "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._cstage1",
  "constType": "Lean.ParserDescr",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "instSubNat",
   "dite",
   "instLTNat",
   "True",
   "Eq",
   "Eq.mpr",
   "Nat.cast",
   "instLENat",
   "Iff.mp",
   "Nat",
   "Int.instSub",
   "instOfNat",
   "Eq.trans",
   "Nat.decLe",
   "id",
   "eq_self",
   "instHSub",
   "Or",
   "Or.inr",
   "HSub.hSub",
   "and_true",
   "LE.le",
   "Init.Core._auxLemma.7",
   "Int.ofNat_sub",
   "And",
   "Or.inl",
   "instNatCastInt",
   "Lean.Omega.Int.ofNat_sub_eq_zero",
   "LT.lt",
   "letFun",
   "Not",
   "And.intro",
   "Nat.not_le",
   "congrArg",
   "Int"],
  "name": "Lean.Omega.Int.ofNat_sub_dichotomy",
  "constType": "∀ {a b : ℕ}, b ≤ a ∧ ↑(a - b) = ↑a - ↑b ∨ a < b ∧ ↑(a - b) = 0",
  "constCategory": "Theorem"},
 {"references":
  ["Lean.MonadRef.withRef",
   "Monad",
   "Lean.replaceRef",
   "Lean.MonadRef",
   "Bind.bind",
   "Lean.MonadRef.getRef",
   "Monad.toBind",
   "Lean.Syntax"],
  "name": "Lean.withRef",
  "constType":
  "{m : Type → Type} → [inst : Monad m] → [inst : Lean.MonadRef m] → {α : Type} → Lean.Syntax → m α → m α",
  "constCategory": "Definition"},
 {"references":
  ["instHSub",
   "OfNat.ofNat",
   "HSub.hSub",
   "instOfNatNat",
   "Nat",
   "Int.instSub",
   "instOfNat",
   "Int",
   "instDecidableEqNat",
   "Eq",
   "ite"],
  "name": "FltRegular.CaseI.f0k₂",
  "constType": "ℤ → ℤ → ℕ → ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Subgroup.instSetLike.proof_1",
   "Subsemigroup.carrier",
   "SetLike",
   "MulOneClass.toMul",
   "SetLike.mk",
   "Submonoid.toSubsemigroup",
   "Subgroup.toSubmonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass"],
  "name": "Subgroup.instSetLike",
  "constType": "{G : Type u_1} → [inst : Group G] → SetLike (Subgroup G) G",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Exists",
   "CommSemiring.toSemiring",
   "Iff.rfl",
   "Set",
   "NonUnitalCommSemiring.toCommSemigroup",
   "Ideal.span",
   "semigroupDvd",
   "CommSemiring.toNonUnitalCommSemiring",
   "SetLike.instMembership",
   "Eq",
   "mul_comm",
   "Set.instSingletonSet",
   "Semiring.toNonAssocSemiring",
   "Eq.mpr",
   "Iff",
   "CommSemiring",
   "Iff.trans",
   "NonUnitalCommSemiring.toNonUnitalSemiring",
   "Semiring.toModule",
   "id",
   "Membership.mem",
   "eq_comm",
   "Dvd.dvd",
   "exists_congr",
   "NonUnitalNonAssocSemiring.toMul",
   "CommMagma.toMul",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Ideal.mem_span_singleton'",
   "CommSemigroup.toCommMagma",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "Singleton.singleton",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "congrArg",
   "Ideal",
   "Submodule.setLike"],
  "name": "Ideal.mem_span_singleton",
  "constType":
  "∀ {α : Type u} [inst : CommSemiring α] {x y : α}, x ∈ Ideal.span {y} ↔ y ∣ x",
  "constCategory": "Theorem"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["DistribLattice.toLattice",
   "And",
   "sup_lt_iff",
   "PartialOrder.toPreorder",
   "Iff",
   "LinearOrder",
   "Lattice.toSemilatticeInf",
   "Preorder.toLT",
   "LT.lt",
   "LinearOrder.toMax",
   "Max.max",
   "SemilatticeInf.toPartialOrder",
   "instDistribLatticeOfLinearOrder"],
  "name": "max_lt_iff",
  "constType":
  "∀ {α : Type u} [inst : LinearOrder α] {a b c : α}, max a b < c ↔ a < c ∧ b < c",
  "constCategory": "Theorem"},
 {"references":
  ["EStateM.dummyRestore",
   "PUnit",
   "EStateM.Backtrackable",
   "EStateM.dummySave",
   "EStateM.Backtrackable.mk"],
  "name": "EStateM.nonBacktrackable",
  "constType": "{σ : Type u} → EStateM.Backtrackable PUnit.{u + 1} σ",
  "constCategory": "Definition"},
 {"references":
  ["LeftCancelMonoid.toMonoid",
   "HPow.hPow",
   "pow_eq_pow_iff_modEq",
   "instHMod",
   "Iff",
   "instHPow",
   "HMod.hMod",
   "Monoid.toNatPow",
   "orderOf",
   "Nat",
   "LeftCancelMonoid",
   "Nat.instMod",
   "Eq"],
  "name": "pow_inj_mod",
  "constType":
  "∀ {G : Type u_1} [inst : LeftCancelMonoid G] {x : G} {n m : ℕ}, x ^ n = x ^ m ↔ n % orderOf x = m % orderOf x",
  "constCategory": "Theorem"},
 {"references":
  ["_obj",
   "Lean.Name.str._override",
   "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_1",
   "FltRegular.termP.«_@».FltRegular.CaseI.AuxLemmas._hyg.14._closed_2"],
  "name":
  "FltRegular.termK.«_@».FltRegular.CaseI.AuxLemmas._hyg.250._closed_2._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": ["Int.ofNat", "NatCast", "Nat", "Int", "NatCast.mk"],
  "name": "instNatCastInt",
  "constType": "NatCast ℤ",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "IsOfFinOrder.mem_powers_iff_mem_zpowers",
   "CancelMonoid.toLeftCancelMonoid",
   "Subgroup.zpowers",
   "Finite",
   "isOfFinOrder_of_finite",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "Group.toCancelMonoid",
   "Submonoid.powers",
   "Iff",
   "Submonoid",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "Submonoid.instSetLike",
   "Subgroup.instSetLike"],
  "name": "mem_powers_iff_mem_zpowers",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] [inst_1 : Finite G] {x y : G}, y ∈ Submonoid.powers x ↔ y ∈ Subgroup.zpowers x",
  "constCategory": "Theorem"},
 {"references": ["Fin.val", "LT.lt", "Nat", "rfl", "instLTNat", "Fin.mk", "Eq"],
  "name": "Fin.val_mk",
  "constType": "∀ {m n : ℕ} (h : m < n), ↑⟨m, h⟩ = m",
  "constCategory": "Theorem"},
 {"references":
  ["Set.Elem",
   "Set",
   "Set.Nat.card_coe_set_eq",
   "Set.ncard",
   "Nat",
   "Nat.card",
   "Eq.symm",
   "Eq"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.16",
  "constType": "∀ {α : Type u_1} (s : Set α), s.ncard = Nat.card ↑s",
  "constCategory": "Theorem"},
 {"references":
  ["AddZeroClass.toAdd",
   "OrderedAddCommMonoid",
   "OrderedAddCommMonoid.add_le_add_left",
   "PartialOrder.toPreorder",
   "instHAdd",
   "HAdd.hAdd",
   "CovariantClass",
   "AddCommMonoid.toAddMonoid",
   "AddMonoid.toAddZeroClass",
   "CovariantClass.mk",
   "LE.le",
   "OrderedAddCommMonoid.toPartialOrder",
   "Preorder.toLE",
   "OrderedAddCommMonoid.toAddCommMonoid"],
  "name": "OrderedAddCommMonoid.toCovariantClassLeft",
  "constType":
  "∀ {α : Type u_1} [inst : OrderedAddCommMonoid α], CovariantClass α α (fun x x_1 => x + x_1) fun x x_1 => x ≤ x_1",
  "constCategory": "Definition"},
 {"references":
  ["eq_self",
   "Int.natAbs_neg",
   "of_eq_true",
   "Int.instNegInt",
   "Neg.neg",
   "Nat.gcd",
   "Nat",
   "congrArg",
   "Eq.trans",
   "Int",
   "True",
   "Int.gcd",
   "Int.natAbs",
   "Eq"],
  "name": "Int.neg_gcd",
  "constType": "∀ {a b : ℤ}, (-a).gcd b = a.gcd b",
  "constCategory": "Theorem"},
 {"references": ["And", "Exists", "propext", "exists_prop", "Eq"],
  "name": "FltRegular.NumberTheory.QuotientTrace._auxLemma.7",
  "constType": "∀ {b a : Prop}, (∃ (_ : a), b) = (a ∧ b)",
  "constCategory": "Theorem"},
 {"references": ["LinearOrderedRing", "LinearOrderedCommRing"],
  "name": "LinearOrderedCommRing.toLinearOrderedRing",
  "constType":
  "{α : Type u} → [self : LinearOrderedCommRing α] → LinearOrderedRing α",
  "constCategory": "Definition"},
 {"references":
  ["MulDivCancelClass",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "Int.instCommRing",
   "Semiring.toMonoidWithZero",
   "MulDivCancelClass.mk",
   "Int.instDiv",
   "Int.mul_ediv_cancel",
   "Int"],
  "name": "Int.instMulDivCancelClass",
  "constType": "MulDivCancelClass ℤ",
  "constCategory": "Definition"},
 {"references": ["propext", "eq_self_iff_true", "True", "Eq"],
  "name": "FltRegular.ReadyForMathlib.Homogenization._auxLemma.4",
  "constType": "∀ {α : Sort u_1} (a : α), (a = a) = True",
  "constCategory": "Theorem"},
 {"references":
  ["Multiset.instOrderBot",
   "Multiset.le_add_right",
   "PartialOrder.toPreorder",
   "Multiset.instOrderedCancelAddCommMonoid",
   "CanonicallyOrderedAddCommMonoid",
   "Multiset",
   "OrderedCancelAddCommMonoid.toOrderedAddCommMonoid",
   "inferInstanceAs",
   "Multiset.instPartialOrder",
   "OrderBot",
   "CanonicallyOrderedAddCommMonoid.mk",
   "Multiset.instCanonicallyOrderedAddCommMonoid.proof_1",
   "Preorder.toLE"],
  "name": "Multiset.instCanonicallyOrderedAddCommMonoid",
  "constType": "{α : Type u_1} → CanonicallyOrderedAddCommMonoid (Multiset α)",
  "constCategory": "Definition"},
 {"references":
  ["CommRing.toCommMonoid",
   "CommRing.toCommSemiring",
   "CommSemiring.toSemiring",
   "FractionRing",
   "OreLocalization.oreSetComm",
   "Semiring.toMonoidWithZero",
   "Algebra.id",
   "IsIntegrallyClosedIn",
   "CommRing",
   "OreLocalization.instAlgebra",
   "nonZeroDivisors",
   "OreLocalization.instCommRing"],
  "name": "IsIntegrallyClosed",
  "constType": "(R : Type u_1) → [inst : CommRing R] → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Group",
  "constType": "Type u → Type u",
  "constCategory": "Other"},
 {"references":
  ["inferInstance",
   "Int.instCommMonoid",
   "CommSemigroup",
   "Int",
   "CommMonoid.toCommSemigroup"],
  "name": "Int.instCommSemigroup",
  "constType": "CommSemigroup ℤ",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "Nat.cast_pos",
   "PartialOrder.toPreorder",
   "Semiring.toMonoidWithZero",
   "instLTNat",
   "Eq",
   "Semiring.toNatCast",
   "OrderedSemiring",
   "Zero.toOfNat0",
   "Nat.cast",
   "propext",
   "Preorder.toLT",
   "LT.lt",
   "OrderedSemiring.toSemiring",
   "instOfNatNat",
   "Nontrivial",
   "Nat",
   "MonoidWithZero.toZero",
   "OrderedSemiring.toPartialOrder"],
  "name": "Mathlib.Data.Nat.Cast.Order.Ring._auxLemma.5",
  "constType":
  "∀ {α : Type u_3} [inst : OrderedSemiring α] [inst_1 : Nontrivial α] {n : ℕ}, (0 < ↑n) = (0 < n)",
  "constCategory": "Theorem"},
 {"references": ["Multiset", "Multiset.ofList", "Nat", "List.range"],
  "name": "Multiset.range",
  "constType": "ℕ → Multiset ℕ",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._closed_43._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Units",
   "Monoid",
   "instHPow",
   "Units.instMonoid",
   "Units.val",
   "Monoid.toNatPow",
   "Units.val_pow_eq_pow_val",
   "Nat",
   "Eq.symm",
   "Eq"],
  "name": "FltRegular.NumberTheory.Hilbert92._auxLemma.14",
  "constType":
  "∀ {α : Type u} [inst : Monoid α] (a : αˣ) (n : ℕ), ↑a ^ n = ↑(a ^ n)",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom.instRingHomClass",
   "RingHom",
   "NonAssocRing",
   "Int.instSemiring",
   "RingHomClass",
   "RingHom.comp",
   "eq_intCast",
   "RingHomClass.toRingHom",
   "RingHom.instFunLike",
   "Eq",
   "NonAssocRing.toIntCast",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "Int.castRingHom",
   "Int.cast",
   "DFunLike.coe",
   "NonAssocRing.toNonAssocSemiring",
   "Int"],
  "name": "map_intCast",
  "constType":
  "∀ {F : Type u_1} {α : Type u_3} {β : Type u_4} [inst : NonAssocRing α] [inst_1 : NonAssocRing β]\n  [inst_2 : FunLike F α β] [inst_3 : RingHomClass F α β] (f : F) (n : ℤ), f ↑n = ↑n",
  "constCategory": "Theorem"},
 {"references":
  ["Membership.mem",
   "OfNat.ofNat",
   "MulOneClass",
   "MulOneClass.toOne",
   "Iff.rfl",
   "One.toOfNat1",
   "MonoidHom",
   "DivInvMonoid.toMonoid",
   "Monoid.toMulOneClass",
   "SetLike.instMembership",
   "MonoidHom.ker",
   "Eq",
   "Iff",
   "Subgroup",
   "Group",
   "Group.toDivInvMonoid",
   "MonoidHom.instFunLike",
   "DFunLike.coe",
   "Subgroup.instSetLike"],
  "name": "MonoidHom.mem_ker",
  "constType":
  "∀ {G : Type u_1} [inst : Group G] {M : Type u_7} [inst_1 : MulOneClass M] (f : G →* M) {x : G}, x ∈ f.ker ↔ f x = 1",
  "constCategory": "Theorem"},
 {"references":
  ["Iff.intro", "Exists", "Iff", "Exists.intro", "forall_exists_index.match_1"],
  "name": "forall_exists_index",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : (∃ x, p x) → Prop}, (∀ (h : ∃ x, p x), q h) ↔ ∀ (x : α) (h : p x), q ⋯",
  "constCategory": "Theorem"},
 {"references":
  ["Semigroup.toMul",
   "instHMul",
   "Exists",
   "Dvd.mk",
   "HMul.hMul",
   "Semigroup",
   "Dvd",
   "Eq"],
  "name": "semigroupDvd",
  "constType": "{α : Type u_1} → [inst : Semigroup α] → Dvd α",
  "constCategory": "Definition"},
 {"references": ["Int.cast", "Ring.toIntCast", "Ring", "Int"],
  "name": "Int.rawCast",
  "constType": "{α : Type u} → [inst : Ring α] → ℤ → α",
  "constCategory": "Definition"},
 {"references":
  ["Mathlib.Data.Finset.Union._auxLemma.14",
   "Membership.mem",
   "Exists",
   "funext",
   "Mathlib.Data.Finset.Union._auxLemma.2",
   "True",
   "iff_self",
   "Multiset.dedup",
   "Finset.instMembership",
   "Multiset.instMembership",
   "And",
   "Iff",
   "Finset.biUnion",
   "DecidableEq",
   "of_eq_true",
   "Finset",
   "Multiset",
   "Finset.val",
   "congr",
   "Mathlib.Data.Finset.Union._auxLemma.1",
   "congrArg",
   "Eq.trans",
   "Multiset.bind"],
  "name": "Finset.mem_biUnion",
  "constType":
  "∀ {α : Type u_1} {β : Type u_2} {s : Finset α} {t : α → Finset β} [inst : DecidableEq β] {b : β},\n  b ∈ s.biUnion t ↔ ∃ a ∈ s, b ∈ t a",
  "constCategory": "Theorem"},
 {"references": ["Classical.not_forall", "Exists", "propext", "Not", "Eq"],
  "name": "FltRegular.NumberTheory.KummersLemma.KummersLemma._auxLemma.8",
  "constType": "∀ {α : Sort u_1} {p : α → Prop}, (¬∀ (x : α), p x) = ∃ x, ¬p x",
  "constCategory": "Theorem"},
 {"references": ["Zero", "CommMonoidWithZero"],
  "name": "CommMonoidWithZero.toZero",
  "constType": "{M₀ : Type u_4} → [self : CommMonoidWithZero M₀] → Zero M₀",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "propext",
   "Finset.toSet",
   "Set",
   "Finset",
   "Set.instMembership",
   "Finset.mem_coe",
   "Eq",
   "Finset.instMembership"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.2",
  "constType": "∀ {α : Type u_1} {a : α} {s : Finset α}, (a ∈ ↑s) = (a ∈ s)",
  "constCategory": "Theorem"},
 {"references":
  ["CommSemiring.toSemiring",
   "Nat.instCommSemiring",
   "Semiring.toNonAssocSemiring",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "CharZero",
   "Nat",
   "AddCommMonoidWithOne.toAddMonoidWithOne",
   "CharZero.mk",
   "Function.injective_id"],
  "name": "Nat.instCharZero",
  "constType": "CharZero ℕ",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "AddGroupWithOne.toAddMonoidWithOne",
   "NonAssocSemiring.toAddCommMonoidWithOne",
   "Ring.toAddGroupWithOne",
   "DivisionRing.toRing",
   "Algebra.toModule",
   "Semifield.toCommSemiring",
   "NumberField.RingOfIntegers.instCommRing",
   "Field.toSemifield",
   "CommRing.toCommSemiring",
   "DivisionSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "CharZero",
   "CharZero.of_module",
   "Field",
   "CommRing.toRing",
   "Semifield.toDivisionSemiring",
   "Algebra.id",
   "Field.toDivisionRing",
   "NumberField.RingOfIntegers",
   "NumberField.RingOfIntegers.instAlgebra_1"],
  "name": "NumberField.RingOfIntegers.instCharZero_1",
  "constType":
  "∀ (K : Type u_1) [inst : Field K] [inst_1 : CharZero K], CharZero (NumberField.RingOfIntegers K)",
  "constCategory": "Definition"},
 {"references": ["outParam", "FunLike", "MulOneClass"],
  "name": "MonoidHomClass",
  "constType":
  "(F : Type u_10) →\n  (M : outParam (Type u_11)) →\n    (N : outParam (Type u_12)) → [inst : MulOneClass M] → [inst : MulOneClass N] → [inst : FunLike F M N] → Prop",
  "constCategory": "Other"},
 {"references":
  ["Submodule",
   "Submodule.Quotient.mk",
   "Submodule.hasQuotient",
   "Ring",
   "AddCommGroup.toAddCommMonoid",
   "HasQuotient.Quotient",
   "Module",
   "AddCommGroup",
   "Ring.toSemiring",
   "Eq"],
  "name": "SModEq",
  "constType":
  "{R : Type u_1} →\n  [inst : Ring R] → {M : Type u_3} → [inst_1 : AddCommGroup M] → [inst_2 : Module R M] → Submodule R M → M → M → Prop",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Lean.Syntax",
  "constType": "Type",
  "constCategory": "Other"},
 {"references":
  ["Lean.SyntaxNodeKind",
   "Lean.SourceInfo",
   "Array.mkArray5",
   "Lean.Syntax",
   "Lean.Syntax.node"],
  "name": "Lean.Syntax.node5",
  "constType":
  "Lean.SourceInfo →\n  Lean.SyntaxNodeKind → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax → Lean.Syntax",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "String.toSubstring'",
   "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_3"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_Statement___macroRules_FltRegular_termK_1._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem",
   "Mathlib.Data.Finset.Basic._auxLemma.139",
   "Mathlib.Data.Finset.Basic._auxLemma.93",
   "instDecidableAnd",
   "True",
   "Eq",
   "Finset.instMembership",
   "iff_self",
   "DecidablePred",
   "And",
   "Iff",
   "of_eq_true",
   "Finset.ext",
   "Finset",
   "Finset.filter",
   "congr",
   "congrArg",
   "Eq.trans"],
  "name": "Finset.filter_filter",
  "constType":
  "∀ {α : Type u_1} (p q : α → Prop) [inst : DecidablePred p] [inst_1 : DecidablePred q] (s : Finset α),\n  Finset.filter q (Finset.filter p s) = Finset.filter (fun a => p a ∧ q a) s",
  "constCategory": "Theorem"},
 {"references": ["Lean.MonadRef", "Lean.MonadQuotation"],
  "name": "Lean.MonadQuotation.toMonadRef",
  "constType":
  "{m : Type → Type} → [self : Lean.MonadQuotation m] → Lean.MonadRef m",
  "constCategory": "Definition"},
 {"references":
  ["HPow.hPow",
   "Units.instInv",
   "Monoid",
   "Monoid.mk",
   "MulOneClass.toMul",
   "Units.instMonoid.proof_4",
   "MulOneClass",
   "MulOneClass.toOne",
   "Units.instMonoid.proof_3",
   "Units.instMonoid.proof_1",
   "Units.instMonoid.proof_6",
   "Units",
   "inferInstance",
   "Units.instMonoid.proof_2",
   "instHPow",
   "Units.val",
   "Monoid.toNatPow",
   "Units.instMonoid.proof_5",
   "Units.instMulOneClass",
   "Nat",
   "Units.mk",
   "Units.instMonoid.proof_7",
   "Semigroup.mk",
   "Inv.inv"],
  "name": "Units.instMonoid",
  "constType": "{α : Type u} → [inst : Monoid α] → Monoid αˣ",
  "constCategory": "Definition"},
 {"references":
  ["Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "root_div_zeta_sub_one_dvd_gcd.proof_1",
   "algebraRat",
   "MulZeroClass.toMul",
   "Finset.instMembership",
   "Eq",
   "exists_ideal_pow_eq_c",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "Nat",
   "Subtype",
   "HPow.hPow",
   "instHSub",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "NumberField.to_charZero",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "NumberField.RingOfIntegers.instIsDomain",
   "Field.toEuclideanDomain",
   "NumberField.inst_ringOfIntegersAlgebra",
   "NumberField",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Algebra.id",
   "Fact",
   "Field.toDivisionRing",
   "Ideal",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "div_zeta_sub_one_dvd_gcd",
   "Submodule.idemSemiring",
   "PNat.Prime",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "semigroupDvd",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instHPow",
   "Finset",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "NeZero.succ",
   "Membership.mem",
   "instAddNat",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Dvd.dvd",
   "Ring.toSemiring",
   "Polynomial.nthRootsFinset",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "Exists.choose",
   "Units.val",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IdemSemiring.toSemiring",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "root_div_zeta_sub_one_dvd_gcd",
  "constType":
  "{K : Type u_1} →\n  {p : ℕ+} →\n    [hpri : Fact p.Prime] →\n      [inst : Field K] →\n        [inst_1 : NumberField K] →\n          [inst_2 : IsCyclotomicExtension {p} ℚ K] →\n            p ≠ 2 →\n              {ζ : K} →\n                (hζ : IsPrimitiveRoot ζ ↑p) →\n                  {x y z : NumberField.RingOfIntegers K} →\n                    {ε : (NumberField.RingOfIntegers K)ˣ} →\n                      {m : ℕ} →\n                        x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p →\n                          ¬↑hζ.unit' - 1 ∣ y →\n                            { x // x ∈ Polynomial.nthRootsFinset (↑p) (NumberField.RingOfIntegers K) } →\n                              Ideal (NumberField.RingOfIntegers K)",
  "constCategory": "Definition"},
 {"references":
  ["OfNat.ofNat",
   "SubmonoidClass.toOneMemClass",
   "Monoid.toOne",
   "Iff.rfl",
   "Subtype.val",
   "IsPrimitiveRoot",
   "Set",
   "Eq.refl",
   "implies_congr",
   "SetLike.instMembership",
   "Eq",
   "Eq.mpr",
   "SetLike",
   "Iff",
   "forall_congr",
   "instHPow",
   "Monoid.toNatPow",
   "Nat.instDvd",
   "CommMonoid.toMonoid",
   "Nat",
   "Subtype",
   "id",
   "Membership.mem",
   "HPow.hPow",
   "OneMemClass.one",
   "SubmonoidClass.toCommMonoid",
   "One.toOfNat1",
   "Dvd.dvd",
   "Mathlib.RingTheory.RootsOfUnity.Basic._auxLemma.13",
   "Set.instMembership",
   "SubmonoidClass",
   "Monoid.toMulOneClass",
   "And",
   "CommMonoid",
   "congr",
   "congrArg",
   "SubmonoidClass.nPow",
   "Mathlib.Algebra.Group.Submonoid.Operations._auxLemma.7",
   "SetLike.coe"],
  "name": "IsPrimitiveRoot.coe_submonoidClass_iff",
  "constType":
  "∀ {k : ℕ} {M : Type u_7} {B : Type u_8} [inst : CommMonoid M] [inst_1 : SetLike B M] [inst_2 : SubmonoidClass B M]\n  {N : B} {ζ : ↥N}, IsPrimitiveRoot (↑ζ) k ↔ IsPrimitiveRoot ζ k",
  "constCategory": "Theorem"},
 {"references":
  ["RingHom",
   "CommSemiring.toSemiring",
   "Semiring.toNonAssocSemiring",
   "IsScalarTower.algebraMap_eq",
   "Semiring",
   "RingHom.comp",
   "algebraMap",
   "CommSemiring",
   "Algebra",
   "Eq.symm",
   "Algebra.toSMul",
   "IsScalarTower",
   "Eq"],
  "name": "FltRegular.NumberTheory.IdealNorm._auxLemma.13",
  "constType":
  "∀ (R : Type u) (S : Type v) (A : Type w) [inst : CommSemiring R] [inst_1 : CommSemiring S] [inst_2 : Semiring A]\n  [inst_3 : Algebra R S] [inst_4 : Algebra S A] [inst_5 : Algebra R A] [inst_6 : IsScalarTower R S A],\n  (algebraMap S A).comp (algebraMap R S) = algebraMap R A",
  "constCategory": "Theorem"},
 {"references": ["LT.lt", "Nat", "instLTNat", "Fin"],
  "name": "Fin.mk",
  "constType": "{n : ℕ} → (val : ℕ) → val < n → Fin n",
  "constCategory": "Other"},
 {"references":
  ["Membership.mem",
   "And",
   "Exists",
   "setOf",
   "Set",
   "Set.instMembership",
   "Eq"],
  "name": "Set.image",
  "constType": "{α : Type u} → {β : Type v} → (α → β) → Set α → Set β",
  "constCategory": "Definition"},
 {"references": ["_obj"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termK_1._closed_3._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references": [],
  "name": "Function.Embedding",
  "constType": "Sort u_1 → Sort u_2 → Sort (max (max 1 u_1) u_2)",
  "constCategory": "Other"},
 {"references":
  ["EStateM.Result.ok",
   "String.toSubstring'",
   "String",
   "Lean.Syntax.Preresolved.decl",
   "Lean.Syntax.Preresolved",
   "EStateM.Result",
   "Lean.addMacroScope",
   "EStateM.Result.error",
   "Lean.Macro.State",
   "Lean.Syntax.node1",
   "Lean.Macro.Exception",
   "Lean.SourceInfo.fromRef",
   "List.nil",
   "Lean.Syntax.ident",
   "Lean.Name.anonymous",
   "Lean.Syntax.node3",
   "Lean.Syntax.isOfKind",
   "Lean.Macro.Context",
   "List.cons",
   "Lean.Name.num",
   "Lean.Name.mkStr4",
   "Lean.Macro",
   "Lean.Syntax.atom",
   "Lean.Syntax.node5",
   "Lean.Syntax",
   "Lean.Macro.Exception.unsupportedSyntax",
   "Lean.MacroScope",
   "Lean.Name.mkStr2",
   "Bool.casesOn",
   "Bool.false",
   "List",
   "Lean.SourceInfo",
   "Bool",
   "Lean.Name",
   "Substring",
   "Lean.Name.str"],
  "name":
  "FltRegular._aux_FltRegular_CaseI_AuxLemmas___macroRules_FltRegular_termP_1._cstage1",
  "constType": "Lean.Macro",
  "constCategory": "Definition"},
 {"references":
  ["Membership.mem", "setOf", "Set", "Finset", "Finset.instMembership"],
  "name": "Finset.toSet",
  "constType": "{α : Type u_1} → Finset α → Set α",
  "constCategory": "Definition"},
 {"references": ["SemilatticeSup", "Sup"],
  "name": "SemilatticeSup.toSup",
  "constType": "{α : Type u} → [self : SemilatticeSup α] → Sup α",
  "constCategory": "Definition"},
 {"references":
  ["Union",
   "Union.mk",
   "Multiset.ndunion",
   "DecidableEq",
   "Finset.instUnion.proof_1",
   "Finset",
   "Finset.val",
   "Finset.mk"],
  "name": "Finset.instUnion",
  "constType": "{α : Type u_1} → [inst : DecidableEq α] → Union (Finset α)",
  "constCategory": "Definition"},
 {"references":
  ["Exists", "Subtype.exists", "propext", "Subtype.mk", "Subtype", "Eq"],
  "name": "FltRegular.NumberTheory.QuotientTrace._auxLemma.6",
  "constType":
  "∀ {α : Sort u_1} {p : α → Prop} {q : { a // p a } → Prop}, (∃ x, q x) = ∃ a, ∃ (b : p a), q ⟨a, b⟩",
  "constCategory": "Theorem"},
 {"references":
  ["Ideal.map",
   "PartialOrder.toPreorder",
   "Semiring",
   "RingHomClass",
   "CompleteLattice.instOmegaCompletePartialOrder",
   "OmegaCompletePartialOrder.toPartialOrder",
   "Submodule.completeLattice",
   "Ideal.comap",
   "LE.le",
   "Preorder.toLE",
   "Eq",
   "Semiring.toNonAssocSemiring",
   "FunLike",
   "Ideal.map_le_iff_le_comap",
   "propext",
   "NonAssocSemiring.toNonUnitalNonAssocSemiring",
   "NonUnitalNonAssocSemiring.toAddCommMonoid",
   "Ideal",
   "Semiring.toModule"],
  "name": "FltRegular.NumberTheory.GaloisPrime._auxLemma.4",
  "constType":
  "∀ {R : Type u} {S : Type v} {F : Type u_1} [inst : Semiring R] [inst_1 : Semiring S] [inst_2 : FunLike F R S]\n  [rc : RingHomClass F R S] {f : F} {I : Ideal R} {K : Ideal S}, (Ideal.map f I ≤ K) = (I ≤ Ideal.comap f K)",
  "constCategory": "Theorem"},
 {"references":
  ["Decidable.casesOn", "Bool.false", "Bool.true", "Decidable", "Not", "Bool"],
  "name": "Decidable.decide",
  "constType": "(p : Prop) → [h : Decidable p] → Bool",
  "constCategory": "Definition"},
 {"references":
  ["Subalgebra.instSetLike.proof_1",
   "Subsemigroup.carrier",
   "SetLike",
   "Semiring.toNonAssocSemiring",
   "MulOneClass.toMul",
   "SetLike.mk",
   "MulZeroOneClass.toMulOneClass",
   "Submonoid.toSubsemigroup",
   "Semiring",
   "CommSemiring",
   "Algebra",
   "Subalgebra",
   "Subsemiring.toSubmonoid",
   "NonAssocSemiring.toMulZeroOneClass",
   "Subalgebra.toSubsemiring"],
  "name": "Subalgebra.instSetLike",
  "constType":
  "{R : Type u} →\n  {A : Type v} → [inst : CommSemiring R] → [inst_1 : Semiring A] → [inst_2 : Algebra R A] → SetLike (Subalgebra R A) A",
  "constCategory": "Definition"},
 {"references":
  ["_obj",
   "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_3",
   "Lean.Name.str._override",
   "FltRegular.termP.«_@».FltRegular.CaseI.Statement._hyg.15._closed_1"],
  "name":
  "FltRegular.termR.«_@».FltRegular.CaseI.Statement._hyg.727._closed_4._cstage2",
  "constType": "_obj",
  "constCategory": "Definition"},
 {"references":
  ["Semigroup.toMul",
   "Distrib.toAdd",
   "Semiring.toNonUnitalSemiring",
   "CommSemiring.toSemiring",
   "OfNat.ofNat",
   "IsPrimitiveRoot",
   "Semifield.toCommSemiring",
   "HAdd.hAdd",
   "Ideal.span",
   "algebraRat",
   "MulZeroClass.toMul",
   "Eq",
   "MonoidWithZero.toMonoid",
   "Field",
   "IsPrimitiveRoot.unit'",
   "CommSemiring.toCommMonoid",
   "Nat",
   "HPow.hPow",
   "instHSub",
   "Ne",
   "instOfNatPNatOfNeZeroNat",
   "NonUnitalNonAssocSemiring.toMulZeroClass",
   "root_div_zeta_sub_one_dvd_gcd",
   "a_eta_zero_dvd_p_pow.proof_1",
   "NumberField.to_charZero",
   "EuclideanDomain.toCommRing",
   "NonUnitalNonAssocSemiring.toDistrib",
   "SemigroupWithZero.toSemigroup",
   "instHMul",
   "Field.toEuclideanDomain",
   "NumberField.inst_ringOfIntegersAlgebra",
   "NumberField",
   "CommRing.toRing",
   "Singleton.singleton",
   "Not",
   "Algebra.id",
   "Fact",
   "Field.toDivisionRing",
   "NonUnitalSemiring.toNonUnitalNonAssocSemiring",
   "Ideal",
   "Submodule.idemSemiring",
   "PNat.Prime",
   "Set",
   "NumberField.RingOfIntegers.instCommRing",
   "Semiring.toMonoidWithZero",
   "semigroupDvd",
   "PNat.val",
   "Set.instSingletonSet",
   "Rat.commRing",
   "instHPow",
   "Ring.toSub",
   "Monoid.toNatPow",
   "instOfNatNat",
   "zeta_sub_one_dvd_root",
   "p_pow_dvd_a_eta_zero",
   "NeZero.succ",
   "instAddNat",
   "instHAdd",
   "Rat",
   "HSub.hSub",
   "Field.toSemifield",
   "One.toOfNat1",
   "Dvd.dvd",
   "Ring.toSemiring",
   "IsCyclotomicExtension",
   "Semiring.toOne",
   "Units",
   "CommRing.toCommSemiring",
   "Units.val",
   "Exists.choose",
   "HMul.hMul",
   "NonUnitalSemiring.toSemigroupWithZero",
   "IdemSemiring.toSemiring",
   "NumberField.RingOfIntegers",
   "PNat"],
  "name": "a_eta_zero_dvd_p_pow",
  "constType":
  "{K : Type u_1} →\n  {p : ℕ+} →\n    [hpri : Fact p.Prime] →\n      [inst : Field K] →\n        [inst_1 : NumberField K] →\n          [inst_2 : IsCyclotomicExtension {p} ℚ K] →\n            p ≠ 2 →\n              {ζ : K} →\n                (hζ : IsPrimitiveRoot ζ ↑p) →\n                  {x y z : NumberField.RingOfIntegers K} →\n                    {ε : (NumberField.RingOfIntegers K)ˣ} →\n                      {m : ℕ} →\n                        x ^ ↑p + y ^ ↑p = ↑ε * ((↑hζ.unit' - 1) ^ (m + 1) * z) ^ ↑p →\n                          ¬↑hζ.unit' - 1 ∣ y → Ideal (NumberField.RingOfIntegers K)",
  "constCategory": "Definition"},
 {"references": ["SubNegMonoid", "Neg"],
  "name": "SubNegMonoid.toNeg",
  "constType": "{G : Type u} → [self : SubNegMonoid G] → Neg G",
  "constCategory": "Definition"},
 {"references": ["SProd", "SProd.mk", "Finset", "Finset.product", "Prod"],
  "name": "Finset.instSProd",
  "constType":
  "{α : Type u_1} → {β : Type u_2} → SProd (Finset α) (Finset β) (Finset (α × β))",
  "constCategory": "Definition"},
 {"references":
  ["CommSemiring.toSemiring",
   "Units",
   "Units.instOne",
   "OfNat.ofNat",
   "Unique.mk",
   "MonoidWithZero.toMonoid",
   "Submodule.idemSemiring",
   "CommSemiring",
   "Semiring.toMonoidWithZero",
   "Ideal.uniqueUnits.proof_1",
   "One.toOfNat1",
   "IdemSemiring.toSemiring",
   "Algebra.id",
   "Inhabited.mk",
   "Ideal",
   "Unique"],
  "name": "Ideal.uniqueUnits",
  "constType": "{R : Type u} → [inst : CommSemiring R] → Unique (Ideal R)ˣ",
  "constCategory": "Definition"},
 {"references": ["String", "Lean.Name", "Lean.Name.anonymous", "Lean.Name.str"],
  "name": "Lean.Name.mkStr3",
  "constType": "String → String → String → Lean.Name",
  "constCategory": "Definition"},
 {"references": ["CancelCommMonoidWithZero"],
  "name": "GCDMonoid",
  "constType":
  "(α : Type u_2) → [inst : CancelCommMonoidWithZero α] → Type u_2",
  "constCategory": "Other"},
 {"references":
  ["LE.mk",
   "Part.Dom",
   "Exists",
   "instLENat",
   "Part.get",
   "LE",
   "PartENat",
   "Nat",
   "LE.le"],
  "name": "PartENat.instLE",
  "constType": "LE PartENat",
  "constCategory": "Definition"}]