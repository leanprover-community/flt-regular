import may_assume.lemmas
import number_theory.cyclotomic.factoring
import number_theory.cyclotomic.Unit_lemmas
import ready_for_mathlib.exists_eq_pow_of_mul_eq_pow

open finset nat is_cyclotomic_extension ideal polynomial int

open_locale big_operators number_field

namespace flt_regular

variables {p : ‚Ñï} (hpri : p.prime)

local notation `P` := (‚ü®p, hpri.pos‚ü© : ‚Ñï+)
local notation `K` := cyclotomic_field P ‚Ñö
local notation `R` := ùìû K

namespace caseI

/-- Statement of case I with additional assumptions. -/
def slightly_easier : Prop := ‚àÄ ‚¶Éa b c : ‚Ñ§‚¶Ñ ‚¶Ép : ‚Ñï‚¶Ñ (hpri : p.prime)
  (hreg : is_regular_number p hpri.pos) (hp5 : 5 ‚â§ p) (hprod : a * b * c ‚â† 0)
  (hgcd : is_unit (({a, b, c} : finset ‚Ñ§).gcd id))
  (hab : ¬¨a ‚â° b [ZMOD p]) (caseI : ¬¨ ‚Üëp ‚à£ a * b * c), a ^ p + b ^ p ‚â† c ^ p

/-- Statement of case I. -/
def statement : Prop := ‚àÄ ‚¶Éa b c : ‚Ñ§‚¶Ñ ‚¶Ép : ‚Ñï‚¶Ñ (hpri : p.prime) (hreg : is_regular_number p hpri.pos)
  (hodd : p ‚â† 2) (hprod : a * b * c ‚â† 0) (caseI : ¬¨ ‚Üëp ‚à£ a * b * c), a ^ p + b ^ p ‚â† c ^ p

lemma may_assume : slightly_easier ‚Üí statement :=
begin
  intro Heasy,
  intros a b c p hpri hreg hodd hprod hI H,
  have hp5 : 5 ‚â§ p,
  { by_contra' habs,
    have : p ‚àà finset.Ioo 2 5 := finset.mem_Icc.2 ‚ü®nat.lt_of_le_and_ne hpri.two_le hodd.symm,
      by linarith‚ü©,
    fin_cases this,
    { exact may_assume.p_ne_three hprod H rfl },
    { rw [show 4 = 2 * 2, from rfl] at hpri,
      refine nat.not_prime_mul one_lt_two one_lt_two hpri } },
  rcases may_assume.coprime H hprod with ‚ü®Hxyz, hunit, hprodxyx‚ü©,
  let d := ({a, b, c} : finset ‚Ñ§).gcd id,
  have hdiv : ¬¨‚Üëp ‚à£ (a / d) * (b / d) * (c / d),
  { have hadiv : d ‚à£ a := gcd_dvd (by simp),
    have hbdiv : d ‚à£ b := gcd_dvd (by simp),
    have hcdiv : d ‚à£ c := gcd_dvd (by simp),
    intro hdiv,
    replace hdiv := dvd_mul_of_dvd_right hdiv ((d * d) * d),
    rw [mul_assoc, ‚Üê mul_assoc d, ‚Üê mul_assoc d, int.mul_div_cancel' hadiv, mul_assoc,
      mul_comm a, mul_assoc (b / d), ‚Üê mul_assoc _ (b / d), int.mul_div_cancel' hbdiv,
      mul_comm, mul_assoc, mul_assoc, int.div_mul_cancel hcdiv, mul_comm, mul_assoc,
      mul_comm c, ‚Üê mul_assoc] at hdiv,
    exact hI hdiv },
  obtain ‚ü®X, Y, Z, H1, H2, H3, H4, H5‚ü© := a_not_cong_b hpri hp5 hprodxyx Hxyz hunit hdiv,
  exact Heasy hpri hreg hp5 H4 H2 H3 (Œª hfin, H5 hfin) H1
end

end caseI

lemma ab_coprime {a b c : ‚Ñ§} (H : a ^ p + b ^ p = c ^ p) (hpzero : p ‚â† 0)
  (hgcd : is_unit (({a, b, c} : finset ‚Ñ§).gcd id)) : is_coprime a b  :=
begin
  rw [‚Üê gcd_eq_one_iff_coprime],
  by_contra' h,
  obtain ‚ü®q, hqpri, hq‚ü© := exists_prime_and_dvd h,
  replace hqpri : prime (q : ‚Ñ§) := prime_iff_nat_abs_prime.2 (by simp [hqpri]),
  obtain ‚ü®n, hn‚ü© := hq,
  have haq : ‚Üëq ‚à£ a,
  { obtain ‚ü®m, hm‚ü© := int.gcd_dvd_left a b,
    exact ‚ü®n * m, by { rw [hm, hn], simp [mul_assoc] }‚ü© },
  have hbq : ‚Üëq ‚à£ b,
  { obtain ‚ü®m, hm‚ü© := int.gcd_dvd_right a b,
    exact ‚ü®n * m, by { rw [hm, hn], simp [mul_assoc] }‚ü© },
  have hcq : ‚Üëq ‚à£ c,
  { suffices : ‚Üëq ‚à£ c ^ p,
    { exact hqpri.dvd_of_dvd_pow this },
    rw [‚Üê H],
    exact dvd_add (dvd_pow haq hpzero) (dvd_pow hbq hpzero) },
  have Hq : ‚Üëq ‚à£ ({a, b, c} : finset ‚Ñ§).gcd id,
  { refine dvd_gcd (Œª x hx, _),
    simp only [mem_insert, mem_singleton] at hx,
    rcases hx with H | H | H;
    simpa [H] },
  exact not_is_unit_of_not_is_unit_dvd hqpri.not_unit Hq hgcd
end

theorem exist_ideal {a b c : ‚Ñ§} (h5p : 5 ‚â§ p)
  (H : a ^ p + b ^ p = c ^ p)
  (hgcd : is_unit (({a, b, c} : finset ‚Ñ§).gcd id))
  (caseI : ¬¨ ‚Üëp ‚à£ a * b * c) :
  ‚àÄ i ‚àà nth_roots_finset p R, ‚àÉ I, span ({a + i * b} : set R) = I ^ p :=
begin
  have h5P : 5 ‚â§ P := h5p,
  haveI : fact ((P : ‚Ñï).prime) := ‚ü®hpri‚ü©,
  classical,
  have H‚ÇÅ := congr_arg (algebra_map ‚Ñ§ R) H,
  simp only [eq_int_cast, int.cast_add, int.cast_pow] at H‚ÇÅ,
  have hŒ∂ := is_primitive_root.unit'_coe (zeta_spec P ‚Ñö K),
  rw [pow_add_pow_eq_prod_add_zeta_runity_mul (or.resolve_left (prime.eq_two_or_odd hpri)
    (Œª _, by linarith)) hŒ∂] at H‚ÇÅ,
  replace H‚ÇÅ := congr_arg (Œª x, span ({x} : set R)) H‚ÇÅ,
  simp only [span_singleton_prod, ‚Üê span_singleton_pow] at H‚ÇÅ,
  intros i hi,
  obtain ‚ü®I, hI‚ü© := exists_eq_pow_of_prod_eq_pow p (span ({c} : set R)) (Œª Œ∑‚ÇÅ hŒ∑‚ÇÅ Œ∑‚ÇÇ hŒ∑‚ÇÇ hŒ∑, _) H‚ÇÅ i hi,
  { exact ‚ü®I, hI‚ü© },
  { exact flt_ideals_coprime h5P H (ab_coprime H hpri.ne_zero hgcd) hŒ∑‚ÇÅ hŒ∑‚ÇÇ hŒ∑ caseI }
end

/-- Case I with additional assumptions. -/
theorem caseI_easier {a b c : ‚Ñ§} {p : ‚Ñï} (hpri : p.prime)
  (hreg : is_regular_number p hpri.pos) (hp5 : 5 ‚â§ p) (hprod : a * b * c ‚â† 0)
  (hgcd : is_unit (({a, b, c} : finset ‚Ñ§).gcd id))
  (hab : ¬¨a ‚â° b [ZMOD p]) (caseI : ¬¨ ‚Üëp ‚à£ a * b * c) : a ^ p + b ^ p ‚â† c ^ p :=
begin
  sorry
end

/-- CaseI. -/
theorem caseI {a b c : ‚Ñ§} {p : ‚Ñï} (hpri : p.prime) (hreg : is_regular_number p hpri.pos)
  (hodd : p ‚â† 2) (hprod : a * b * c ‚â† 0) (caseI : ¬¨ ‚Üëp ‚à£ a * b * c) : a ^ p + b ^ p ‚â† c ^ p :=
flt_regular.caseI.may_assume (Œª x y z p‚ÇÅ Hpri Hreg HP5 Hprod Hunit Hxy HI,
    caseI_easier Hpri Hreg HP5 Hprod Hunit Hxy HI) hpri hreg hodd hprod caseI

end flt_regular
