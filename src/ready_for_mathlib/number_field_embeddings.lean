-- PR #14749
import ring_theory.roots_of_unity
import number_theory.number_field
import field_theory.splitting_field
-- import generalisation_linter
import field_theory.is_alg_closed.basic
import field_theory.polynomial_galois_group
import field_theory.adjoin
import algebra.char_p.algebra

open set finite_dimensional complex
open_locale classical
open_locale big_operators
open_locale complex_conjugate

namespace embeddings

noncomputable theory

variables {K L : Type*} [field K] [field L]
section number_field
variables [number_field K] [number_field L]  {n : ℕ} (x : K)

-- TODO generalize to other targets
/-- The equivalence between algebra maps from a number field to the complexes and plain
ring morphisms between them. -/

def equiv_alg : (K →ₐ[ℚ] ℂ) ≃ (K →+* ℂ) :=
{ to_fun := coe,
  inv_fun := λ f : K →+* ℂ, alg_hom.mk' f (λ (c : ℚ) x, map_rat_smul f _ _),
  left_inv  := λ x, alg_hom.ext  $ by simp only [forall_const, alg_hom.coe_to_ring_hom,
                                                 eq_self_iff_true, alg_hom.coe_mk'],
  right_inv := λ x, ring_hom.ext $ by simp only [forall_const, alg_hom.coe_to_ring_hom,
                                                 eq_self_iff_true, alg_hom.coe_mk'] }

-- There are finitely many complex embeddings of a number field
instance : fintype (K →+* ℂ) := fintype.of_equiv (K →ₐ[ℚ] ℂ) equiv_alg

lemma card_embeddings : fintype.card (K →+* ℂ) = finrank ℚ K :=
by rw [fintype.of_equiv_card equiv_alg, alg_hom.card]

open polynomial

/-- Any embeddings of a number field `K` can be extended to an embedding of an extension `L`. -/
lemma lift {L : Type*} [field L] [number_field L] [algebra K L] (φ : K →+* ℂ) :
  ∃ ψ : L →+* ℂ, φ = ψ.comp (algebra_map K L) :=
begin
  letI : algebra K ℂ, from ring_hom.to_algebra φ,
  letI : is_alg_closed ℂ, from complex.is_alg_closed,
  have hS : algebra.is_algebraic K L,
  { show ∀ (a : L), is_algebraic K a,
    intro a,
    obtain ⟨p, hp⟩ := (number_field.is_algebraic L) a,
    haveI : algebra ℚ K, { exact algebra_rat },
    use (map (algebra_map ℚ K) p),
    split,
    simp only [ne.def, map_eq_zero, not_false_iff, hp.left],
    simp only [aeval_map, map_zero, hp.right]
  },
  let ψ₀ : L →ₐ[K] ℂ := is_alg_closed.lift hS,
  let ψ := ψ₀.to_ring_hom,
  use ψ,
  refine fun_like.ext φ (ψ.comp (algebra_map K L)) _,
  intro x,
  show φ x = ψ₀ ((algebra_map K L) x),
  rw alg_hom.commutes ψ₀ x,
  exact rfl,
end

namespace adjoin_root

section

open_locale polynomial

local attribute [-instance] algebra_rat

/-- The quotient of `ℚ[X]` by the ideal generated by an irreducible polynomial of `ℚ[X]`
is a number field. -/
instance {f : ℚ[X]} [hf : irreducible f] : number_field (adjoin_root f) :=
{ to_char_zero := char_zero_of_injective_algebra_map (algebra_map ℚ _).injective,
  to_finite_dimensional := begin
   let := (adjoin_root.power_basis (irreducible.ne_zero hf : f ≠ 0)),
   convert power_basis.finite_dimensional this,
   haveI : subsingleton (algebra ℚ (adjoin_root f)) := algebra_rat_subsingleton,
   exact subsingleton.elim _ _,
  end }

end

end adjoin_root

/-- For `x ∈ K`, with `K` a number field, the images of `x` by the embeddings of `K` are exactly
the roots of the minimal polynomial of `x` over `ℚ` -/
lemma eq_roots : range (λ φ : K →+* ℂ, φ x) = (minpoly ℚ x).root_set ℂ :=
begin
  have hx : is_integral ℚ x, { exact is_separable.is_integral ℚ x },
  ext a,
  split,
  { rintro ⟨φ, hφ⟩,
    rw [mem_root_set_iff, ←hφ],
    let ψ := ring_hom.to_rat_alg_hom φ,
    show (aeval (ψ x)) (minpoly ℚ x) = 0,
    { rw aeval_alg_hom_apply ψ x (minpoly ℚ x),
      simp only [minpoly.aeval, map_zero] },
    exact minpoly.ne_zero hx, },
  { intro ha,
    let Qx := adjoin_root (minpoly ℚ x),
    haveI : irreducible (minpoly ℚ x), { exact minpoly.irreducible hx },
    haveI : number_field Qx := by apply_instance,
    have hK : (aeval x) (minpoly ℚ x) = 0, { exact minpoly.aeval _ _, },
    have hC : (aeval a) (minpoly ℚ x) = 0,
    { rw [aeval_def, ←eval_map, ←mem_root_set_iff'],
      exact ha,
      suffices : (minpoly ℚ x) ≠ 0,
      { contrapose! this,
        simp only [polynomial.ext_iff, coeff_map, coeff_zero] at this ⊢,
        suffices inj : function.injective (algebra_map ℚ ℂ),
        { exact λ n : ℕ, inj (by rw [(this n), (algebra_map ℚ ℂ).map_zero]),},
        exact (algebra_map ℚ ℂ).injective, },
      exact minpoly.ne_zero hx, },
    let ψ : Qx →+* ℂ := adjoin_root.lift (algebra_map ℚ ℂ) a hC,
    letI : algebra Qx K,
      { exact ring_hom.to_algebra (adjoin_root.lift (algebra_map ℚ K) x hK), },
    obtain ⟨φ, hφ⟩ := lift ψ,
    use φ,
    rw (_ : x = (algebra_map Qx K) (adjoin_root.root (minpoly ℚ x))),
    rw (_ : a = ψ (adjoin_root.root (minpoly ℚ x))),
    simp only [congr_fun, hφ, ring_hom.coe_comp],
    exact (adjoin_root.lift_root hC).symm,
    exact (adjoin_root.lift_root hK).symm,
    apply_instance, },
end

end number_field

variables (φ : K →* ℂ)

/-- An embedding is real if its fixed by complex conjugation-/
def is_real (φ : K →+* ℂ) : Prop := conj ∘ φ = φ

/-- An embedding is real if its not fixed by complex conjugation-/
def is_complex (φ : K →+* ℂ) : Prop := conj ∘ φ ≠ φ

/-- Two embeddings are conjuate if `conj` takes one to the other-/
def are_conj (φ θ : K →+* ℂ) : Prop := conj ∘ φ = θ

/--An element of a number field is real if its image under any embedding is fixed by conj-/
def element_is_real (x : K) : Prop := ∀ φ : K →+* ℂ, conj (φ x) = φ x

local notation `r1` := fintype.card { φ  : K →+* ℂ // is_real φ }

local notation `c2` := fintype.card { φ  : K →+* ℂ // is_complex φ }

lemma not_real_eq_complex (φ : K →+* ℂ) : is_real φ ↔ ¬ is_complex φ :=
begin
  rw [is_real, is_complex],
  simp only [not_not],
end

lemma real_eq_rank_sub_complex [number_field K] :
  r1 = finrank ℚ K  - c2 :=
begin
  rw ← card_embeddings,
  simp_rw not_real_eq_complex,
  exact fintype.card_subtype_compl _,
end

lemma elem_is_real_is_real (x : K) (h : element_is_real x) :
   ∀  φ : K →+* ℂ, ∃ (r : ℝ), φ x = (r : ℂ) :=
begin
  intro φ,
  simp_rw [element_is_real] at h,
  have h1 := h φ,
  rw eq_conj_iff_real at h1,
  exact h1,
end

/-- A number field all of whose embeddings are real -/
def in_totally_real {K : Type*} [field K] : Prop := ∀ φ : K →+* ℂ, is_real φ

/-- A number field all of whose embeddings are complex -/
def in_totally_complex {K : Type*} [field K] : Prop := ∀ φ : K →+* ℂ, is_complex φ

end embeddings
