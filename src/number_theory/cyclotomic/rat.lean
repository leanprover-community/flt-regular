import number_theory.cyclotomic.basic
import number_theory.cyclotomic.cyclotomic_units
import number_theory.cyclotomic.number_field_embeddings
import number_theory.cyclotomic.absolute_value
import number_theory.cyclotomic.galois_action_on_cyclo

universes u

open finite_dimensional

variables (L : Type u) [field L] [char_zero L]

namespace rat

section singleton

variables (n : ℕ+) [is_cyclotomic_extension {n} ℚ L]

lemma degree : finrank ℚ L = (n : ℕ).totient := sorry

end singleton

end rat

namespace int

section singleton

variables (n : ℕ+)

instance : is_integral_closure (cyclotomic_ring n ℤ ℚ) ℤ (cyclotomic_field n ℚ) := sorry

end singleton

end int

section int_facts

variables (p : ℕ+)



local notation `KK` := cyclotomic_field p ℚ

local notation `RR` := number_field.ring_of_integers (cyclotomic_field p ℚ)

--A.K.A theorem:FLT_facts 3
lemma flt_fact_3 [fact (p : ℕ).prime] (a : RR) :
  ∃ (n : ℤ), (a^(p : ℕ) - n) ∈ ideal.span ({p} : set RR) := sorry

/-- The principal ideal generated by `x + y ζ^i` for integer `x` and `y` -/
noncomputable def flt_ideals (x y : ℤ) (i  : ℕ) : ideal RR :=
  ideal.span ({ x+y*(cyclotomic_ring.zeta p ℚ)^i} : set RR)

lemma flt_fact_2 [fact (p : ℕ).prime] (ph: 5 ≤ p) (x y : ℤ) (i j : ℕ) (h : i ≠ j)
  (hp : is_coprime x y) : (flt_ideals p x y i) + (flt_ideals p x y i) = ⊤ := sorry

open cyclotomic_ring embeddings

noncomputable theory
open is_cyclotomic_extension

local notation `ζ` := zeta' p ℚ KK

/-- `is_gal_conj_real x` means that `x` is real. -/
def is_gal_conj_real (x : KK) : Prop := gal_conj p x = x

--do more generally
lemma roots_of_unity_in_cyclo (x  : KK) (h : ∃ (n : ℕ+), x^(n: ℕ) =1 ) :
  ∃ (m k: ℕ+), x = (-1)^(k : ℕ) * ζ^(m : ℕ) :=
begin
sorry,
end

/-
lemma unit_lemma_gal_conj (u : units RR) :
  ∃ (x : units RR) (n : ℤ), (is_gal_conj_real p (x : KK)) ∧ (u : KK) = x * (zeta p ℚ) ^ n :=

begin
 have := mem_roots_of_unity_of_abs_eq_one (u * (unit_gal_conj p u)⁻¹ : KK) _ _,
  { have : ∃ m : ℕ, u * (unit_gal_conj p u)⁻¹ = (zeta p ℚ) ^ (2 * m),
    sorry, --follows from above with some work
          -- what we have shows its +- a power of zeta
    obtain ⟨m, hm⟩ := this,
    use [u * (zeta p ℚ)⁻¹ ^ (m), m],
    split,
    { rw is_gal_conj_real,
    have hy : u * ((zeta p ℚ)⁻¹)  ^ ( m) = (unit_gal_conj p u) *  (zeta p ℚ) ^ ( m), by {sorry,},
    dsimp,
    simp only [inv_pow, alg_hom.map_mul],
    have hz: gal_conj p ((zeta p ℚ)  ^ ( m))⁻¹ =(zeta p ℚ)  ^ ( m) , by {sorry,},
    rw ← coe_coe,
    rw ← coe_coe,



    sorry,

    },
    dsimp at *,
    simp only [exists_prop, inv_pow, zpow_coe_nat] at *,
    norm_cast,
    simp only [inv_mul_cancel_right] at *,
  },
  exact unit_lemma_val_one p u,
   { apply is_integral_mul,
    exact number_field.ring_of_integers.is_integral_coe (coe_b u),
    rw (_ : ((unit_gal_conj p u)⁻¹ : KK) = (↑(unit_gal_conj p u⁻¹))),
    exact number_field.ring_of_integers.is_integral_coe (coe_b _),
    simp,
    sorry,
     },
end

lemma unit_lemma (u : units RR) :
  ∃ (x : units RR) (n : ℤ), element_is_real (x : KK) ∧ (u : KK) = x * (zeta p ℚ) ^ n :=
begin
  have := mem_roots_of_unity_of_abs_eq_one (u * (unit_gal_conj p u)⁻¹ : KK) _ _,
  { have : ∃ m : ℕ, u * (unit_gal_conj p u)⁻¹ = (zeta p ℚ) ^ (2 * m),
    sorry, --follows from above with some work
          -- what we have shows its +- a power of zeta
    obtain ⟨m, hm⟩ := this,
    use [u * (zeta p ℚ)⁻¹ ^ m, m],
    split,
    { rw element_is_real,
      intro φ,
      have := congr_arg (conj ∘ φ ∘ coe) hm,
      simp at this,
      simp [alg_hom.map_inv],
      rw ← coe_coe,
      rw ← coe_coe, -- TODO this is annoying
      rw (_ : (↑(zeta p ℚ ^ m)⁻¹ : KK) = (zeta p ℚ ^ m : KK)⁻¹),
      rw alg_hom.map_inv,
      rw ring_hom.map_inv,
      rw mul_inv_eq_iff_eq_mul₀,
      simp,
      sorry, -- wow we should really have some more structure and simp lemmas to tame this beast
      sorry, -- similar silly goal to below
      sorry,
       },
    { simp only [mul_assoc, inv_pow, subalgebra.coe_mul, coe_coe, units.coe_mul, zpow_coe_nat],
      norm_cast,
      simp, }, },
  { exact unit_lemma_val_one p u, },
  { apply is_integral_mul,
    exact number_field.ring_of_integers.is_integral_coe (coe_b u),
    rw (_ : ((unit_gal_conj p u)⁻¹ : KK) = (↑(unit_gal_conj p u⁻¹))),
    exact number_field.ring_of_integers.is_integral_coe (coe_b _),
    simp,
    sorry, -- tis a silly goal
     },
end
-/


end int_facts
