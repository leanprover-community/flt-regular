import number_theory.cyclotomic.galois_action_on_cyclo

universes u

open finite_dimensional

variables (n : ℕ+) (L : Type u) [field L] [char_zero L]

namespace is_cyclotomic_extension

namespace rat

namespace singleton

variables [is_cyclotomic_extension {n} ℚ L]

lemma finrank : finrank ℚ L = (n : ℕ).totient := sorry

end singleton

end rat

namespace int

namespace singleton

instance : is_integral_closure (cyclotomic_ring n ℤ ℚ) ℤ (cyclotomic_field n ℚ) := sorry

end singleton

end int

end is_cyclotomic_extension

section int_facts

noncomputable theory

local notation `KK` := cyclotomic_field n ℚ

local notation `RR` := number_field.ring_of_integers (cyclotomic_field n ℚ)

--A.K.A theorem:FLT_facts 3
lemma flt_fact_3 [fact (n : ℕ).prime] (a : RR) :
  ∃ (m : ℤ), (a ^ (n : ℕ) - m) ∈ ideal.span ({n} : set RR) := sorry

open ideal is_cyclotomic_extension

-- TODO refactor add_pow_char_of_commute to use this instead of its own (basically the same) proof
-- TODO is the fact assumption necessary what if p is a prime power?
-- TODO other versions, e.g. one for sub and one for p^n with the
theorem add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute {R : Type*} [semiring R] (p : ℕ)
  [fact p.prime] (x y : R) (h : commute x y) : ∃ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
begin
  have : p = p - 1 + 1 := (nat.succ_pred_prime (fact.out _)).symm,
  rw [commute.add_pow h, finset.sum_range_succ_comm, tsub_self, pow_zero, nat.choose_self,
    nat.cast_one, mul_one, mul_one, this, finset.sum_range_succ'],
  simp only [this.symm, tsub_zero, mul_one, one_mul, nat.choose_zero_right, nat.cast_one, pow_zero],
  rw add_comm _ (y ^ p),
  simp_rw add_assoc,
  use (finset.range (p - 1)).sum
    (λ (x_1 : ℕ), x ^ (x_1 + 1) * y ^ (p - (x_1 + 1)) * ↑(p.choose (x_1 + 1) / p)),
  rw finset.mul_sum,
  congr' 2,
  apply finset.sum_congr rfl,
  intros i hi,
  rw [finset.mem_range] at hi,
  rw [nat.cast_comm, mul_assoc, mul_assoc, mul_assoc],
  congr,
  norm_cast,
  rw nat.div_mul_cancel,
  exact nat.prime.dvd_choose_self (nat.succ_pos _) (lt_tsub_iff_right.mp hi) (fact.out _),
end

theorem add_pow_prime_eq_pow_add_pow_add_prime_mul {R : Type*} [comm_semiring R] (p : ℕ)
  [fact p.prime] (x y : R) : ∃ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute _ _ _ (commute.all _ _)

-- TODO can we make a relative version of this with another base ring instead of ℤ ?
-- A version of flt_facts_3 indep of the ring
lemma exists_int_sub_pow_prime_dvd {A : Type*} [comm_ring A] [is_cyclotomic_extension {n} ℤ A]
  [fact (n : ℕ).prime] (a : A) : ∃ (m : ℤ), (a ^ (n : ℕ) - m) ∈ span ({n} : set A) :=
begin
  have : a ∈ algebra.adjoin ℤ _ := @adjoint_roots {n} ℤ A _ _ _ _ a,
  apply algebra.adjoin_induction this,
  { intros x hx,
    rcases hx with ⟨hx_w, hx_m, hx_p⟩,
    simp only [set.mem_singleton_iff] at hx_m,
    rw [hx_m] at hx_p,
    simp only [hx_p, coe_coe],
    use 1,
    simp, },
  { intros r,
    use r ^ (n : ℕ),
    simp, },
  { rintros x y ⟨hx_m, hx_p⟩ ⟨hy_m, hy_p⟩,
    obtain ⟨r, hr⟩ := add_pow_prime_eq_pow_add_pow_add_prime_mul n x y,
    rw [hr],
    existsi hx_m + hy_m,
    push_cast,
    rw sub_add_eq_sub_sub, -- horrible calculation time
    rw sub_eq_add_neg,
    rw sub_eq_add_neg,
    rw add_comm _ (↑↑n * r),
    rw add_assoc,
    rw add_assoc,
    apply' ideal.add_mem _ _,
    sorry, -- TODO this is just a silly computation should be easy from here.
    rw mem_span_singleton, -- TODO probably a lemma
    sorry, -- hopefully easy?
   },
  { rintros x y ⟨hx_m, hx_p⟩ ⟨hy_m, hy_p⟩,
    rw mul_pow,
    simp,
    use hx_m * hy_m,
    sorry, -- TODO also shouldn't be too hard a calculation
  },
end

-- TODO I (alex) am not sure whether this is better as ideal span,
-- or fractional_ideal.span_singleton
/-- The principal ideal generated by `x + y ζ^i` for integer `x` and `y` -/
def flt_ideals (x y : ℤ) (i : ℕ) : ideal RR :=
  ideal.span ({ x+y*(cyclotomic_ring.zeta n ℚ)^i} : set RR)

lemma flt_fact_2 [fact (n : ℕ).prime] (ph : 5 ≤ n) (x y : ℤ) {i j : ℕ} (h : i ≠ j)
  (hp : is_coprime x y) : flt_ideals n x y i + flt_ideals n x y i = ⊤ := sorry

end int_facts
