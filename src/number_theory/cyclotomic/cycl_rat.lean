import ring_theory.polynomial.eisenstein
import number_theory.cyclotomic.galois_action_on_cyclo
import number_theory.cyclotomic.rat

import ready_for_mathlib.basis

universes u

open finite_dimensional polynomial algebra nat

variables (p : ‚Ñï+) (L : Type u) [field L] [char_zero L] [is_cyclotomic_extension {p} ‚Ñö L]

namespace is_cyclotomic_extension

end is_cyclotomic_extension

section int_facts

noncomputable theory

open_locale number_field big_operators

--A.K.A theorem:FLT_facts 3
-- Eric: is this superseded by `exists_int_sub_pow_prime_dvd`?
lemma flt_fact_3 [fact (p : ‚Ñï).prime] (a : ùìû L) :
  ‚àÉ (m : ‚Ñ§), (a ^ (p : ‚Ñï) - m) ‚àà ideal.span ({p} : set (ùìû L)) := by admit

open ideal is_cyclotomic_extension

-- TODO refactor add_pow_char_of_commute to use this instead of its own (basically the same) proof
-- TODO is the fact assumption necessary what if p is a prime power?
-- TODO other versions, e.g. one for sub and one for p^n with the
theorem add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute {R : Type*} [semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) (h : commute x y) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
begin
  have : p = p - 1 + 1 := (nat.succ_pred_prime (fact.out _)).symm,
  rw [commute.add_pow h, finset.sum_range_succ_comm, tsub_self, pow_zero, nat.choose_self,
    nat.cast_one, mul_one, mul_one, this, finset.sum_range_succ'],
  simp only [this.symm, tsub_zero, mul_one, one_mul, nat.choose_zero_right, nat.cast_one, pow_zero],
  rw add_comm _ (y ^ p),
  simp_rw add_assoc,
  use (finset.range (p - 1)).sum
    (Œª (x_1 : ‚Ñï), x ^ (x_1 + 1) * y ^ (p - (x_1 + 1)) * ‚Üë(p.choose (x_1 + 1) / p)),
  rw finset.mul_sum,
  congr' 2,
  apply finset.sum_congr rfl,
  intros i hi,
  rw [finset.mem_range] at hi,
  rw [nat.cast_comm, mul_assoc, mul_assoc, mul_assoc],
  congr,
  norm_cast,
  rw nat.div_mul_cancel,
  exact nat.prime.dvd_choose_self (nat.succ_pos _) (lt_tsub_iff_right.mp hi) (fact.out _),
end

theorem add_pow_prime_eq_pow_add_pow_add_prime_mul {R : Type*} [comm_semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute _ _ _ (commute.all _ _)

-- TODO can we make a relative version of this with another base ring instead of ‚Ñ§ ?
-- A version of flt_facts_3 indep of the ring
lemma exists_int_sub_pow_prime_dvd {A : Type*} [comm_ring A] [is_cyclotomic_extension {p} ‚Ñ§ A]
  [fact (p : ‚Ñï).prime] (a : A) : ‚àÉ (m : ‚Ñ§), (a ^ (p : ‚Ñï) - m) ‚àà span ({p} : set A) :=
begin
  have : a ‚àà algebra.adjoin ‚Ñ§ _ := @adjoin_roots {p} ‚Ñ§ A _ _ _ _ a,
  apply algebra.adjoin_induction this,
  { intros x hx,
    rcases hx with ‚ü®hx_w, hx_m, hx_p‚ü©,
    simp only [set.mem_singleton_iff] at hx_m,
    rw [hx_m] at hx_p,
    simp only [hx_p, coe_coe],
    use 1,
    simp, },
  { intros r,
    use r ^ (p : ‚Ñï),
    simp, },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    obtain ‚ü®r, hr‚ü© := add_pow_prime_eq_pow_add_pow_add_prime_mul p x y,
    rw [hr],
    use c + b,
    push_cast,
    rw [sub_add_eq_sub_sub, sub_eq_add_neg, sub_eq_add_neg, add_comm _ (‚Üë‚Üëp * r),
        add_assoc, add_assoc],
    apply' ideal.add_mem _ _,
    { convert ideal.add_mem _ hb hc using 1,
      ring },
    { rw [mem_span_singleton, coe_coe],
      exact dvd_mul_right _ _ } },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    rw mul_pow,
    use b * c,
    have := ideal.mul_mem_left _ (x ^ (p : ‚Ñï)) hc,
    rw [mul_sub] at this,
    rw [‚Üêideal.quotient.eq_zero_iff_mem, map_sub] at this ‚ä¢ hb,
    convert this using 2,
    rw [int.cast_mul, _root_.map_mul, _root_.map_mul],
    congr' 1,
    exact (sub_eq_zero.mp hb).symm }
end

-- Eric: I thought Riccardo's new work meant we had this?
instance aaaa : is_cyclotomic_extension {p} ‚Ñ§ (ùìû L) := sorry

local notation `KK` := cyclotomic_field p ‚Ñö

local notation `RR` := ùìû KK

local attribute [instance] algebra_rat_subsingleton

--This is still annoying
instance : is_cyclotomic_extension {p} ‚Ñ§ ‚Ü•(ùìû (cyclotomic_field p ‚Ñö)) :=
@aaaa p (cyclotomic_field p ‚Ñö) _ _
  (by { convert cyclotomic_field.is_cyclotomic_extension p ‚Ñö, exact subsingleton.elim _ _ })

-- TODO I (alex) am not sure whether this is better as ideal span,
-- or fractional_ideal.span_singleton
/-- The principal ideal generated by `x + y Œ∂^i` for integer `x` and `y` -/
def flt_ideals (x y i : ‚Ñ§) : ideal RR :=
  ideal.span ({ x + y * ((zeta_runity p ‚Ñ§ RR) ^ i : RRÀ£) } : set RR)

variable {p} -- why does this not update (n : ‚Ñï+)?

lemma mem_flt_ideals {x y i : ‚Ñ§} :
  (x : RR) + y * ((zeta_runity p ‚Ñ§ RR) ^ i : RRÀ£) ‚àà flt_ideals p x y i :=
mem_span_singleton.mpr dvd_rfl

section to_move

variables {R : Type*} [semiring R] {s t : ideal R}

lemma ideal.add_left_subset  : s ‚â§ s + t := le_sup_left
lemma ideal.add_right_subset : t ‚â§ s + t := le_sup_right

variables {K : Type*} [semiring K]

lemma add_eq_mul_one_add_div {a : KÀ£} {b : K} : ‚Üëa + b = a * (1 + ‚Üëa‚Åª¬π * b) :=
by rwa [mul_add, mul_one, ‚Üê mul_assoc, units.mul_inv, one_mul]

end to_move

lemma flt_ideals_coprime [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {x y : ‚Ñ§} {i j : ‚Ñ§} (h : i ‚â† j)
  (hp : is_coprime x y) : flt_ideals p x y i + flt_ideals p x y j = ‚ä§ :=
begin
  let I := flt_ideals p x y i + flt_ideals p x y j,
  have : ‚àÉ v : RRÀ£, (v : RR) * y * (1 - (zeta_runity p ‚Ñ§ RR)) ‚àà I,
  { have := I.add_mem (ideal.add_left_subset $ mem_flt_ideals p)
                      (ideal.mul_mem_left _ (-1) $ ideal.add_right_subset $ mem_flt_ideals p),
    simp only [neg_mul, one_mul, neg_add_rev] at this,
    rw [neg_mul_eq_mul_neg, add_comm] at this,
    simp only [‚Üê add_assoc] at this,
    rw [add_assoc _ (-_) _, neg_add_self, add_zero, ‚Üêmul_add, add_comm, add_eq_mul_one_add_div,
        ‚Üêzpow_neg] at this,
    sorry
    -- I cannot get the tactic state to work here :/
  }, sorry,
end

lemma dvd_last_coeff_cycl_integer [hp : fact (p : ‚Ñï).prime] {Œ∂ :ùìû L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ùìû L} {i : fin p} (hf : f i = 0) {m : ‚Ñï} (hx : ‚Üëm ‚à£ ‚àë i, f i * Œ∂ ^ (i : ‚Ñï)) :
  ‚Üëm ‚à£ f ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := sorry

lemma dvd_coeff_cycl_integer [fact (p : ‚Ñï).prime] {Œ∂ :ùìû L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ùìû L} {i : fin p} (hf : f i = 0) {m : ‚Ñï} (hx : ‚Üëm ‚à£ ‚àë i, f i * Œ∂ ^ (i : ‚Ñï)) :
  ‚àÄ j, ‚Üëm ‚à£ f j := sorry

end int_facts
