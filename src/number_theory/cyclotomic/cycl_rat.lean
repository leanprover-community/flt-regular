import ring_theory.polynomial.eisenstein
import number_theory.cyclotomic.galois_action_on_cyclo
import number_theory.cyclotomic.rat
import number_theory.cyclotomic.Unit_lemmas
import ready_for_mathlib.basis
import ring_theory.dedekind_domain.ideal
import number_theory.cyclotomic.zeta_sub_one_prime
import number_theory.cyclotomic.cyclotomic_units

universes u

open finite_dimensional polynomial algebra nat finset fintype

variables (p : ‚Ñï+) (L : Type u) [field L] [char_zero L] [is_cyclotomic_extension {p} ‚Ñö L]

section int_facts

noncomputable theory

open_locale number_field big_operators

section to_move

variables {R : Type*} [semiring R] {s t : ideal R}

lemma ideal.add_left_subset  : s ‚â§ s + t := le_sup_left
lemma ideal.add_right_subset : t ‚â§ s + t := le_sup_right

variables {K : Type*} [semiring K]

lemma add_eq_mul_one_add_div {a : KÀ£} {b : K} : ‚Üëa + b = a * (1 + ‚Üëa‚Åª¬π * b) :=
by rwa [mul_add, mul_one, ‚Üê mul_assoc, units.mul_inv, one_mul]

end to_move

open ideal is_cyclotomic_extension

-- TODO refactor add_pow_char_of_commute to use this instead of its own (basically the same) proof
-- TODO is the fact assumption necessary what if p is a prime power?
-- TODO other versions, e.g. one for sub and one for p^n with the
theorem add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute {R : Type*} [semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) (h : commute x y) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
begin
  have : p = p - 1 + 1 := (nat.succ_pred_prime (fact.out _)).symm,
  rw [commute.add_pow h, finset.sum_range_succ_comm, tsub_self, pow_zero, nat.choose_self,
    nat.cast_one, mul_one, mul_one, this, finset.sum_range_succ'],
  simp only [this.symm, tsub_zero, mul_one, one_mul, nat.choose_zero_right, nat.cast_one, pow_zero],
  rw add_comm _ (y ^ p),
  simp_rw add_assoc,
  use (finset.range (p - 1)).sum
    (Œª (x_1 : ‚Ñï), x ^ (x_1 + 1) * y ^ (p - (x_1 + 1)) * ‚Üë(p.choose (x_1 + 1) / p)),
  rw finset.mul_sum,
  congr' 2,
  apply finset.sum_congr rfl,
  intros i hi,
  rw [finset.mem_range] at hi,
  rw [nat.cast_comm, mul_assoc, mul_assoc, mul_assoc],
  congr,
  norm_cast,
  rw nat.div_mul_cancel,
  exact nat.prime.dvd_choose_self (nat.succ_pos _) (lt_tsub_iff_right.mp hi) (fact.out _),
end

theorem add_pow_prime_eq_pow_add_pow_add_prime_mul {R : Type*} [comm_semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute _ _ _ (commute.all _ _)

-- TODO can we make a relative version of this with another base ring instead of ‚Ñ§ ?
-- A version of flt_facts_3 indep of the ring
lemma exists_int_sub_pow_prime_dvd {A : Type*} [comm_ring A] [is_cyclotomic_extension {p} ‚Ñ§ A]
  [fact (p : ‚Ñï).prime] (a : A) : ‚àÉ (m : ‚Ñ§), (a ^ (p : ‚Ñï) - m) ‚àà span ({p} : set A) :=
begin
  have : a ‚àà algebra.adjoin ‚Ñ§ _ := @adjoin_roots {p} ‚Ñ§ A _ _ _ _ a,
  apply algebra.adjoin_induction this,
  { intros x hx,
    rcases hx with ‚ü®hx_w, hx_m, hx_p‚ü©,
    simp only [set.mem_singleton_iff] at hx_m,
    rw [hx_m] at hx_p,
    simp only [hx_p, coe_coe],
    use 1,
    simp, },
  { intros r,
    use r ^ (p : ‚Ñï),
    simp, },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    obtain ‚ü®r, hr‚ü© := add_pow_prime_eq_pow_add_pow_add_prime_mul p x y,
    rw [hr],
    use c + b,
    push_cast,
    rw [sub_add_eq_sub_sub, sub_eq_add_neg, sub_eq_add_neg, add_comm _ (‚Üë‚Üëp * r),
        add_assoc, add_assoc],
    apply' ideal.add_mem _ _,
    { convert ideal.add_mem _ hb hc using 1,
      ring },
    { rw [mem_span_singleton, coe_coe],
      exact dvd_mul_right _ _ } },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    rw mul_pow,
    use b * c,
    have := ideal.mul_mem_left _ (x ^ (p : ‚Ñï)) hc,
    rw [mul_sub] at this,
    rw [‚Üêideal.quotient.eq_zero_iff_mem, map_sub] at this ‚ä¢ hb,
    convert this using 2,
    rw [int.cast_mul, _root_.map_mul, _root_.map_mul],
    congr' 1,
    exact (sub_eq_zero.mp hb).symm }
end

instance aaaa [fact ((p : ‚Ñï).prime)] : is_cyclotomic_extension {p} ‚Ñ§ (ùìû L) :=
let _ := (zeta_spec p ‚Ñö L).adjoin_is_cyclotomic_extension ‚Ñ§ in
 by exactI is_cyclotomic_extension.equiv {p} _ _ (zeta_spec p ‚Ñö L).adjoin_equiv_ring_of_integers'

local notation `R` := ùìû (cyclotomic_field p ‚Ñö)

local attribute [instance] algebra_rat_subsingleton

--This is still annoying
instance [hp : fact ((p : ‚Ñï).prime)] : is_cyclotomic_extension {p} ‚Ñ§ ‚Ü•(ùìû (cyclotomic_field p ‚Ñö)) :=
@aaaa p (cyclotomic_field p ‚Ñö) _ _
  (by { convert cyclotomic_field.is_cyclotomic_extension p ‚Ñö, exact subsingleton.elim _ _ }) _

-- TODO I (alex) am not sure whether this is better as ideal span,
-- or fractional_ideal.span_singleton
/-- The principal ideal generated by `x + y Œ∂^i` for integer `x` and `y` -/
@[nolint unused_arguments]
def flt_ideals [fact ((p : ‚Ñï).prime)] (x y : ‚Ñ§) {Œ∑ : R}
  (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R) : ideal R :=
  ideal.span ({ x + Œ∑ * y } : set R)

variable {p} -- why does this not update (n : ‚Ñï+)?

lemma mem_flt_ideals [fact ((p : ‚Ñï).prime)] (x y : ‚Ñ§) {Œ∑ : R}
  (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R) :
  ‚Üëx + Œ∑ * ‚Üëy ‚àà flt_ideals p x y hŒ∑ :=
mem_span_singleton.mpr dvd_rfl

lemma ideal.le_add (a b c d : ideal R) (hab : a ‚â§ b) (hcd : c ‚â§ d) : a + c ‚â§ b + d :=
begin
  simp at *,
  split,
  apply le_trans hab (@le_sup_left _ _ _ _ ),
  apply le_trans hcd (@le_sup_right _ _ _ _ ),
end

lemma not_coprime_not_top (a b : ideal R) : ¬¨ is_coprime a b ‚Üî a + b ‚â† ‚ä§ :=
begin
  apply not_iff_not_of_iff,
  rw is_coprime,
  split,
  intro h,
  obtain ‚ü®x, y , hxy ‚ü© := h,
  rw eq_top_iff_one,
  have h2 : x * a + y * b ‚â§ a + b, by {apply ideal.le_add, all_goals {apply mul_le_left},  },
  apply h2,
  rw hxy,
  simp,
  intro h,
  refine ‚ü®1,1,_‚ü©,
  simp [h],
end

instance a1 : is_galois ‚Ñö (cyclotomic_field p ‚Ñö) := is_galois p _ _

instance a2 :  finite_dimensional ‚Ñö (cyclotomic_field p ‚Ñö) := finite_dimensional {p} _ _

instance a3 : number_field (cyclotomic_field p ‚Ñö) := number_field {p} ‚Ñö _

open is_primitive_root

lemma nth_roots_prim [fact (p : ‚Ñï).prime] {Œ∑ : R} (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R)
  (hne1 : Œ∑ ‚â† 1) : is_primitive_root Œ∑ p :=
begin
  have hŒ∂' := (zeta_spec p ‚Ñö ((cyclotomic_field p ‚Ñö))).unit'_coe,
    rw (nth_roots_one_eq_bUnion_primitive_roots' hŒ∂') at hŒ∑,
    simp at *,
    obtain ‚ü®a, ha, h2‚ü© := hŒ∑,
    have ha2 : a = p, by {rw (dvd_prime _inst_4.out) at ha,
    cases ha,
    exfalso,
    rw ha at h2,
    simp at h2,
    rw h2 at hne1,
    simp at *,
    exact hne1,
    exact ha,},
    rw ha2 at h2,
    have hn :  0 <(p : ‚Ñï), by {norm_num,},
    rw (mem_primitive_roots hn) at h2,
    exact h2,
end

lemma prim_coe (Œ∂ : R) (hŒ∂ : is_primitive_root Œ∂ p) :
  is_primitive_root (Œ∂ : (cyclotomic_field p ‚Ñö))  p :=
coe_submonoid_class_iff.mpr hŒ∂

lemma zeta_sub_one_dvb_p [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {Œ∑ : R} (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R)
  (hne1 : Œ∑ ‚â† 1): (1 - Œ∑) ‚à£ (p : R) :=
begin
  have h00 : (1 - Œ∑) ‚à£ (p : R) ‚Üî (Œ∑ - 1) ‚à£ (p : R), by {have hh : -(Œ∑ - 1) = (1 - Œ∑), by {ring},
  simp_rw [‚Üêhh],
  apply neg_dvd},
  rw h00,
  have : is_primitive_root (Œ∑ : (cyclotomic_field p ‚Ñö))  p, by {
    apply prim_coe p Œ∑ (nth_roots_prim hŒ∑ hne1)},
  have h0 : p ‚â† 2, by   { intro hP,
    norm_num [hP] at ph },
  have h := dvd_norm ‚Ñö ((Œ∑ - 1) : R),
  have h2 := is_primitive_root.sub_one_norm_prime this (cyclotomic.irreducible_rat p.2) h0,
  convert h,
  ext,
  rw algebra_map_norm',
  norm_cast at h2,
  rw h2,
  simp,
end

local attribute [-instance] cyclotomic_field.algebra
local notation `K` := cyclotomic_field p ‚Ñö
local notation `R` := ùìû K

lemma one_sub_zeta_prime [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {Œ∑ : R} (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R)
  (hne1 : Œ∑ ‚â† 1) : prime (1 - Œ∑) :=
begin
  replace ph : p ‚â† 2,
  { intro h,
    rw [h] at ph,
    simpa using ph },
  haveI diamond : is_cyclotomic_extension {p} ‚Ñö K,
  { convert cyclotomic_field.is_cyclotomic_extension p ‚Ñö,
    exact subsingleton.elim _ _ },
  have h := (prim_coe p Œ∑ (nth_roots_prim hŒ∑ hne1)),
  have := rat.zeta_sub_one_prime' h ph,
  have H : ((‚ü®Œ∑ - 1, subalgebra.sub_mem _ (h.is_integral p.pos) (subalgebra.one_mem _)‚ü© : R)) =
    Œ∑ -1 := rfl,
  rw [H] at this,
  convert this.neg,
  ring,
end

lemma diff_of_roots [hp : fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R} (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R)
  (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ) (hwlog : Œ∑‚ÇÅ ‚â† 1) :
  ‚àÉ (u : RÀ£), (Œ∑‚ÇÅ - Œ∑‚ÇÇ) = u * (1 - Œ∑‚ÇÅ)  :=
begin
  replace ph : 2 ‚â§ p := le_trans (by norm_num) ph,
  have h := nth_roots_prim hŒ∑‚ÇÅ hwlog,
  obtain ‚ü®i, ‚ü®H, hi‚ü©‚ü© := h.eq_pow_of_pow_eq_one ((mem_nth_roots_finset hp.out.pos).1 hŒ∑‚ÇÇ) hp.out.pos,
  have hi1 : 1 ‚â† i,
  { intro hi1,
    rw [‚Üê hi1, pow_one] at hi,
    exact hdiff hi },
  obtain ‚ü®u, hu‚ü© := cyclotomic_unit.is_primitive_root.zeta_pow_sub_eq_unit_zeta_sub_one
    R ph hp.out hp.out.one_lt H hi1 h,
  refine ‚ü®u, _‚ü©,
  rw [‚Üê hu, hi, pow_one],
end

lemma diff_of_roots2  [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R} (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R)
  (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ) (hwlog : Œ∑‚ÇÅ ‚â† 1) :
  ‚àÉ (u : RÀ£), (Œ∑‚ÇÇ - Œ∑‚ÇÅ) = u * (1 - Œ∑‚ÇÅ)  :=
begin
  obtain ‚ü®u, hu‚ü© := diff_of_roots ph hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hwlog,
  refine ‚ü®-u, _‚ü©,
  rw [units.coe_neg, neg_mul, ‚Üê hu],
  ring
end

instance arg : is_dedekind_domain R := infer_instance

lemma flt_ideals_coprime2 [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {x y : ‚Ñ§} {Œ∑‚ÇÅ Œ∑‚ÇÇ : R}
  (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R) (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ)
  (hp : is_coprime x y) (hp2 : ¬¨ (p : ‚Ñ§) ‚à£ (x + y : ‚Ñ§) ) (hwlog : Œ∑‚ÇÅ ‚â† 1) :
  is_coprime (flt_ideals p x y hŒ∑‚ÇÅ) (flt_ideals p x y hŒ∑‚ÇÇ) :=
begin
  let I := flt_ideals p x y hŒ∑‚ÇÅ + flt_ideals p x y hŒ∑‚ÇÇ,
  by_contra,
  have he := (not_coprime_not_top p (flt_ideals p x y hŒ∑‚ÇÅ)  (flt_ideals p x y hŒ∑‚ÇÇ)).1 h,
  have := exists_le_maximal I he,
  obtain ‚ü®P, hP1, hP2‚ü©:= this,
  have hiP : (flt_ideals p x y hŒ∑‚ÇÅ) ‚â§ P, by {apply le_trans _ hP2, apply ideal.add_left_subset,},
  have hjP : (flt_ideals p x y hŒ∑‚ÇÇ) ‚â§ P, by {apply le_trans _ hP2, apply ideal.add_right_subset,},
  have hel1: ‚àÉ v : RÀ£, (v : R) * y * (1 - Œ∑‚ÇÅ) ‚àà I, by {
  have := I.add_mem (ideal.add_left_subset $ (mem_flt_ideals _ _ hŒ∑‚ÇÅ))
                      (ideal.mul_mem_left _ (-1) $ ideal.add_right_subset $ (mem_flt_ideals _ _ _) ),
    simp only [neg_mul, one_mul, neg_add_rev] at this,
    rw [neg_mul_eq_mul_neg, add_comm] at this,
    simp only [‚Üê add_assoc] at this,
    simp at this,
    have hh := diff_of_roots ph hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hwlog,
    obtain ‚ü®v, hv‚ü© := hh,
    refine ‚ü®v, _‚ü©,
    have  h3 : -(Œ∑‚ÇÇ * ‚Üëy) + Œ∑‚ÇÅ * ‚Üëy = (Œ∑‚ÇÅ - Œ∑‚ÇÇ) * y, by {ring},
    rw h3 at this,
    rw hv at this,
    have h4 :  ‚Üëv * (1 - Œ∑‚ÇÅ) * ‚Üëy = v * y * (1-Œ∑‚ÇÅ) , by {ring},
    rw ‚Üêh4,
    apply this},
  have hel2 : ‚àÉ v : RÀ£, (v : R) * x * (1 - Œ∑‚ÇÅ) ‚àà I, by {
    have := I.add_mem (ideal.mul_mem_left _ (Œ∑‚ÇÇ) $ ideal.add_left_subset $ (mem_flt_ideals _ _ hŒ∑‚ÇÅ))
                      (ideal.mul_mem_left _ (-Œ∑‚ÇÅ) $ ideal.add_right_subset $ (mem_flt_ideals _ _ _)),
    have h1 :  Œ∑‚ÇÇ * (‚Üëx + Œ∑‚ÇÅ * ‚Üëy) + -Œ∑‚ÇÅ * (‚Üëx + Œ∑‚ÇÇ * ‚Üëy) = (Œ∑‚ÇÇ - Œ∑‚ÇÅ) * x, by {ring},
    rw h1 at this,
    have hh := diff_of_roots2 ph hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hwlog,
    obtain ‚ü®v, hv‚ü© := hh,
    refine ‚ü®v, _‚ü©,
    rw hv at this,
    have h4 :  ‚Üëv * (1 - Œ∑‚ÇÅ) * ‚Üëx = v * x * (1-Œ∑‚ÇÅ) , by {ring},
    rw h4 at this,
    exact this},
  have hel11:  (y : R) * (1 - Œ∑‚ÇÅ) ‚àà P, by {
    obtain ‚ü®v, hv ‚ü©:= hel1,
    rw mul_assoc at hv,
    have hvunit : is_unit (v : R), by {exact units.is_unit v, },
    apply (unit_mul_mem_iff_mem P hvunit).1 _,
    apply hP2,
    apply hv,},
  have hel22 : (x : R) * (1 - Œ∑‚ÇÅ) ‚àà P, by {
      obtain ‚ü®v, hv ‚ü©:= hel2,
    rw mul_assoc at hv,
    have hvunit : is_unit (v : R), by {exact units.is_unit v, },
    apply (unit_mul_mem_iff_mem P hvunit).1 _,
    apply hP2,
    apply hv,
  },
  have hPrime:= hP1.is_prime,
  have hprime2 := is_prime.mem_or_mem hPrime hel11,
  have hprime3 := is_prime.mem_or_mem hPrime hel22,
  have HC : (1 - Œ∑‚ÇÅ) ‚àà P ‚Üí false,
    begin
    intro h,
    have eta_sub_one_ne_zero :=  sub_ne_zero.mpr (ne.symm hwlog),
    have hŒ∑prime : is_prime (ideal.span ({1 - Œ∑‚ÇÅ} : set R)) := by {
      rw span_singleton_prime eta_sub_one_ne_zero,
      apply one_sub_zeta_prime ph hŒ∑‚ÇÅ hwlog,},
    have H5 : is_prime (ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§)), by {
    have h2 : (p : ‚Ñ§) ‚â† 0, by {simp, },
    have h1 : prime (p : ‚Ñ§) , by {simp only [coe_coe], rw  ‚Üêprime_iff_prime_int, exact _inst_4.out,},
    rw (span_singleton_prime h2),
    apply h1,  },
    have hŒ∑P : (ideal.span ({1 - Œ∑‚ÇÅ} : set R)) = P, by {
      have hRdim1 : ring.dimension_le_one R,  by {exact is_dedekind_domain.dimension_le_one,},
      have hle : (ideal.span ({1 - Œ∑‚ÇÅ} : set R)) ‚â§ P, by {rw span_le, simp [h],},
      apply ((@ring.dimension_le_one.prime_le_prime_iff_eq _ _ hRdim1 _ _ hŒ∑prime hPrime _).1 hle),
      simp,
      exact sub_ne_zero.mpr (ne.symm hwlog)},
    have hcapZ : P.comap (int.cast_ring_hom R) = ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§), by {
      have H1 : ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§) ‚â§ P.comap (int.cast_ring_hom R), by {
        rw ‚ÜêhŒ∑P,
        apply le_comap_of_map_le _,
        rw map_span,
        simp,
        rw span_singleton_le_span_singleton,
        apply zeta_sub_one_dvb_p ph hŒ∑‚ÇÅ hwlog},
      have H2 : is_prime (P.comap (int.cast_ring_hom R)),
        by {apply @is_prime.comap _ _ _ _ _ _ _ _ hPrime,},
      have H3 : ring.dimension_le_one ‚Ñ§, by {exact is_dedekind_domain.dimension_le_one, },
      have H4 :  (ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§)) ‚â† ‚ä•, by {simp,},
      apply ((@ring.dimension_le_one.prime_le_prime_iff_eq _ _ H3 _ _ H5 H2 H4).1 H1).symm,},
    have hxyinP : (x + y : R) ‚àà P, by {
      have H1 : (x : R) + Œ∑‚ÇÅ* y ‚àà P, by { apply hiP, apply submodule.mem_span_singleton_self},
      have H2 : Œ∑‚ÇÅ * y = y - y * (1 - Œ∑‚ÇÅ), by {ring},
      rw H2 at H1,
      have H3 : ‚Üëx + (‚Üëy - ‚Üëy * (1 - Œ∑‚ÇÅ)) = (‚Üëx + ‚Üëy) + (-‚Üëy * (1 - Œ∑‚ÇÅ)), by {ring},
      rw H3 at H1,
      have H4 : -‚Üëy * (1 - Œ∑‚ÇÅ) ‚àà P, by {rw ‚ÜêhŒ∑P, rw ideal.mem_span_singleton',
      refine ‚ü®-(y : R), rfl‚ü©, },
      apply (ideal.add_mem_iff_left P H4).1 H1,},
    have hxyinP2 : (x + y ) ‚àà ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§), by {rw ‚ÜêhcapZ, simp [hxyinP]},
    rw mem_span_singleton at hxyinP2,
    apply absurd hxyinP2 hp2,
    end,
  cases hprime2,
  cases hprime3,
  obtain ‚ü®a, b, hab ‚ü© := hp,
  have hone := P.add_mem (ideal.mul_mem_left _ a hprime3) (ideal.mul_mem_left _ b hprime2),
  norm_cast at hone,
  rw hab at hone,
  norm_cast at hone,
  rw ‚Üêeq_top_iff_one at hone,
  have hcontra := is_prime.ne_top hPrime,
  rw hone at hcontra,
  simp only [ne.def, eq_self_iff_true, not_true] at hcontra,
  exact hcontra,
  apply HC hprime3,
  apply HC hprime2,
end

lemma aux_lem_flt [fact (p : ‚Ñï).prime] {x y z : ‚Ñ§}
  (H : x ^ (p : ‚Ñï) + y ^ (p : ‚Ñï) = z ^ (p : ‚Ñï))
  (caseI : ¬¨ ‚Üëp ‚à£ x * y * z) : ¬¨ (p : ‚Ñ§) ‚à£ (x + y : ‚Ñ§) :=
begin
  intro habs,
  replace habs : ‚Üë(p : ‚Ñï) ‚à£ (x + y : ‚Ñ§) := by simpa using habs,
  rw [‚Üê zmod.int_coe_zmod_eq_zero_iff_dvd, int.cast_add] at habs,
  replace H := congr_arg (Œª x : ‚Ñ§, (x : zmod p)) H.symm,
  simp only [int.cast_add, int.cast_pow, zmod.pow_card, habs, zmod.int_coe_zmod_eq_zero_iff_dvd,
    ‚Üê coe_coe] at H,
  exact caseI (has_dvd.dvd.mul_left H _)
end

lemma flt_ideals_coprime [fact (p : ‚Ñï).prime] (p5 : 5 ‚â§ p) {x y z : ‚Ñ§}
  (H : x ^ (p : ‚Ñï) + y ^ (p : ‚Ñï) = z ^ (p : ‚Ñï)) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R} (hxy : is_coprime x y)
  (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R) (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ)
  (caseI : ¬¨ ‚Üëp ‚à£ x * y * z) : is_coprime (flt_ideals p x y hŒ∑‚ÇÅ) (flt_ideals p x y hŒ∑‚ÇÇ) :=
begin
   --how does wlog work? I want to have Œ∑‚ÇÅ ‚â† 1...
  by_cases h : Œ∑‚ÇÅ ‚â† 1,
   apply flt_ideals_coprime2 p5 hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hxy (aux_lem_flt H caseI) h,
  have h2 : Œ∑‚ÇÇ ‚â† 1, by {simp at h, rw h at hdiff, exact hdiff.symm},
  have := flt_ideals_coprime2 p5 hŒ∑‚ÇÇ hŒ∑‚ÇÅ hdiff.symm hxy (aux_lem_flt H caseI) h2,
  apply is_coprime.symm,
  exact this,
end

variable {L}

lemma dvd_last_coeff_cycl_integer [hp : fact (p : ‚Ñï).prime] {Œ∂ : ùìû L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ‚Ñ§} (hf : ‚àÉ i, f i = 0) {m : ‚Ñ§}
  (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ Œ∂ ^ (j : ‚Ñï)) :
  m ‚à£ f ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© :=
begin
  obtain ‚ü®i, Hi‚ü© := hf,
  have hlast : (fin.cast (succ_pred_prime hp.out)) (fin.last (p : ‚Ñï).pred) =
    ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := fin.ext rfl,
  have h : ‚àÄ x, (fin.cast (succ_pred_prime hp.out)) (fin.cast_succ x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.out.ne_zero)‚ü© := Œª x, fin.ext rfl,
  let Œ∂' := (Œ∂ : L),
  have hŒ∂' : is_primitive_root Œ∂' p :=
    is_primitive_root.coe_submonoid_class_iff.2 hŒ∂,
  have hcoe : Œ∂ = ‚ü®Œ∂', hŒ∂'.is_integral p.pos‚ü© := by simp,
  set b := hŒ∂'.integral_power_basis' with hb,
  have hdim : b.dim = (p : ‚Ñï).pred,
  { rw [hŒ∂'.power_basis_int'_dim, totient_prime hp.out, pred_eq_sub_one] },

  by_cases H : i = ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü©,
  { simp [H.symm, Hi] },
  have hi : ‚Üëi < (p : ‚Ñï).pred,
  { by_contra' habs,
    simpa [le_antisymm habs (le_pred_of_lt (fin.is_lt i))] using H },
  obtain ‚ü®y, hy‚ü© := hdiv,
  rw [‚Üê equiv.sum_comp (fin.cast (succ_pred_prime hp.out)).to_equiv, fin.sum_univ_cast_succ] at hy,
  simp only [hlast, h, rel_iso.coe_fn_to_equiv, fin.coe_mk] at hy,
  rw [hŒ∂.pow_sub_one_eq hp.out.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (fin.cast hdim).to_equiv.sum_comp] at hy,
  simp only [rel_iso.coe_fn_to_equiv, fin.coe_cast, mul_neg, ‚Üê subtype.coe_inj] at hy,
  push_cast at hy,
  conv_lhs at hy { congr, skip, funext,
    rw [smul_neg, hcoe, ‚Üê hŒ∂'.integral_power_basis'_gen, ‚Üê hb, ‚Üê subsemiring_class.coe_pow,
      ‚Üê show ‚àÄ x, _ = _, from Œª x, congr_fun b.coe_basis x, ‚Üê sub_eq_add_neg] },
  norm_cast at hy,
  rw [sum_sub_distrib] at hy,
  replace hy := congr_arg (b.basis.coord ((fin.cast hdim.symm) ‚ü®i, hi‚ü©)) hy,
  rw [‚Üê b.basis.equiv_fun_symm_apply, ‚Üê b.basis.equiv_fun_symm_apply, linear_map.map_sub,
    b.basis.coord_equiv_fun_symm, b.basis.coord_equiv_fun_symm] at hy,
  simp only [Hi, fin.coe_cast, smul_eq_mul, mul_boole, sum_ite_eq', mem_univ, fin.coe_mk,
    fin.eta, zero_sub, if_true] at hy,
  rw [‚Üê smul_eq_mul, ‚Üê zsmul_eq_smul_cast, neg_eq_iff_neg_eq] at hy,
  obtain ‚ü®n, hn‚ü© := b.basis.coord_dvd_of_dvd ((fin.cast hdim.symm) ‚ü®i, hi‚ü©) y m,
  rw [hn] at hy,
  simp [‚Üê hy, dvd_neg]
end

lemma dvd_coeff_cycl_integer [hp : fact (p : ‚Ñï).prime] {Œ∂ : ùìû L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ‚Ñ§} (hf : ‚àÉ i, f i = 0) {m : ‚Ñ§}
  (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ Œ∂ ^ (j : ‚Ñï)) : ‚àÄ j, m ‚à£ f j :=
begin
  let Œ∂' := (Œ∂ : L),
  have hŒ∂' : is_primitive_root Œ∂' p :=
    is_primitive_root.coe_submonoid_class_iff.2 hŒ∂,
  have hcoe : Œ∂ = ‚ü®Œ∂', hŒ∂'.is_integral p.pos‚ü© := by simp,
  have hlast : (fin.cast (succ_pred_prime hp.out)) (fin.last (p : ‚Ñï).pred) =
    ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := fin.ext rfl,
  have h : ‚àÄ x, (fin.cast (succ_pred_prime hp.out)) (fin.cast_succ x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.out.ne_zero)‚ü© := Œª x, fin.ext rfl,
  set b := hŒ∂'.integral_power_basis' with hb,
  have hdim : b.dim = (p : ‚Ñï).pred,
  { rw [hŒ∂'.power_basis_int'_dim, totient_prime hp.out, pred_eq_sub_one] },
  have last_dvd := dvd_last_coeff_cycl_integer hŒ∂ hf hdiv,

  intro j,
  by_cases H : j = ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü©,
  { simpa [H] using last_dvd },
  have hj : ‚Üëj < (p : ‚Ñï).pred,
  { by_contra' habs,
    simpa [le_antisymm habs (le_pred_of_lt (fin.is_lt j))] using H },
  obtain ‚ü®y, hy‚ü© := hdiv,
  rw [‚Üê equiv.sum_comp (fin.cast (succ_pred_prime hp.out)).to_equiv, fin.sum_univ_cast_succ] at hy,
  simp only [hlast, h, rel_iso.coe_fn_to_equiv, fin.coe_mk] at hy,
  rw [hŒ∂.pow_sub_one_eq hp.out.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (fin.cast hdim).to_equiv.sum_comp] at hy,
  simp only [rel_iso.coe_fn_to_equiv, fin.coe_cast, mul_neg, ‚Üê subtype.coe_inj] at hy,
  push_cast at hy,
  conv_lhs at hy { congr, skip, funext,
    rw [smul_neg, hcoe, ‚Üê hŒ∂'.integral_power_basis'_gen, ‚Üê hb, ‚Üê subsemiring_class.coe_pow,
      ‚Üê show ‚àÄ x, _ = _, from Œª x, congr_fun b.coe_basis x, ‚Üê sub_eq_add_neg] },
  norm_cast at hy,
  rw [sum_sub_distrib] at hy,
  replace hy := congr_arg (b.basis.coord ((fin.cast hdim.symm) ‚ü®j, hj‚ü©)) hy,
  rw [‚Üê b.basis.equiv_fun_symm_apply, ‚Üê b.basis.equiv_fun_symm_apply, linear_map.map_sub,
    b.basis.coord_equiv_fun_symm, b.basis.coord_equiv_fun_symm] at hy,
  simp only [fin.cast_mk, fin.coe_mk, fin.eta, basis.coord_apply, sub_eq_iff_eq_add] at hy,
  obtain ‚ü®n, hn‚ü© := b.basis.coord_dvd_of_dvd ((fin.cast hdim.symm) ‚ü®j, hj‚ü©) y m,
  rw [hy, ‚Üê smul_eq_mul, ‚Üê zsmul_eq_smul_cast, ‚Üê b.basis.coord_apply, ‚Üê fin.cast_mk, hn],
  exact dvd_add (dvd_mul_right _ _) last_dvd
end

end int_facts
