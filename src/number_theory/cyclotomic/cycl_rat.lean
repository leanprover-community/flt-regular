import ring_theory.polynomial.eisenstein
import number_theory.cyclotomic.galois_action_on_cyclo
import number_theory.cyclotomic.rat

import ready_for_mathlib.basis
import ready_for_mathlib.is_cyclotomic_extension

universes u

open finite_dimensional polynomial algebra nat finset fintype

variables (p : ‚Ñï+) (L : Type u) [field L] [char_zero L] [is_cyclotomic_extension {p} ‚Ñö L]

section int_facts

noncomputable theory

open_locale number_field big_operators

--A.K.A theorem:FLT_facts 3
-- Eric: is this superseded by `exists_int_sub_pow_prime_dvd`?
lemma flt_fact_3 [fact (p : ‚Ñï).prime] (a : ùìû L) :
  ‚àÉ (m : ‚Ñ§), (a ^ (p : ‚Ñï) - m) ‚àà ideal.span ({p} : set (ùìû L)) := by admit

open ideal is_cyclotomic_extension

-- TODO refactor add_pow_char_of_commute to use this instead of its own (basically the same) proof
-- TODO is the fact assumption necessary what if p is a prime power?
-- TODO other versions, e.g. one for sub and one for p^n with the
theorem add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute {R : Type*} [semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) (h : commute x y) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
begin
  have : p = p - 1 + 1 := (nat.succ_pred_prime (fact.out _)).symm,
  rw [commute.add_pow h, finset.sum_range_succ_comm, tsub_self, pow_zero, nat.choose_self,
    nat.cast_one, mul_one, mul_one, this, finset.sum_range_succ'],
  simp only [this.symm, tsub_zero, mul_one, one_mul, nat.choose_zero_right, nat.cast_one, pow_zero],
  rw add_comm _ (y ^ p),
  simp_rw add_assoc,
  use (finset.range (p - 1)).sum
    (Œª (x_1 : ‚Ñï), x ^ (x_1 + 1) * y ^ (p - (x_1 + 1)) * ‚Üë(p.choose (x_1 + 1) / p)),
  rw finset.mul_sum,
  congr' 2,
  apply finset.sum_congr rfl,
  intros i hi,
  rw [finset.mem_range] at hi,
  rw [nat.cast_comm, mul_assoc, mul_assoc, mul_assoc],
  congr,
  norm_cast,
  rw nat.div_mul_cancel,
  exact nat.prime.dvd_choose_self (nat.succ_pos _) (lt_tsub_iff_right.mp hi) (fact.out _),
end

theorem add_pow_prime_eq_pow_add_pow_add_prime_mul {R : Type*} [comm_semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute _ _ _ (commute.all _ _)

-- TODO can we make a relative version of this with another base ring instead of ‚Ñ§ ?
-- A version of flt_facts_3 indep of the ring
lemma exists_int_sub_pow_prime_dvd {A : Type*} [comm_ring A] [is_cyclotomic_extension {p} ‚Ñ§ A]
  [fact (p : ‚Ñï).prime] (a : A) : ‚àÉ (m : ‚Ñ§), (a ^ (p : ‚Ñï) - m) ‚àà span ({p} : set A) :=
begin
  have : a ‚àà algebra.adjoin ‚Ñ§ _ := @adjoin_roots {p} ‚Ñ§ A _ _ _ _ a,
  apply algebra.adjoin_induction this,
  { intros x hx,
    rcases hx with ‚ü®hx_w, hx_m, hx_p‚ü©,
    simp only [set.mem_singleton_iff] at hx_m,
    rw [hx_m] at hx_p,
    simp only [hx_p, coe_coe],
    use 1,
    simp, },
  { intros r,
    use r ^ (p : ‚Ñï),
    simp, },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    obtain ‚ü®r, hr‚ü© := add_pow_prime_eq_pow_add_pow_add_prime_mul p x y,
    rw [hr],
    use c + b,
    push_cast,
    rw [sub_add_eq_sub_sub, sub_eq_add_neg, sub_eq_add_neg, add_comm _ (‚Üë‚Üëp * r),
        add_assoc, add_assoc],
    apply' ideal.add_mem _ _,
    { convert ideal.add_mem _ hb hc using 1,
      ring },
    { rw [mem_span_singleton, coe_coe],
      exact dvd_mul_right _ _ } },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    rw mul_pow,
    use b * c,
    have := ideal.mul_mem_left _ (x ^ (p : ‚Ñï)) hc,
    rw [mul_sub] at this,
    rw [‚Üêideal.quotient.eq_zero_iff_mem, map_sub] at this ‚ä¢ hb,
    convert this using 2,
    rw [int.cast_mul, _root_.map_mul, _root_.map_mul],
    congr' 1,
    exact (sub_eq_zero.mp hb).symm }
end

instance aaaa [fact ((p : ‚Ñï).prime)] : is_cyclotomic_extension {p} ‚Ñ§ (ùìû L) :=
let _ := (zeta_spec p ‚Ñö L).adjoin_is_cyclotomic_extension ‚Ñ§ in
  by exactI is_cyclotomic_extension.equiv {p} (zeta_spec p ‚Ñö L).adjoin_equiv_ring_of_integers'

local notation `RR` := ùìû (cyclotomic_field p ‚Ñö)

local attribute [instance] algebra_rat_subsingleton

--This is still annoying
instance [hp : fact ((p : ‚Ñï).prime)] : is_cyclotomic_extension {p} ‚Ñ§ ‚Ü•(ùìû (cyclotomic_field p ‚Ñö)) :=
@aaaa p (cyclotomic_field p ‚Ñö) _ _
  (by { convert cyclotomic_field.is_cyclotomic_extension p ‚Ñö, exact subsingleton.elim _ _ }) _

-- TODO I (alex) am not sure whether this is better as ideal span,
-- or fractional_ideal.span_singleton
/-- The principal ideal generated by `x + y Œ∂^i` for integer `x` and `y` -/
def flt_ideals [fact ((p : ‚Ñï).prime)] (x y i : ‚Ñ§) : ideal RR :=
  ideal.span ({ x + y * ((zeta_runity p ‚Ñ§ RR) ^ i : RRÀ£) } : set RR)

variable {p} -- why does this not update (n : ‚Ñï+)?

lemma mem_flt_ideals [fact ((p : ‚Ñï).prime)] {x y i : ‚Ñ§} :
  (x : RR) + y * ((zeta_runity p ‚Ñ§ RR) ^ i : RRÀ£) ‚àà flt_ideals p x y i :=
mem_span_singleton.mpr dvd_rfl

section to_move

variables {R : Type*} [semiring R] {s t : ideal R}

lemma ideal.add_left_subset  : s ‚â§ s + t := le_sup_left
lemma ideal.add_right_subset : t ‚â§ s + t := le_sup_right

variables {K : Type*} [semiring K]

lemma add_eq_mul_one_add_div {a : KÀ£} {b : K} : ‚Üëa + b = a * (1 + ‚Üëa‚Åª¬π * b) :=
by rwa [mul_add, mul_one, ‚Üê mul_assoc, units.mul_inv, one_mul]

end to_move

lemma flt_ideals_coprime [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {x y : ‚Ñ§} {i j : ‚Ñ§} (h : i ‚â† j)
  (hp : is_coprime x y) : flt_ideals p x y i + flt_ideals p x y j = ‚ä§ :=
begin
  let I := flt_ideals p x y i + flt_ideals p x y j,
  have : ‚àÉ v : RRÀ£, (v : RR) * y * (1 - (zeta_runity p ‚Ñ§ RR)) ‚àà I,
  { have := I.add_mem (ideal.add_left_subset $ mem_flt_ideals)
                      (ideal.mul_mem_left _ (-1) $ ideal.add_right_subset $ mem_flt_ideals),
    simp only [neg_mul, one_mul, neg_add_rev] at this,
    rw [neg_mul_eq_mul_neg, add_comm] at this,
    simp only [‚Üê add_assoc] at this,
    rw [add_assoc _ (-_) _, neg_add_self, add_zero, ‚Üêmul_add, add_comm, add_eq_mul_one_add_div,
        ‚Üêzpow_neg] at this,
    sorry
    -- I cannot get the tactic state to work here :/
  }, sorry,
end

variable {L}

lemma dvd_last_coeff_cycl_integer [hp : fact (p : ‚Ñï).prime] {Œ∂ : L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ‚Ñ§} {i : fin p} (hf : f i = 0) {m : ‚Ñ§}
  (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) ^ (j : ‚Ñï)) :
  m ‚à£ f ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© :=
begin
  have hlast : (fin.cast (succ_pred_prime hp.out)) (fin.last (p : ‚Ñï).pred) =
    ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := fin.ext rfl,
  have h : ‚àÄ x, (fin.cast (succ_pred_prime hp.out)) (fin.cast_succ x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.out.ne_zero)‚ü© := Œª x, fin.ext rfl,
  have hŒ∂' : is_primitive_root (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) p :=
    is_primitive_root.coe_submonoid_class_iff.1 hŒ∂,
  set b := hŒ∂.integral_power_basis' with hb,
  have hdim : b.dim = (p : ‚Ñï).pred,
  { rw [hŒ∂.power_basis_int'_dim, totient_prime hp.out, pred_eq_sub_one] },

  by_cases H : i = ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü©,
  { simp [H.symm, hf] },
  have hi : ‚Üëi < (p : ‚Ñï).pred,
  { by_contra' habs,
    simpa [le_antisymm habs (le_pred_of_lt (fin.is_lt i))] using H },
  obtain ‚ü®y, hy‚ü© := hdiv,
  rw [‚Üê equiv.sum_comp (fin.cast (succ_pred_prime hp.out)).to_equiv, fin.sum_univ_cast_succ] at hy,
  simp only [hlast, h, rel_iso.coe_fn_to_equiv, fin.coe_mk] at hy,
  rw [hŒ∂'.pow_sub_one_eq hp.out.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (fin.cast hdim).to_equiv.sum_comp] at hy,
  simp only [rel_iso.coe_fn_to_equiv, fin.coe_cast, mul_neg] at hy,
  conv_lhs at hy { congr, skip, funext,
    rw [add_comm, smul_neg, ‚Üê sub_eq_neg_add, ‚Üê sub_smul, ‚Üê hŒ∂.integral_power_basis'_gen,
      ‚Üê hb, ‚Üê show ‚àÄ x, _ = _, from Œª x, congr_fun b.coe_basis x] },
  replace hy := congr_arg (b.basis.coord ((fin.cast hdim.symm) ‚ü®i, hi‚ü©)) hy,
  rw [‚Üê b.basis.equiv_fun_symm_apply, b.basis.coord_equiv_fun_symm] at hy,
  simp only [hf, fin.coe_cast, smul_eq_mul, mul_boole, sum_ite_eq', mem_univ, fin.coe_mk,
    fin.eta, zero_sub, if_true] at hy,
  rw [‚Üê smul_eq_mul, ‚Üê zsmul_eq_smul_cast, neg_eq_iff_neg_eq] at hy,
  obtain ‚ü®n, hn‚ü© := b.basis.coord_dvd_of_dvd ((fin.cast hdim.symm) ‚ü®i, hi‚ü©) y m,
  rw [hn] at hy,
  simp [‚Üê hy, dvd_neg]
end

lemma dvd_coeff_cycl_integer [hp : fact (p : ‚Ñï).prime] {Œ∂ : L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ‚Ñ§} {i : fin p} (hf : f i = 0) {m : ‚Ñ§}
  (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) ^ (j : ‚Ñï)) : ‚àÄ j, m ‚à£ f j :=
begin
  have hlast : (fin.cast (succ_pred_prime hp.out)) (fin.last (p : ‚Ñï).pred) =
    ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := fin.ext rfl,
  have h : ‚àÄ x, (fin.cast (succ_pred_prime hp.out)) (fin.cast_succ x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.out.ne_zero)‚ü© := Œª x, fin.ext rfl,
  have hŒ∂' : is_primitive_root (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) p :=
    is_primitive_root.coe_submonoid_class_iff.1 hŒ∂,
  set b := hŒ∂.integral_power_basis' with hb,
  have hdim : b.dim = (p : ‚Ñï).pred,
  { rw [hŒ∂.power_basis_int'_dim, totient_prime hp.out, pred_eq_sub_one] },
  have last_dvd := dvd_last_coeff_cycl_integer hŒ∂ hf hdiv,

  intro j,
  by_cases H : j = ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü©,
  { simpa [H] using last_dvd },
  have hj : ‚Üëj < (p : ‚Ñï).pred,
  { by_contra' habs,
    simpa [le_antisymm habs (le_pred_of_lt (fin.is_lt j))] using H },
  obtain ‚ü®y, hy‚ü© := hdiv,
  rw [‚Üê equiv.sum_comp (fin.cast (succ_pred_prime hp.out)).to_equiv, fin.sum_univ_cast_succ] at hy,
  simp only [hlast, h, rel_iso.coe_fn_to_equiv, fin.coe_mk] at hy,
  rw [hŒ∂'.pow_sub_one_eq hp.out.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (fin.cast hdim).to_equiv.sum_comp] at hy,
  simp only [rel_iso.coe_fn_to_equiv, fin.coe_cast, mul_neg] at hy,
  conv_lhs at hy { congr, skip, funext,
    rw [add_comm, smul_neg, ‚Üê sub_eq_neg_add, ‚Üê sub_smul, ‚Üê hŒ∂.integral_power_basis'_gen,
      ‚Üê hb, ‚Üê show ‚àÄ x, _ = _, from Œª x, congr_fun b.coe_basis x] },
  replace hy := congr_arg (b.basis.coord ((fin.cast hdim.symm) ‚ü®j, hj‚ü©)) hy,
  rw [‚Üê b.basis.equiv_fun_symm_apply, b.basis.coord_equiv_fun_symm] at hy,
  simp only [fin.cast_mk, fin.coe_mk, fin.eta, basis.coord_apply, sub_eq_iff_eq_add] at hy,
  obtain ‚ü®n, hn‚ü© := b.basis.coord_dvd_of_dvd ((fin.cast hdim.symm) ‚ü®j, hj‚ü©) y m,
  rw [hy, ‚Üê smul_eq_mul, ‚Üê zsmul_eq_smul_cast, ‚Üê b.basis.coord_apply, ‚Üê fin.cast_mk, hn],
  exact dvd_add (dvd_mul_right _ _) last_dvd
end

end int_facts
