import ring_theory.polynomial.eisenstein
import number_theory.cyclotomic.galois_action_on_cyclo
import number_theory.cyclotomic.rat

import ready_for_mathlib.basis
import ring_theory.dedekind_domain.ideal
import ready_for_mathlib.is_cyclotomic_extension
import number_theory.cyclotomic.zeta_sub_one_prime

universes u

open finite_dimensional polynomial algebra nat finset fintype

variables (p : ‚Ñï+) (L : Type u) [field L] [char_zero L] [is_cyclotomic_extension {p} ‚Ñö L]

section int_facts

noncomputable theory

open_locale number_field big_operators

section to_move

variables {R : Type*} [semiring R] {s t : ideal R}

lemma ideal.add_left_subset  : s ‚â§ s + t := le_sup_left
lemma ideal.add_right_subset : t ‚â§ s + t := le_sup_right

variables {K : Type*} [semiring K]

lemma add_eq_mul_one_add_div {a : KÀ£} {b : K} : ‚Üëa + b = a * (1 + ‚Üëa‚Åª¬π * b) :=
by rwa [mul_add, mul_one, ‚Üê mul_assoc, units.mul_inv, one_mul]

end to_move

open ideal is_cyclotomic_extension

-- TODO refactor add_pow_char_of_commute to use this instead of its own (basically the same) proof
-- TODO is the fact assumption necessary what if p is a prime power?
-- TODO other versions, e.g. one for sub and one for p^n with the
theorem add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute {R : Type*} [semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) (h : commute x y) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
begin
  have : p = p - 1 + 1 := (nat.succ_pred_prime (fact.out _)).symm,
  rw [commute.add_pow h, finset.sum_range_succ_comm, tsub_self, pow_zero, nat.choose_self,
    nat.cast_one, mul_one, mul_one, this, finset.sum_range_succ'],
  simp only [this.symm, tsub_zero, mul_one, one_mul, nat.choose_zero_right, nat.cast_one, pow_zero],
  rw add_comm _ (y ^ p),
  simp_rw add_assoc,
  use (finset.range (p - 1)).sum
    (Œª (x_1 : ‚Ñï), x ^ (x_1 + 1) * y ^ (p - (x_1 + 1)) * ‚Üë(p.choose (x_1 + 1) / p)),
  rw finset.mul_sum,
  congr' 2,
  apply finset.sum_congr rfl,
  intros i hi,
  rw [finset.mem_range] at hi,
  rw [nat.cast_comm, mul_assoc, mul_assoc, mul_assoc],
  congr,
  norm_cast,
  rw nat.div_mul_cancel,
  exact nat.prime.dvd_choose_self (nat.succ_pos _) (lt_tsub_iff_right.mp hi) (fact.out _),
end

theorem add_pow_prime_eq_pow_add_pow_add_prime_mul {R : Type*} [comm_semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute _ _ _ (commute.all _ _)

-- TODO can we make a relative version of this with another base ring instead of ‚Ñ§ ?
-- A version of flt_facts_3 indep of the ring
lemma exists_int_sub_pow_prime_dvd {A : Type*} [comm_ring A] [is_cyclotomic_extension {p} ‚Ñ§ A]
  [fact (p : ‚Ñï).prime] (a : A) : ‚àÉ (m : ‚Ñ§), (a ^ (p : ‚Ñï) - m) ‚àà span ({p} : set A) :=
begin
  have : a ‚àà algebra.adjoin ‚Ñ§ _ := @adjoin_roots {p} ‚Ñ§ A _ _ _ _ a,
  apply algebra.adjoin_induction this,
  { intros x hx,
    rcases hx with ‚ü®hx_w, hx_m, hx_p‚ü©,
    simp only [set.mem_singleton_iff] at hx_m,
    rw [hx_m] at hx_p,
    simp only [hx_p, coe_coe],
    use 1,
    simp, },
  { intros r,
    use r ^ (p : ‚Ñï),
    simp, },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    obtain ‚ü®r, hr‚ü© := add_pow_prime_eq_pow_add_pow_add_prime_mul p x y,
    rw [hr],
    use c + b,
    push_cast,
    rw [sub_add_eq_sub_sub, sub_eq_add_neg, sub_eq_add_neg, add_comm _ (‚Üë‚Üëp * r),
        add_assoc, add_assoc],
    apply' ideal.add_mem _ _,
    { convert ideal.add_mem _ hb hc using 1,
      ring },
    { rw [mem_span_singleton, coe_coe],
      exact dvd_mul_right _ _ } },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    rw mul_pow,
    use b * c,
    have := ideal.mul_mem_left _ (x ^ (p : ‚Ñï)) hc,
    rw [mul_sub] at this,
    rw [‚Üêideal.quotient.eq_zero_iff_mem, map_sub] at this ‚ä¢ hb,
    convert this using 2,
    rw [int.cast_mul, _root_.map_mul, _root_.map_mul],
    congr' 1,
    exact (sub_eq_zero.mp hb).symm }
end

instance aaaa [fact ((p : ‚Ñï).prime)] : is_cyclotomic_extension {p} ‚Ñ§ (ùìû L) :=
let _ := (zeta_spec p ‚Ñö L).adjoin_is_cyclotomic_extension ‚Ñ§ in
  by exactI is_cyclotomic_extension.equiv {p} (zeta_spec p ‚Ñö L).adjoin_equiv_ring_of_integers'

local notation `R` := ùìû (cyclotomic_field p ‚Ñö)

local attribute [instance] algebra_rat_subsingleton

--This is still annoying
instance [hp : fact ((p : ‚Ñï).prime)] : is_cyclotomic_extension {p} ‚Ñ§ ‚Ü•(ùìû (cyclotomic_field p ‚Ñö)) :=
@aaaa p (cyclotomic_field p ‚Ñö) _ _
  (by { convert cyclotomic_field.is_cyclotomic_extension p ‚Ñö, exact subsingleton.elim _ _ }) _

-- TODO I (alex) am not sure whether this is better as ideal span,
-- or fractional_ideal.span_singleton
/-- The principal ideal generated by `x + y Œ∂^i` for integer `x` and `y` -/
@[nolint unused_arguments]
def flt_ideals [fact ((p : ‚Ñï).prime)] (x y : ‚Ñ§) {Œ∑ : R}
  (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R) : ideal R :=
  ideal.span ({ x + Œ∑ * y } : set R)

variable {p} -- why does this not update (n : ‚Ñï+)?

lemma mem_flt_ideals [fact ((p : ‚Ñï).prime)] (x y : ‚Ñ§) {Œ∑ : R}
  (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R) :
  ‚Üëx + Œ∑ * ‚Üëy ‚àà flt_ideals p x y hŒ∑ :=
mem_span_singleton.mpr dvd_rfl

lemma not_coprime_not_top (a b : ideal R) : ¬¨ is_coprime a b ‚Üî a + b ‚â† ‚ä§ :=
begin
 sorry,
end

lemma zeta_sub_one_dvb_p [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {Œ∑ : R} (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R)
  (hne1 : Œ∑ ‚â† 1): (1 -Œ∑) ‚à£ (p : R) :=
begin
  sorry,
end

lemma one_sub_zeta_prime [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {Œ∑ : R} (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R)
  (hne1 : Œ∑ ‚â† 1) : prime (1 - Œ∑) :=
begin
sorry,
end

lemma diff_of_roots  [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R} (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R)
  (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ) (hwlog : Œ∑‚ÇÅ ‚â† 1) :
  ‚àÉ (u : RÀ£), (Œ∑‚ÇÅ - Œ∑‚ÇÇ) = u * (1 - Œ∑‚ÇÅ)  :=
begin
 sorry,
end


lemma diff_of_roots2  [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R} (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R)
  (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ) (hwlog : Œ∑‚ÇÅ ‚â† 1) :
  ‚àÉ (u : RÀ£), (Œ∑‚ÇÇ - Œ∑‚ÇÅ) = u * (1 - Œ∑‚ÇÅ)  :=
begin
 sorry,
end

instance arg : is_dedekind_domain R := sorry

lemma flt_ideals_coprime2 [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {x y : ‚Ñ§} {Œ∑‚ÇÅ Œ∑‚ÇÇ : R}
  (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R) (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ)
  (hp : is_coprime x y) (hp2 : ¬¨ (p : ‚Ñ§) ‚à£ (x + y : ‚Ñ§) ) (hwlog : Œ∑‚ÇÅ ‚â† 1) :
  is_coprime (flt_ideals p x y hŒ∑‚ÇÅ) (flt_ideals p x y hŒ∑‚ÇÇ) :=
begin
  let I := flt_ideals p x y hŒ∑‚ÇÅ + flt_ideals p x y hŒ∑‚ÇÇ,
  by_contra,
  have he := (not_coprime_not_top p (flt_ideals p x y hŒ∑‚ÇÅ)  (flt_ideals p x y hŒ∑‚ÇÇ)).1 h,
  have := exists_le_maximal I he,
  obtain ‚ü®P, hP1, hP2‚ü©:= this,
  have hiP : (flt_ideals p x y hŒ∑‚ÇÅ) ‚â§ P, by {apply le_trans _ hP2, apply ideal.add_left_subset,},
  have hjP : (flt_ideals p x y hŒ∑‚ÇÇ) ‚â§ P, by {apply le_trans _ hP2, apply ideal.add_right_subset,},
  have hel1: ‚àÉ v : RÀ£, (v : R) * y * (1 - Œ∑‚ÇÅ) ‚àà I, by {
  have := I.add_mem (ideal.add_left_subset $ (mem_flt_ideals _ _ hŒ∑‚ÇÅ))
                      (ideal.mul_mem_left _ (-1) $ ideal.add_right_subset $ (mem_flt_ideals _ _ _) ),
    simp only [neg_mul, one_mul, neg_add_rev] at this,
    rw [neg_mul_eq_mul_neg, add_comm] at this,
    simp only [‚Üê add_assoc] at this,
    simp at this,
    have hh := diff_of_roots ph hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hwlog,
    obtain ‚ü®v, hv‚ü© := hh,
    refine ‚ü®v, _‚ü©,
    have  h3 : -(Œ∑‚ÇÇ * ‚Üëy) + Œ∑‚ÇÅ * ‚Üëy = (Œ∑‚ÇÅ - Œ∑‚ÇÇ) * y, by {ring},
    rw h3 at this,
    rw hv at this,
    have h4 :  ‚Üëv * (1 - Œ∑‚ÇÅ) * ‚Üëy = v * y * (1-Œ∑‚ÇÅ) , by {ring},
    rw ‚Üêh4,
    apply this},
  have hel2 : ‚àÉ v : RÀ£, (v : R) * x * (1 - Œ∑‚ÇÅ) ‚àà I, by {
    have := I.add_mem (ideal.mul_mem_left _ (Œ∑‚ÇÇ) $ ideal.add_left_subset $ (mem_flt_ideals _ _ hŒ∑‚ÇÅ))
                      (ideal.mul_mem_left _ (-Œ∑‚ÇÅ) $ ideal.add_right_subset $ (mem_flt_ideals _ _ _)),
    have h1 :  Œ∑‚ÇÇ * (‚Üëx + Œ∑‚ÇÅ * ‚Üëy) + -Œ∑‚ÇÅ * (‚Üëx + Œ∑‚ÇÇ * ‚Üëy) = (Œ∑‚ÇÇ - Œ∑‚ÇÅ) * x, by {ring},
    rw h1 at this,
    have hh := diff_of_roots2 ph hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hwlog,
    obtain ‚ü®v, hv‚ü© := hh,
    refine ‚ü®v, _‚ü©,
    rw hv at this,
    have h4 :  ‚Üëv * (1 - Œ∑‚ÇÅ) * ‚Üëx = v * x * (1-Œ∑‚ÇÅ) , by {ring},
    rw h4 at this,
    exact this},
  have hel11:  (y : R) * (1 - Œ∑‚ÇÅ) ‚àà P, by {
    obtain ‚ü®v, hv ‚ü©:= hel1,
    rw mul_assoc at hv,
    have hvunit : is_unit (v : R), by {exact units.is_unit v, },
    apply (unit_mul_mem_iff_mem P hvunit).1 _,
    apply hP2,
    apply hv,},
  have hel22 : (x : R) * (1 - Œ∑‚ÇÅ) ‚àà P, by {
      obtain ‚ü®v, hv ‚ü©:= hel2,
    rw mul_assoc at hv,
    have hvunit : is_unit (v : R), by {exact units.is_unit v, },
    apply (unit_mul_mem_iff_mem P hvunit).1 _,
    apply hP2,
    apply hv,
  },
  have hPrime:= hP1.is_prime,
  have hprime2 := is_prime.mem_or_mem hPrime hel11,
  have hprime3 := is_prime.mem_or_mem hPrime hel22,
  have HC : (1 - Œ∑‚ÇÅ) ‚àà P ‚Üí false,
    begin
    intro h,
    have eta_sub_one_ne_zero :=  sub_ne_zero.mpr (ne.symm hwlog),
    have hŒ∑prime : is_prime (ideal.span ({1 - Œ∑‚ÇÅ} : set R)) := by {
      rw span_singleton_prime eta_sub_one_ne_zero,
      apply one_sub_zeta_prime ph hŒ∑‚ÇÅ hwlog,},
    have H5 : is_prime (ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§)), by {
    have h2 : (p : ‚Ñ§) ‚â† 0, by {simp, },
    have h1 : prime (p : ‚Ñ§) , by {simp only [coe_coe], rw  ‚Üêprime_iff_prime_int, exact _inst_4.out,},
    rw (span_singleton_prime h2),
    apply h1,  },
    have hŒ∑P : (ideal.span ({1 - Œ∑‚ÇÅ} : set R)) = P, by {
      have hRdim1 : ring.dimension_le_one R,  by {exact is_dedekind_domain.dimension_le_one,},
      have hle : (ideal.span ({1 - Œ∑‚ÇÅ} : set R)) ‚â§ P, by {rw span_le, simp [h],},
      apply ((@ring.dimension_le_one.prime_le_prime_iff_eq _ _ hRdim1 _ _ hŒ∑prime hPrime _).1 hle),
      simp,
      exact sub_ne_zero.mpr (ne.symm hwlog)},
    have hcapZ : P.comap (int.cast_ring_hom R) = ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§), by {
      have H1 : ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§) ‚â§ P.comap (int.cast_ring_hom R), by {
        rw ‚ÜêhŒ∑P,
        apply le_comap_of_map_le _,
        rw map_span,
        simp,
        rw span_singleton_le_span_singleton,
        apply zeta_sub_one_dvb_p ph hŒ∑‚ÇÅ hwlog},
      have H2 : is_prime (P.comap (int.cast_ring_hom R)),
        by {apply @is_prime.comap _ _ _ _ _ _ _ _ hPrime,},
      have H3 : ring.dimension_le_one ‚Ñ§, by {exact is_dedekind_domain.dimension_le_one, },
      have H4 :  (ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§)) ‚â† ‚ä•, by {simp,},
      apply ((@ring.dimension_le_one.prime_le_prime_iff_eq _ _ H3 _ _ H5 H2 H4).1 H1).symm,},
    have hxyinP : (x + y : R) ‚àà P, by {
      have H1 : (x : R) + Œ∑‚ÇÅ* y ‚àà P, by { apply hiP, apply submodule.mem_span_singleton_self},
      have H2 : Œ∑‚ÇÅ * y = y - y * (1 - Œ∑‚ÇÅ), by {ring},
      rw H2 at H1,
      have H3 : ‚Üëx + (‚Üëy - ‚Üëy * (1 - Œ∑‚ÇÅ)) = (‚Üëx + ‚Üëy) + (-‚Üëy * (1 - Œ∑‚ÇÅ)), by {ring},
      rw H3 at H1,
      have H4 : -‚Üëy * (1 - Œ∑‚ÇÅ) ‚àà P, by {rw ‚ÜêhŒ∑P, rw ideal.mem_span_singleton',
      refine ‚ü®-(y : R), rfl‚ü©, },
      apply (ideal.add_mem_iff_left P H4).1 H1,},
    have hxyinP2 : (x + y ) ‚àà ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§), by {rw ‚ÜêhcapZ, simp [hxyinP]},
    rw mem_span_singleton at hxyinP2,
    apply absurd hxyinP2 hp2,
    end,
  cases hprime2,
  cases hprime3,
  obtain ‚ü®a, b, hab ‚ü© := hp,
  have hone := P.add_mem (ideal.mul_mem_left _ a hprime3) (ideal.mul_mem_left _ b hprime2),
  norm_cast at hone,
  rw hab at hone,
  norm_cast at hone,
  rw ‚Üêeq_top_iff_one at hone,
  have hcontra := is_prime.ne_top hPrime,
  rw hone at hcontra,
  simp only [ne.def, eq_self_iff_true, not_true] at hcontra,
  exact hcontra,
  apply HC hprime3,
  apply HC hprime2,
end

lemma flt_ideals_coprime [fact (p : ‚Ñï).prime] (p5 : 5 ‚â§ p) {x y z : ‚Ñ§}
  (H : x ^ (p : ‚Ñï) + y ^ (p : ‚Ñï) = z ^ (p : ‚Ñï)) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R} (hxy : is_coprime x y)
  (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R) (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ)
  (caseI : ¬¨ ‚Üëp ‚à£ x * y * z) : is_coprime (flt_ideals p x y hŒ∑‚ÇÅ) (flt_ideals p x y hŒ∑‚ÇÇ) :=
begin
   --how does wlog work? I want to have Œ∑‚ÇÅ ‚â† 1...
  by_cases h : Œ∑‚ÇÅ ‚â† 1,
   apply flt_ideals_coprime2 p5 hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hxy _ h,
  sorry,
  have h2 : Œ∑‚ÇÇ ‚â† 1, by {simp at h, rw h at hdiff, exact hdiff.symm},
  have := flt_ideals_coprime2 p5 hŒ∑‚ÇÇ hŒ∑‚ÇÅ hdiff.symm hxy _ h2,
  apply is_coprime.symm,
  exact this,
  sorry,

end
#exit



variable {L}

lemma dvd_last_coeff_cycl_integer [hp : fact (p : ‚Ñï).prime] {Œ∂ : L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ‚Ñ§} {i : fin p} (hf : f i = 0) {m : ‚Ñ§}
  (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) ^ (j : ‚Ñï)) :
  m ‚à£ f ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© :=
begin
  have hlast : (fin.cast (succ_pred_prime hp.out)) (fin.last (p : ‚Ñï).pred) =
    ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := fin.ext rfl,
  have h : ‚àÄ x, (fin.cast (succ_pred_prime hp.out)) (fin.cast_succ x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.out.ne_zero)‚ü© := Œª x, fin.ext rfl,
  have hŒ∂' : is_primitive_root (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) p :=
    is_primitive_root.coe_submonoid_class_iff.1 hŒ∂,
  set b := hŒ∂.integral_power_basis' with hb,
  have hdim : b.dim = (p : ‚Ñï).pred,
  { rw [hŒ∂.power_basis_int'_dim, totient_prime hp.out, pred_eq_sub_one] },

  by_cases H : i = ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü©,
  { simp [H.symm, hf] },
  have hi : ‚Üëi < (p : ‚Ñï).pred,
  { by_contra' habs,
    simpa [le_antisymm habs (le_pred_of_lt (fin.is_lt i))] using H },
  obtain ‚ü®y, hy‚ü© := hdiv,
  rw [‚Üê equiv.sum_comp (fin.cast (succ_pred_prime hp.out)).to_equiv, fin.sum_univ_cast_succ] at hy,
  simp only [hlast, h, rel_iso.coe_fn_to_equiv, fin.coe_mk] at hy,
  rw [hŒ∂'.pow_sub_one_eq hp.out.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (fin.cast hdim).to_equiv.sum_comp] at hy,
  simp only [rel_iso.coe_fn_to_equiv, fin.coe_cast, mul_neg] at hy,
  conv_lhs at hy { congr, skip, funext,
    rw [add_comm, smul_neg, ‚Üê sub_eq_neg_add, ‚Üê sub_smul, ‚Üê hŒ∂.integral_power_basis'_gen,
      ‚Üê hb, ‚Üê show ‚àÄ x, _ = _, from Œª x, congr_fun b.coe_basis x] },
  replace hy := congr_arg (b.basis.coord ((fin.cast hdim.symm) ‚ü®i, hi‚ü©)) hy,
  rw [‚Üê b.basis.equiv_fun_symm_apply, b.basis.coord_equiv_fun_symm] at hy,
  simp only [hf, fin.coe_cast, smul_eq_mul, mul_boole, sum_ite_eq', mem_univ, fin.coe_mk,
    fin.eta, zero_sub, if_true] at hy,
  rw [‚Üê smul_eq_mul, ‚Üê zsmul_eq_smul_cast, neg_eq_iff_neg_eq] at hy,
  obtain ‚ü®n, hn‚ü© := b.basis.coord_dvd_of_dvd ((fin.cast hdim.symm) ‚ü®i, hi‚ü©) y m,
  rw [hn] at hy,
  simp [‚Üê hy, dvd_neg]
end

lemma dvd_coeff_cycl_integer [hp : fact (p : ‚Ñï).prime] {Œ∂ : L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ‚Ñ§} {i : fin p} (hf : f i = 0) {m : ‚Ñ§}
  (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) ^ (j : ‚Ñï)) : ‚àÄ j, m ‚à£ f j :=
begin
  have hlast : (fin.cast (succ_pred_prime hp.out)) (fin.last (p : ‚Ñï).pred) =
    ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := fin.ext rfl,
  have h : ‚àÄ x, (fin.cast (succ_pred_prime hp.out)) (fin.cast_succ x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.out.ne_zero)‚ü© := Œª x, fin.ext rfl,
  have hŒ∂' : is_primitive_root (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) p :=
    is_primitive_root.coe_submonoid_class_iff.1 hŒ∂,
  set b := hŒ∂.integral_power_basis' with hb,
  have hdim : b.dim = (p : ‚Ñï).pred,
  { rw [hŒ∂.power_basis_int'_dim, totient_prime hp.out, pred_eq_sub_one] },
  have last_dvd := dvd_last_coeff_cycl_integer hŒ∂ hf hdiv,

  intro j,
  by_cases H : j = ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü©,
  { simpa [H] using last_dvd },
  have hj : ‚Üëj < (p : ‚Ñï).pred,
  { by_contra' habs,
    simpa [le_antisymm habs (le_pred_of_lt (fin.is_lt j))] using H },
  obtain ‚ü®y, hy‚ü© := hdiv,
  rw [‚Üê equiv.sum_comp (fin.cast (succ_pred_prime hp.out)).to_equiv, fin.sum_univ_cast_succ] at hy,
  simp only [hlast, h, rel_iso.coe_fn_to_equiv, fin.coe_mk] at hy,
  rw [hŒ∂'.pow_sub_one_eq hp.out.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (fin.cast hdim).to_equiv.sum_comp] at hy,
  simp only [rel_iso.coe_fn_to_equiv, fin.coe_cast, mul_neg] at hy,
  conv_lhs at hy { congr, skip, funext,
    rw [add_comm, smul_neg, ‚Üê sub_eq_neg_add, ‚Üê sub_smul, ‚Üê hŒ∂.integral_power_basis'_gen,
      ‚Üê hb, ‚Üê show ‚àÄ x, _ = _, from Œª x, congr_fun b.coe_basis x] },
  replace hy := congr_arg (b.basis.coord ((fin.cast hdim.symm) ‚ü®j, hj‚ü©)) hy,
  rw [‚Üê b.basis.equiv_fun_symm_apply, b.basis.coord_equiv_fun_symm] at hy,
  simp only [fin.cast_mk, fin.coe_mk, fin.eta, basis.coord_apply, sub_eq_iff_eq_add] at hy,
  obtain ‚ü®n, hn‚ü© := b.basis.coord_dvd_of_dvd ((fin.cast hdim.symm) ‚ü®j, hj‚ü©) y m,
  rw [hy, ‚Üê smul_eq_mul, ‚Üê zsmul_eq_smul_cast, ‚Üê b.basis.coord_apply, ‚Üê fin.cast_mk, hn],
  exact dvd_add (dvd_mul_right _ _) last_dvd
end

end int_facts
