import ring_theory.polynomial.eisenstein
import number_theory.cyclotomic.galois_action_on_cyclo
import number_theory.cyclotomic.rat

import ready_for_mathlib.basis

import ready_for_mathlib.is_cyclotomic_extension

universes u

open finite_dimensional polynomial algebra nat finset fintype

variables (p : ‚Ñï+) (L : Type u) [field L] [char_zero L] [is_cyclotomic_extension {p} ‚Ñö L]

section int_facts

noncomputable theory

open_locale number_field big_operators

section to_move

variables {R : Type*} [semiring R] {s t : ideal R}

lemma ideal.add_left_subset  : s ‚â§ s + t := le_sup_left
lemma ideal.add_right_subset : t ‚â§ s + t := le_sup_right

variables {K : Type*} [semiring K]

lemma add_eq_mul_one_add_div {a : KÀ£} {b : K} : ‚Üëa + b = a * (1 + ‚Üëa‚Åª¬π * b) :=
by rwa [mul_add, mul_one, ‚Üê mul_assoc, units.mul_inv, one_mul]

end to_move

open ideal is_cyclotomic_extension

-- TODO refactor add_pow_char_of_commute to use this instead of its own (basically the same) proof
-- TODO is the fact assumption necessary what if p is a prime power?
-- TODO other versions, e.g. one for sub and one for p^n with the
theorem add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute {R : Type*} [semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) (h : commute x y) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
begin
  have : p = p - 1 + 1 := (nat.succ_pred_prime (fact.out _)).symm,
  rw [commute.add_pow h, finset.sum_range_succ_comm, tsub_self, pow_zero, nat.choose_self,
    nat.cast_one, mul_one, mul_one, this, finset.sum_range_succ'],
  simp only [this.symm, tsub_zero, mul_one, one_mul, nat.choose_zero_right, nat.cast_one, pow_zero],
  rw add_comm _ (y ^ p),
  simp_rw add_assoc,
  use (finset.range (p - 1)).sum
    (Œª (x_1 : ‚Ñï), x ^ (x_1 + 1) * y ^ (p - (x_1 + 1)) * ‚Üë(p.choose (x_1 + 1) / p)),
  rw finset.mul_sum,
  congr' 2,
  apply finset.sum_congr rfl,
  intros i hi,
  rw [finset.mem_range] at hi,
  rw [nat.cast_comm, mul_assoc, mul_assoc, mul_assoc],
  congr,
  norm_cast,
  rw nat.div_mul_cancel,
  exact nat.prime.dvd_choose_self (nat.succ_pos _) (lt_tsub_iff_right.mp hi) (fact.out _),
end

theorem add_pow_prime_eq_pow_add_pow_add_prime_mul {R : Type*} [comm_semiring R] (p : ‚Ñï)
  [fact p.prime] (x y : R) : ‚àÉ r : R, (x + y) ^ p = x ^ p + y ^ p + p * r :=
add_pow_prime_eq_pow_add_pow_add_prime_mul_of_commute _ _ _ (commute.all _ _)

-- TODO can we make a relative version of this with another base ring instead of ‚Ñ§ ?
-- A version of flt_facts_3 indep of the ring
lemma exists_int_sub_pow_prime_dvd {A : Type*} [comm_ring A] [is_cyclotomic_extension {p} ‚Ñ§ A]
  [fact (p : ‚Ñï).prime] (a : A) : ‚àÉ (m : ‚Ñ§), (a ^ (p : ‚Ñï) - m) ‚àà span ({p} : set A) :=
begin
  have : a ‚àà algebra.adjoin ‚Ñ§ _ := @adjoin_roots {p} ‚Ñ§ A _ _ _ _ a,
  apply algebra.adjoin_induction this,
  { intros x hx,
    rcases hx with ‚ü®hx_w, hx_m, hx_p‚ü©,
    simp only [set.mem_singleton_iff] at hx_m,
    rw [hx_m] at hx_p,
    simp only [hx_p, coe_coe],
    use 1,
    simp, },
  { intros r,
    use r ^ (p : ‚Ñï),
    simp, },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    obtain ‚ü®r, hr‚ü© := add_pow_prime_eq_pow_add_pow_add_prime_mul p x y,
    rw [hr],
    use c + b,
    push_cast,
    rw [sub_add_eq_sub_sub, sub_eq_add_neg, sub_eq_add_neg, add_comm _ (‚Üë‚Üëp * r),
        add_assoc, add_assoc],
    apply' ideal.add_mem _ _,
    { convert ideal.add_mem _ hb hc using 1,
      ring },
    { rw [mem_span_singleton, coe_coe],
      exact dvd_mul_right _ _ } },
  { rintros x y ‚ü®b, hb‚ü© ‚ü®c, hc‚ü©,
    rw mul_pow,
    use b * c,
    have := ideal.mul_mem_left _ (x ^ (p : ‚Ñï)) hc,
    rw [mul_sub] at this,
    rw [‚Üêideal.quotient.eq_zero_iff_mem, map_sub] at this ‚ä¢ hb,
    convert this using 2,
    rw [int.cast_mul, _root_.map_mul, _root_.map_mul],
    congr' 1,
    exact (sub_eq_zero.mp hb).symm }
end

instance aaaa [fact ((p : ‚Ñï).prime)] : is_cyclotomic_extension {p} ‚Ñ§ (ùìû L) :=
let _ := (zeta_spec p ‚Ñö L).adjoin_is_cyclotomic_extension ‚Ñ§ in
  by exactI is_cyclotomic_extension.equiv {p} (zeta_spec p ‚Ñö L).adjoin_equiv_ring_of_integers'

local notation `R` := ùìû (cyclotomic_field p ‚Ñö)

local attribute [instance] algebra_rat_subsingleton

--This is still annoying
instance [hp : fact ((p : ‚Ñï).prime)] : is_cyclotomic_extension {p} ‚Ñ§ ‚Ü•(ùìû (cyclotomic_field p ‚Ñö)) :=
@aaaa p (cyclotomic_field p ‚Ñö) _ _
  (by { convert cyclotomic_field.is_cyclotomic_extension p ‚Ñö, exact subsingleton.elim _ _ }) _

-- TODO I (alex) am not sure whether this is better as ideal span,
-- or fractional_ideal.span_singleton
/-- The principal ideal generated by `x + y Œ∂^i` for integer `x` and `y` -/
def flt_ideals [fact ((p : ‚Ñï).prime)] (x y : ‚Ñ§) {Œ∑ : R}
  (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R) : ideal R :=
  ideal.span ({ x + Œ∑ * y } : set R)

variable {p} -- why does this not update (n : ‚Ñï+)?

lemma mem_flt_ideals [fact ((p : ‚Ñï).prime)] (x y : ‚Ñ§) {Œ∑ : R}
  (hŒ∑ : Œ∑ ‚àà nth_roots_finset p R) :
  ‚Üëx + Œ∑ * ‚Üëy ‚àà flt_ideals p x y hŒ∑ :=
mem_span_singleton.mpr dvd_rfl

lemma not_coprime_not_top (a b : ideal R) : ¬¨ is_coprime a b ‚Üî a + b ‚â† ‚ä§ :=
begin
 sorry,
end


lemma flt_ideals_coprime2 [fact (p : ‚Ñï).prime] (ph : 5 ‚â§ p) {x y : ‚Ñ§} {Œ∑‚ÇÅ Œ∑‚ÇÇ : R}
  (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R) (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ)
  (hp : is_coprime x y) (hp2 : ¬¨ (p : ‚Ñ§) ‚à£ (x + y : ‚Ñ§) ) :
  is_coprime (flt_ideals p x y hŒ∑‚ÇÅ) (flt_ideals p x y hŒ∑‚ÇÇ) :=
begin
  let I := flt_ideals p x y hŒ∑‚ÇÅ + flt_ideals p x y hŒ∑‚ÇÇ,
  by_contra,
  have he := (not_coprime_not_top p (flt_ideals p x y hŒ∑‚ÇÅ)  (flt_ideals p x y hŒ∑‚ÇÇ)).1 h,
  have := exists_le_maximal I he,
  obtain ‚ü®P, hP1, hP2‚ü©:= this,
  have hiP : (flt_ideals p x y hŒ∑‚ÇÅ) ‚â§ P, by {apply le_trans _ hP2, apply ideal.add_left_subset,},
  have hjP : (flt_ideals p x y hŒ∑‚ÇÇ) ‚â§ P, by {apply le_trans _ hP2, apply ideal.add_right_subset,},
  have hel1: ‚àÉ v : RÀ£, (v : R) * y * (1 - Œ∑‚ÇÅ) ‚àà I, by {
    -- { have := I.add_mem (ideal.add_left_subset $ mem_flt_ideals)
  --                     (ideal.mul_mem_left _ (-1) $ ideal.add_right_subset $ mem_flt_ideals),
  --   simp only [neg_mul, one_mul, neg_add_rev] at this,
  --   rw [neg_mul_eq_mul_neg, add_comm] at this,
  --   simp only [‚Üê add_assoc] at this,
  --   rw [add_assoc _ (-_) _, neg_add_self, add_zero, ‚Üêmul_add, add_comm, add_eq_mul_one_add_div,
  --       ‚Üêzpow_neg] at this,
  --  sorry
    -- I cannot get the tactic state to work here :/

    sorry},
  have hel2 : ‚àÉ v : RÀ£, (v : R) * x * (1 - Œ∑‚ÇÅ) ‚àà I, by {sorry},
  have hel11:  (y : R) * (1 - Œ∑‚ÇÅ) ‚àà P, by {sorry},
  have hel22 : (x : R) * (1 - Œ∑‚ÇÅ) ‚àà P, by {sorry},
  have hPrime:= hP1.is_prime,
  have hprime2 := is_prime.mem_or_mem hPrime hel11,
  have hprime3 := is_prime.mem_or_mem hPrime hel22,
  cases hprime2,
  cases hprime3,
  obtain ‚ü®a, b, hab ‚ü© := hp,
  have hone := P.add_mem (ideal.mul_mem_left _ a hprime3) (ideal.mul_mem_left _ b hprime2),
  norm_cast at hone,
  rw hab at hone,
  norm_cast at hone,
  rw ‚Üêeq_top_iff_one at hone,
  have hcontra := is_prime.ne_top hPrime,
  rw hone at hcontra,
  simp only [ne.def, eq_self_iff_true, not_true] at hcontra,
  exact hcontra,
  have hŒ∑prime : is_prime (ideal.span ({1 - Œ∑‚ÇÅ} : set R)) := by {sorry},
  have hŒ∑P : (ideal.span ({1 - Œ∑‚ÇÅ} : set R)) = P, by {sorry},
  have hcapZ : P.comap (int.cast_ring_hom R) = ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§), by {
    have H1 : ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§) ‚â§ P.comap (int.cast_ring_hom R), by {sorry},


    sorry},
  have hxyinP : (x + y : R) ‚àà P, by {
    have H1 : (x : R) + Œ∑‚ÇÅ* y ‚àà P, by { apply hiP, apply submodule.mem_span_singleton_self},
    have H2 : Œ∑‚ÇÅ * y = y - y * (1 - Œ∑‚ÇÅ), by {ring},
    rw H2 at H1,
    have H3 : ‚Üëx + (‚Üëy - ‚Üëy * (1 - Œ∑‚ÇÅ)) = (‚Üëx + ‚Üëy) + (-‚Üëy * (1 - Œ∑‚ÇÅ)), by {ring},
    rw H3 at H1,
    have H4 : -‚Üëy * (1 - Œ∑‚ÇÅ) ‚àà P, by {rw ‚ÜêhŒ∑P, rw ideal.mem_span_singleton',
    refine ‚ü®-(y : R), rfl‚ü©, },
    apply (ideal.add_mem_iff_left P H4).1 H1,},
  have hxyinP2 : (x + y ) ‚àà ideal.span ({(p : ‚Ñ§)} : set ‚Ñ§), by {rw ‚ÜêhcapZ, simp [hxyinP]},
  rw mem_span_singleton at hxyinP2,
  apply absurd hxyinP2 hp2,
  sorry,
  --same as the sorry above
end

lemma flt_ideals_coprime [fact (p : ‚Ñï).prime] (p5 : 5 ‚â§ p) {x y z : ‚Ñ§}
  (H : x ^ (p : ‚Ñï) + y ^ (p : ‚Ñï) = z ^ (p : ‚Ñï)) {Œ∑‚ÇÅ Œ∑‚ÇÇ : R} (hxy : is_coprime x y)
  (hŒ∑‚ÇÅ : Œ∑‚ÇÅ ‚àà nth_roots_finset p R) (hŒ∑‚ÇÇ : Œ∑‚ÇÇ ‚àà nth_roots_finset p R) (hdiff : Œ∑‚ÇÅ ‚â† Œ∑‚ÇÇ)
  (caseI : ¬¨ ‚Üëp ‚à£ x * y * z) : is_coprime (flt_ideals p x y hŒ∑‚ÇÅ) (flt_ideals p x y hŒ∑‚ÇÇ) :=
begin
   apply flt_ideals_coprime2 p5 hŒ∑‚ÇÅ hŒ∑‚ÇÇ hdiff hxy _,
  sorry,


end




variable {L}

lemma dvd_last_coeff_cycl_integer [hp : fact (p : ‚Ñï).prime] {Œ∂ : L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ‚Ñ§} {i : fin p} (hf : f i = 0) {m : ‚Ñ§}
  (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) ^ (j : ‚Ñï)) :
  m ‚à£ f ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© :=
begin
  have hlast : (fin.cast (succ_pred_prime hp.out)) (fin.last (p : ‚Ñï).pred) =
    ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := fin.ext rfl,
  have h : ‚àÄ x, (fin.cast (succ_pred_prime hp.out)) (fin.cast_succ x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.out.ne_zero)‚ü© := Œª x, fin.ext rfl,
  have hŒ∂' : is_primitive_root (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) p :=
    is_primitive_root.coe_submonoid_class_iff.1 hŒ∂,
  set b := hŒ∂.integral_power_basis' with hb,
  have hdim : b.dim = (p : ‚Ñï).pred,
  { rw [hŒ∂.power_basis_int'_dim, totient_prime hp.out, pred_eq_sub_one] },

  by_cases H : i = ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü©,
  { simp [H.symm, hf] },
  have hi : ‚Üëi < (p : ‚Ñï).pred,
  { by_contra' habs,
    simpa [le_antisymm habs (le_pred_of_lt (fin.is_lt i))] using H },
  obtain ‚ü®y, hy‚ü© := hdiv,
  rw [‚Üê equiv.sum_comp (fin.cast (succ_pred_prime hp.out)).to_equiv, fin.sum_univ_cast_succ] at hy,
  simp only [hlast, h, rel_iso.coe_fn_to_equiv, fin.coe_mk] at hy,
  rw [hŒ∂'.pow_sub_one_eq hp.out.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (fin.cast hdim).to_equiv.sum_comp] at hy,
  simp only [rel_iso.coe_fn_to_equiv, fin.coe_cast, mul_neg] at hy,
  conv_lhs at hy { congr, skip, funext,
    rw [add_comm, smul_neg, ‚Üê sub_eq_neg_add, ‚Üê sub_smul, ‚Üê hŒ∂.integral_power_basis'_gen,
      ‚Üê hb, ‚Üê show ‚àÄ x, _ = _, from Œª x, congr_fun b.coe_basis x] },
  replace hy := congr_arg (b.basis.coord ((fin.cast hdim.symm) ‚ü®i, hi‚ü©)) hy,
  rw [‚Üê b.basis.equiv_fun_symm_apply, b.basis.coord_equiv_fun_symm] at hy,
  simp only [hf, fin.coe_cast, smul_eq_mul, mul_boole, sum_ite_eq', mem_univ, fin.coe_mk,
    fin.eta, zero_sub, if_true] at hy,
  rw [‚Üê smul_eq_mul, ‚Üê zsmul_eq_smul_cast, neg_eq_iff_neg_eq] at hy,
  obtain ‚ü®n, hn‚ü© := b.basis.coord_dvd_of_dvd ((fin.cast hdim.symm) ‚ü®i, hi‚ü©) y m,
  rw [hn] at hy,
  simp [‚Üê hy, dvd_neg]
end

lemma dvd_coeff_cycl_integer [hp : fact (p : ‚Ñï).prime] {Œ∂ : L} (hŒ∂ : is_primitive_root Œ∂ p)
  {f : fin p ‚Üí ‚Ñ§} {i : fin p} (hf : f i = 0) {m : ‚Ñ§}
  (hdiv : ‚Üëm ‚à£ ‚àë j, f j ‚Ä¢ (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) ^ (j : ‚Ñï)) : ‚àÄ j, m ‚à£ f j :=
begin
  have hlast : (fin.cast (succ_pred_prime hp.out)) (fin.last (p : ‚Ñï).pred) =
    ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü© := fin.ext rfl,
  have h : ‚àÄ x, (fin.cast (succ_pred_prime hp.out)) (fin.cast_succ x) =
    ‚ü®x, lt_trans x.2 (pred_lt hp.out.ne_zero)‚ü© := Œª x, fin.ext rfl,
  have hŒ∂' : is_primitive_root (‚ü®Œ∂, hŒ∂.is_integral p.pos‚ü© : ùìû L) p :=
    is_primitive_root.coe_submonoid_class_iff.1 hŒ∂,
  set b := hŒ∂.integral_power_basis' with hb,
  have hdim : b.dim = (p : ‚Ñï).pred,
  { rw [hŒ∂.power_basis_int'_dim, totient_prime hp.out, pred_eq_sub_one] },
  have last_dvd := dvd_last_coeff_cycl_integer hŒ∂ hf hdiv,

  intro j,
  by_cases H : j = ‚ü®(p : ‚Ñï).pred, pred_lt hp.out.ne_zero‚ü©,
  { simpa [H] using last_dvd },
  have hj : ‚Üëj < (p : ‚Ñï).pred,
  { by_contra' habs,
    simpa [le_antisymm habs (le_pred_of_lt (fin.is_lt j))] using H },
  obtain ‚ü®y, hy‚ü© := hdiv,
  rw [‚Üê equiv.sum_comp (fin.cast (succ_pred_prime hp.out)).to_equiv, fin.sum_univ_cast_succ] at hy,
  simp only [hlast, h, rel_iso.coe_fn_to_equiv, fin.coe_mk] at hy,
  rw [hŒ∂'.pow_sub_one_eq hp.out.one_lt, ‚Üê sum_neg_distrib, smul_sum, sum_range, ‚Üê sum_add_distrib,
    ‚Üê (fin.cast hdim).to_equiv.sum_comp] at hy,
  simp only [rel_iso.coe_fn_to_equiv, fin.coe_cast, mul_neg] at hy,
  conv_lhs at hy { congr, skip, funext,
    rw [add_comm, smul_neg, ‚Üê sub_eq_neg_add, ‚Üê sub_smul, ‚Üê hŒ∂.integral_power_basis'_gen,
      ‚Üê hb, ‚Üê show ‚àÄ x, _ = _, from Œª x, congr_fun b.coe_basis x] },
  replace hy := congr_arg (b.basis.coord ((fin.cast hdim.symm) ‚ü®j, hj‚ü©)) hy,
  rw [‚Üê b.basis.equiv_fun_symm_apply, b.basis.coord_equiv_fun_symm] at hy,
  simp only [fin.cast_mk, fin.coe_mk, fin.eta, basis.coord_apply, sub_eq_iff_eq_add] at hy,
  obtain ‚ü®n, hn‚ü© := b.basis.coord_dvd_of_dvd ((fin.cast hdim.symm) ‚ü®j, hj‚ü©) y m,
  rw [hy, ‚Üê smul_eq_mul, ‚Üê zsmul_eq_smul_cast, ‚Üê b.basis.coord_apply, ‚Üê fin.cast_mk, hn],
  exact dvd_add (dvd_mul_right _ _) last_dvd
end

end int_facts
