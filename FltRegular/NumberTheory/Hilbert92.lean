import FltRegular.NumberTheory.Cyclotomic.UnitLemmas
import FltRegular.NumberTheory.SystemOfUnits
import Mathlib.RingTheory.IntegralClosure.IntegralRestrict
import Mathlib.Algebra.Lie.OfAssociative
import Mathlib.Data.Int.Star
import Mathlib.NumberTheory.NumberField.Units.DirichletTheorem
import Mathlib.Order.CompletePartialOrder
import Mathlib.RingTheory.Henselian
import Mathlib.LinearAlgebra.Dimension.Torsion.Basic
import Mathlib.LinearAlgebra.Dimension.Torsion.Finite
import Mathlib.GroupTheory.FiniteAbelian.Basic

open scoped NumberField nonZeroDivisors
open FiniteDimensional NumberField

variable {s r : ‚Ñï} (p : ‚Ñï+) {K : Type*} [Field K]
variable {k : Type*} [Field k] (hp : Nat.Prime p)

open Module BigOperators Finset
open CyclotomicIntegers (zeta)

section thm91
variable (G : Type*) [AddCommGroup G]

local notation3 "A" => CyclotomicIntegers p

/-The system of units is maximal if the quotient by its span leaves a torsion module (i.e. finite) -/
abbrev systemOfUnits.IsMaximal {p : ‚Ñï+} {G : Type*} [AddCommGroup G]
    [Module (CyclotomicIntegers p) G] (sys : systemOfUnits (G := G) p s) :=
  Fintype (G ‚ß∏ Submodule.span (CyclotomicIntegers p) (Set.range sys.units))

noncomputable
def systemOfUnits.isMaximal [Module.Finite ‚Ñ§ G] (hf : finrank ‚Ñ§ G = s * (p - 1))
  [Module A G] (sys : systemOfUnits (G := G) p s) : sys.IsMaximal := by
  apply Nonempty.some
  apply (@nonempty_fintype _ ?_)
  apply Module.finite_of_fg_torsion
  rw [‚Üê finrank_eq_zero_iff_isTorsion, Submodule.finrank_quotient,
    finrank_spanA p hp _ _ sys.linearIndependent, hf, mul_comm, Nat.sub_self]

noncomputable
def systemOfUnits.index [Module A G] (sys : systemOfUnits p G s) [sys.IsMaximal] :=
  Fintype.card (G ‚ß∏ Submodule.span A (Set.range sys.units))

/-- A system of units is fundamental if it's maximal and the submodule generated by the elements
of the system has smallest index. -/
def systemOfUnits.IsFundamental [Module A G] (h : systemOfUnits p G s) :=
  ‚àÉ _ : h.IsMaximal, ‚àÄ (S : systemOfUnits p G s) (_ : S.IsMaximal), h.index ‚â§ S.index

lemma systemOfUnits.IsFundamental.maximal' [Module A G] (S : systemOfUnits p G r)
    (hs : S.IsFundamental) (a : systemOfUnits p G r) [a.IsMaximal] :
    (Submodule.span A (Set.range S.units)).toAddSubgroup.index ‚â§
      (Submodule.span A (Set.range a.units)).toAddSubgroup.index := by
  letI := hs.choose
  convert hs.choose_spec a ‚Äπ_‚Ä∫ <;> symm <;> exact Nat.card_eq_fintype_card.symm

@[simps]
noncomputable
def Finsupp.ltotal (Œ± M R) [CommSemiring R] [AddCommMonoid M] [Module R M] :
    (Œ± ‚Üí M) ‚Üí‚Çó[R] (Œ± ‚Üí‚ÇÄ R) ‚Üí‚Çó[R] M where
  toFun := Finsupp.linearCombination R
  map_add' := fun u v ‚Ü¶ by ext f; simp
  map_smul' := fun r v ‚Ü¶ by ext f; simp

lemma Finsupp.total_pi_single {Œ± M R} [CommSemiring R] [AddCommMonoid M] [Module R M]
    [DecidableEq Œ±] (i : Œ±) (m : M) (f : Œ± ‚Üí‚ÇÄ R) :
    Finsupp.linearCombination R (Pi.single i m) f = f i ‚Ä¢ m := by
  simp only [Finsupp.linearCombination, ne_eq, Pi.single_apply, coe_lsum, LinearMap.coe_smulRight,
    LinearMap.id_coe, id_eq, smul_ite, smul_zero, sum_ite_eq', mem_support_iff, ite_eq_left_iff,
    not_not]
  exact fun e ‚Ü¶ e ‚ñ∏ (zero_smul R m).symm

lemma LinearIndependent.update {Œπ} [DecidableEq Œπ] {R} [CommRing R] [Module R G]
    (f : Œπ ‚Üí G) (l : Œπ ‚Üí‚ÇÄ R) (i : Œπ) (g : G) (œÉ : R)
    (hœÉ : œÉ ‚àà nonZeroDivisors R) (hg : œÉ ‚Ä¢ g = Finsupp.linearCombination R f l)
    (hl : l i ‚àà nonZeroDivisors R) (hf : LinearIndependent R f) :
    LinearIndependent R (Function.update f i g) := by
  classical
  rw [linearIndependent_iff] at hf ‚ä¢
  intros l' hl'
  apply_fun (œÉ ‚Ä¢ ¬∑) at hl'
  rw [Pi.update_eq_sub_add_single, ‚Üê Finsupp.ltotal_apply, map_add, map_sub] at hl'
  simp only [Finsupp.ltotal_apply, LinearMap.add_apply, LinearMap.sub_apply,
    Finsupp.total_pi_single, smul_add, smul_sub, smul_zero] at hl'
  rw [smul_comm œÉ (l' i) g, hg, ‚Üê LinearMap.map_smul, ‚Üê LinearMap.map_smul, smul_smul,
    ‚Üê Finsupp.linearCombination_single, ‚Üê (Finsupp.linearCombination R f).map_sub, ‚Üê map_add] at hl'
  replace hl' : ‚àÄ j, (œÉ * l' j - (Finsupp.single i (œÉ * l' i)) j) + l' i * l j = 0 := by
    intro j
    exact DFunLike.congr_fun (hf _ hl') j
  simp only [Finsupp.single_apply] at hl'
  have : l' i = 0 := hl _ (by simpa using hl' i)
  simp only [this, zero_mul, add_zero, mul_zero, ite_self, sub_zero] at hl'
  ext j
  exact hœÉ _ ((mul_comm _ _).trans (hl' j))

namespace systemOfUnits.IsFundamental

variable {H : Type*} [CommGroup H] [Fintype H]
  (hCard : Fintype.card H = p) (œÉ : H) (hœÉ : Subgroup.zpowers œÉ = ‚ä§) (s : ‚Ñï) [DistribMulAction H G]
  (hf : finrank ‚Ñ§ G = s * (p - 1))

include hp hf

variable [Module.Finite ‚Ñ§ G]

/-there exists an fundamental set of units.-/
lemma existence [Module.Free ‚Ñ§ G] [Module A G] :
    ‚àÉ S : systemOfUnits p G s, S.IsFundamental := by
  obtain ‚ü®S‚ü© := systemOfUnits.existence p hp G s hf
  letI := S.isMaximal p hp G hf
  have : { a | ‚àÉ (S : systemOfUnits p G s) (_ : S.IsMaximal), a = S.index p G }.Nonempty :=
    ‚ü®S.index, S, S.isMaximal p hp G hf, rfl‚ü©
  obtain ‚ü®S', hS', ha‚ü© := Nat.sInf_mem this
  use S', hS'
  intro a' ha'
  rw [‚Üê ha]
  apply csInf_le (OrderBot.bddBelow _)
  use a', ha'

lemma lemma2 [Module A G] (S : systemOfUnits p G s) (hs : S.IsFundamental)
    (i : Fin s) (a : Fin s ‚Üí‚ÇÄ A) (ha : a i = 1) :
    ‚àÄ g : G, (1 - zeta p) ‚Ä¢ g ‚â† Finsupp.linearCombination A S.units a := by
  cases' s with s
  ¬∑ exact isEmptyElim i
  intro g hg
  letI := Fact.mk hp
  let S' : systemOfUnits p G (s + 1) := ‚ü®Function.update S.units i g,
    LinearIndependent.update _ _ _ _ _ _ (CyclotomicIntegers.one_sub_zeta_mem_nonZeroDivisors p)
    hg (ha ‚ñ∏ one_mem A‚Å∞) S.linearIndependent‚ü©
  let a' := a.comapDomain (Fin.succAbove i) Fin.succAbove_right_injective.injOn
  have hS' : S'.units ‚àò Fin.succAbove i = S.units ‚àò Fin.succAbove i := by
    ext; simp only [Function.comp_apply, ne_eq, Fin.succAbove_ne, not_false_eq_true,
      Function.update_of_ne, S']
  have ha' :
      Finsupp.linearCombination A (S'.units ‚àò Fin.succAbove i) a' + S.units i = (1 - zeta p) ‚Ä¢ g := by
    rw [hS', Finsupp.linearCombination_comp, LinearMap.comp_apply, Finsupp.lmapDomain_apply,
      ‚Üê one_smul A (S.units i), hg, ‚Üê ha, ‚Üê Finsupp.linearCombination_single, ‚Üê map_add]
    congr 1
    ext j
    rw [Finsupp.coe_add, Pi.add_apply, Finsupp.single_apply]
    have : i = j ‚Üî j ‚àâ Set.range (Fin.succAbove i) := by simp [@eq_comm _ i]
    split_ifs with hij
    ¬∑ rw [Finsupp.mapDomain_notin_range, zero_add, hij]
      rwa [‚Üê this]
    ¬∑ obtain ‚ü®j, rfl‚ü© := not_imp_comm.mp this.mpr hij
      rw [Finsupp.mapDomain_apply Fin.succAbove_right_injective, add_zero,
        Finsupp.comapDomain_apply]
  letI := S'.isMaximal p hp G hf
  suffices Submodule.span A (Set.range S.units) < Submodule.span A (Set.range S'.units) by
    have : (Submodule.span A (Set.range S.units)).toAddSubgroup.FiniteIndex :=
      ‚ü®AddSubgroup.index_ne_zero_of_finite (hH := (S.isMaximal _ hp _ hf).finite)‚ü©
    exact (hs.maximal' _ _ _ S').not_lt <| AddSubgroup.index_strictAnti ‚Äπ_‚Ä∫
  rw [SetLike.lt_iff_le_and_exists]
  constructor
  ¬∑ rw [Submodule.span_le]
    rintro _ ‚ü®j, rfl‚ü©
    by_cases hij : i = j
    ¬∑ rw [add_comm, ‚Üê eq_sub_iff_add_eq] at ha'
      rw [‚Üê hij, ha']
      apply sub_mem
      ¬∑ exact Submodule.smul_mem _ _ (Submodule.subset_span ‚ü®i, Function.update_self _ _ _‚ü©)
      ¬∑ rw [‚Üê Finsupp.range_linearCombination, Finsupp.linearCombination_comp, LinearMap.comp_apply]
        exact ‚ü®_, rfl‚ü©
    ¬∑ exact Submodule.subset_span ‚ü®j, Function.update_of_ne (Ne.symm hij) _ _‚ü©
  ¬∑ refine ‚ü®g, Submodule.subset_span ‚ü®i, Function.update_self _ _ _‚ü©, ?_‚ü©
    rw [‚Üê Finsupp.range_linearCombination]
    rintro ‚ü®l, rfl‚ü©
    letI := (Algebra.id A).toModule
    letI : SMulZeroClass A A := SMulWithZero.toSMulZeroClass
    letI : Module A (Fin s ‚Üí‚ÇÄ A) := Finsupp.module (Fin s) A
    rw [‚Üê LinearMap.map_smul, ‚Üê sub_eq_zero,
      ‚Üê (Finsupp.linearCombination A S.units).map_sub] at hg
    have := DFunLike.congr_fun (linearIndependent_iff.mp S.linearIndependent _ hg) i
    simp only [algebraMap_int_eq, Int.coe_castRingHom, Finsupp.coe_sub, Finsupp.coe_smul, ha,
      Pi.sub_apply, Finsupp.mapRange_apply, Finsupp.coe_zero, Pi.zero_apply, sub_eq_zero] at this
    exact CyclotomicIntegers.not_isUnit_one_sub_zeta p
      (isUnit_of_mul_eq_one _ _ this)

lemma corollary [Module A G] (S : systemOfUnits p G s) (hs : S.IsFundamental) (a : Fin s ‚Üí ‚Ñ§)
    (ha : ‚àÉ i , ¬¨ (p : ‚Ñ§) ‚à£ a i) :
    ‚àÄ g : G, (1 - zeta p) ‚Ä¢ g ‚â† ‚àë i, a i ‚Ä¢ S.units i := by
  intro g hg
  obtain ‚ü®i, hi‚ü© := ha
  letI := Fact.mk hp
  obtain ‚ü®x, y, e‚ü© := CyclotomicIntegers.isCoprime_one_sub_zeta p (a i) hi
  let b' : Fin s ‚Üí A := fun j ‚Ü¶ x * (1 - zeta ‚Üëp) + y * (a j)
  let b := Finsupp.ofSupportFinite b' (Set.toFinite (Function.support _))
  have hb : b i = 1 := by rw [‚Üê e]; rfl
  apply lemma2 p hp G s hf S hs i b hb (x ‚Ä¢ ‚àë i, S.units i + y ‚Ä¢ g)
  rw [smul_add, smul_smul _ y, mul_comm, ‚Üê smul_smul, hg, smul_sum, smul_sum, smul_sum,
    ‚Üê sum_add_distrib, Finsupp.linearCombination_apply, Finsupp.sum_fintype]
  congr
  ¬∑ ext j
    simp only [smul_smul, Finsupp.ofSupportFinite_coe, add_smul, b', b]
    congr 1
    ¬∑ rw [mul_comm]
    ¬∑ rw [‚Üê Int.cast_smul_eq_zsmul (R := A), smul_smul]
  ¬∑ simp

end systemOfUnits.IsFundamental
section application

variable
    [Algebra k K] (hKL : finrank k K = p) (œÉ : K ‚âÉ‚Çê[k] K)
    (hœÉ : ‚àÄ x, x ‚àà Subgroup.zpowers œÉ)

def RelativeUnits (k K : Type*) [Field k] [Field K] [Algebra k K] :=
  ((ùìû K)À£ ‚ß∏ (MonoidHom.range <| Units.map (algebraMap (ùìû k) (ùìû K) : (ùìû k) ‚Üí* (ùìû K))))

instance : CommGroup (RelativeUnits k K) := by delta RelativeUnits; infer_instance

instance : IsScalarTower (ùìû k) (ùìû K) K := IsScalarTower.of_algebraMap_eq (fun _ ‚Ü¶ rfl)

section

lemma RingOfInteger.coe_algebraMap_apply {x : ùìû k} :
  (algebraMap (ùìû k) (ùìû K) x : K) = algebraMap k K x := rfl

-- TODO move Mathlib.GroupTheory.OrderOfElement
lemma pow_finEquivZPowers_symm_apply {M} [Group M] (x : M) (hx) (a : Subgroup.zpowers x) :
    x ^ ((finEquivZPowers hx).symm a : ‚Ñï) = a :=
  congr_arg Subtype.val ((finEquivZPowers hx).apply_symm_apply a)

lemma norm_eq_prod_pow_gen
    [IsGalois k K] [FiniteDimensional k K]
    (œÉ : K ‚âÉ‚Çê[k] K) (hœÉ : ‚àÄ x, x ‚àà Subgroup.zpowers œÉ) (Œ∑ : K) :
    algebraMap k K (Algebra.norm k Œ∑) = (‚àè i ‚àà Finset.range (orderOf œÉ), (œÉ ^ i) Œ∑)   := by
  let _ : Fintype (Subgroup.zpowers œÉ) := inferInstance
  rw [Algebra.norm_eq_prod_automorphisms, ‚Üê Fin.prod_univ_eq_prod_range,
    ‚Üê (finEquivZPowers <| isOfFinOrder_of_finite _).symm.prod_comp]
  simp only [pow_finEquivZPowers_symm_apply]
  rw [prod_subtype]
  simp [hœÉ]

include hKL in
lemma Hilbert92_aux0 (h : ‚Ñï) (ŒΩ : (ùìû k)À£) (hŒΩ : IsPrimitiveRoot (ŒΩ : k) (p ^ h))
  (H : ‚àÄ Œµ : (ùìû K)À£, algebraMap k K ŒΩ ^ ((p : ‚Ñï) ^ (h - 1)) ‚â† Œµ / (œÉ Œµ : K)) :
    ‚àÉ Œ∑ : (ùìû K)À£, Algebra.norm k (Œ∑ : K) = 1 ‚àß ‚àÄ Œµ : (ùìû K)À£, (Œ∑ : K) ‚â† Œµ / (œÉ Œµ : K) := by
  let Œ∑ := (Units.map (algebraMap (ùìû k) (ùìû K)) ŒΩ : (ùìû K)À£)
  use Œ∑ ^ ((p : ‚Ñï) ^ (h - 1))
  refine ‚ü®?_, fun Œµ => H Œµ‚ü©
  simp only [ge_iff_le, Units.val_pow_eq_pow_val, Units.coe_map,
    MonoidHom.coe_coe, SubmonoidClass.coe_pow, map_pow]
  show (Algebra.norm k) ((algebraMap k K) _) ^ _ = 1
  rw [Algebra.norm_algebraMap, hKL, ‚Üê pow_mul]
  nth_rewrite 1 [‚Üê pow_one (p : ‚Ñï)]
  rw [‚Üê pow_add]
  apply (hŒΩ.pow_eq_one_iff_dvd _).2
  cases h <;> simp [add_comm]

variable [NumberField K]

instance : IsIntegralClosure (ùìû K) (ùìû k) K := by
  have : Algebra.IsIntegral (ùìû k) (ùìû K) := ‚ü®fun _ ‚Ü¶ .tower_top (IsIntegralClosure.isIntegral ‚Ñ§ K _)‚ü©
  apply IsIntegralClosure.of_isIntegrallyClosed

variable [NumberField k]

lemma coe_galRestrictHom_apply (œÉ : K ‚Üí‚Çê[k] K) (x) :
    (galRestrictHom (ùìû k) k K (ùìû K) œÉ x : K) = œÉ x :=
  algebraMap_galRestrictHom_apply (ùìû k) k K (ùìû K) œÉ x

noncomputable
def relativeUnitsMap (œÉ : K ‚Üí‚Çê[k] K) : RelativeUnits k K ‚Üí* RelativeUnits k K := by
  apply QuotientGroup.lift _
    ((QuotientGroup.mk' _).comp (Units.map (galRestrictHom (ùìû k) k K (ùìû K) œÉ)))
  rintro _ ‚ü®i, rfl‚ü©
  simp only [MonoidHom.mem_ker, MonoidHom.coe_comp, QuotientGroup.coe_mk', Function.comp_apply,
    QuotientGroup.eq_one_iff, MonoidHom.mem_range, Units.ext_iff, Units.coe_map, MonoidHom.coe_coe,
    AlgHom.commutes, exists_apply_eq_apply]

lemma relativeUnitsMap_mk (œÉ : K ‚Üí‚Çê[k] K) (x : (ùìû K)À£) :
    relativeUnitsMap œÉ (QuotientGroup.mk x) =
      QuotientGroup.mk (Units.map (galRestrictHom (ùìû k) k K (ùìû K) œÉ) x) := rfl

@[simps]
noncomputable
def relativeUnitsMapHom : (K ‚Üí‚Çê[k] K) ‚Üí* (Monoid.End (RelativeUnits k K)) where
  toFun := relativeUnitsMap
  map_one' := by
    refine DFunLike.ext _ _ (fun x ‚Ü¶ ?_)
    obtain ‚ü®x, rfl‚ü© := QuotientGroup.mk_surjective x
    rw [relativeUnitsMap]
    erw [QuotientGroup.lift_mk']
    simp only [map_one, MonoidHom.coe_comp, QuotientGroup.coe_mk', Function.comp_apply]
    rfl
  map_mul' := by
    intros f g
    refine DFunLike.ext _ _ (fun x ‚Ü¶ ?_)
    obtain ‚ü®x, rfl‚ü© := QuotientGroup.mk_surjective x
    simp only [relativeUnitsMap, map_mul, Function.comp_apply]
    rfl

include œÉ hp hKL hœÉ in
open Polynomial in
lemma isTors' [IsGalois k K] : Module.IsTorsionBySet ‚Ñ§[X]
    (Module.AEval' (addMonoidEndRingEquivInt _
      (MulEquiv.Monoid.End <| relativeUnitsMap <| ((AlgEquiv.algHomUnitsEquiv _ _).symm œÉ).val)))
    (Ideal.span {cyclotomic p ‚Ñ§}) := by
  classical
  have := Fact.mk hp
  rw [‚Üê Module.isTorsionBySet_iff_is_torsion_by_span, Module.isTorsionBySet_singleton_iff]
  intro x
  obtain ‚ü®x, rfl‚ü© := (Module.AEval.of _ _ _).surjective x
  obtain ‚ü®x, rfl‚ü© := Additive.ofMul.surjective x
  obtain ‚ü®x, rfl‚ü© := QuotientGroup.mk_surjective x
  rw [‚Üê Module.AEval.of_aeval_smul]
  simp_rw [LinearMap.smul_def, Polynomial.cyclotomic_prime ‚Ñ§ p, EmbeddingLike.map_eq_zero_iff,
    map_sum, map_pow, aeval_X, LinearMap.coeFn_sum, sum_apply]
  conv =>
    enter [1, 2, c]
    rw [‚Üê relativeUnitsMapHom_apply, ‚Üê map_pow, ‚Üê map_pow, ‚Üê map_pow, ‚Üê Units.val_pow_eq_pow_val,
      ‚Üê map_pow, AlgEquiv.val_algHomUnitsEquiv_symm_apply, relativeUnitsMapHom_apply,
      MulEquiv.Monoid.End_apply, addMonoidEndRingEquivInt_apply, AddHom.toFun_eq_coe,
      LinearMap.coe_toAddHom, LinearEquiv.coe_coe, addMonoidHomLequivInt_apply,
      AddMonoidHom.coe_toIntLinearMap, AddMonoidHom.coe_mk, ZeroHom.coe_mk, toMul_ofMul,
      relativeUnitsMap_mk]
  rw [‚Üê ofMul_prod, ‚Üê QuotientGroup.mk_prod, ofMul_eq_zero, QuotientGroup.eq_one_iff]
  use Units.map (RingOfIntegers.norm k) x
  ext
  simp only [Units.coe_map, MonoidHom.coe_coe, RingOfIntegers.coe_algebraMap_norm, map_pow,
    Units.coe_prod, Submonoid.coe_finset_prod, Subsemiring.coe_toSubmonoid,
    Subalgebra.coe_toSubsemiring, Algebra.norm_eq_prod_automorphisms]
  rw [‚Üê hKL, ‚Üê IsGalois.card_aut_eq_finrank, Fintype.card_eq_nat_card,
    ‚Üê orderOf_eq_card_of_forall_mem_zpowers hœÉ, ‚Üê Fin.prod_univ_eq_prod_range,
    ‚Üê (finEquivZPowers <| isOfFinOrder_of_finite _).symm.prod_comp]
  simp only [pow_finEquivZPowers_symm_apply, coe_galRestrictHom_apply, AlgHom.coe_coe, map_prod,
    NumberField.RingOfIntegers.coe_eq_algebraMap]
  rw [prod_subtype]
  simp only [mem_univ, hœÉ, implies_true]

@[nolint unusedArguments]
def relativeUnitsWithGenerator (_hp : Nat.Prime p)
  (_hKL : finrank k K = p) (œÉ : K ‚âÉ‚Çê[k] K) (_hœÉ : ‚àÄ x, x ‚àà Subgroup.zpowers œÉ) : Type _ :=
  RelativeUnits k K

instance : CommGroup (relativeUnitsWithGenerator p hp hKL œÉ hœÉ) := by
  delta relativeUnitsWithGenerator; infer_instance

end

local notation "G" =>
  Additive (relativeUnitsWithGenerator p hp hKL œÉ hœÉ) ‚ß∏
    AddCommGroup.torsion (Additive (relativeUnitsWithGenerator p hp hKL œÉ hœÉ))

def unit_to_U (u : (ùìû K)À£) : G := QuotientAddGroup.mk (Additive.ofMul <| QuotientGroup.mk u)

local notation "mkG" => unit_to_U p hp hKL œÉ hœÉ

lemma unit_to_U_one : mkG 1 = 0 := by
  rw [unit_to_U, QuotientGroup.mk_one, ofMul_one, QuotientAddGroup.mk_zero]

lemma unit_to_U_mul (x y) : mkG (x * y) = mkG x + mkG y := by
  rw [unit_to_U, unit_to_U, unit_to_U, QuotientGroup.mk_mul, ofMul_mul, QuotientAddGroup.mk_add]

lemma unit_to_U_inv (x) : mkG (x‚Åª¬π) = - mkG x := by
  rw [eq_neg_iff_add_eq_zero, ‚Üê unit_to_U_mul, inv_mul_cancel, unit_to_U_one]

lemma unit_to_U_div (x y) : mkG (x / y) = mkG x - mkG y := by
  rw [div_eq_mul_inv, unit_to_U_mul, unit_to_U_inv, sub_eq_add_neg]

lemma unit_to_U_prod {Œπ} (s : Finset Œπ) (f : Œπ ‚Üí _) :
    mkG (‚àè i ‚àà s, f i) = ‚àë i ‚àà s, mkG (f i) := by
  classical
  induction s using Finset.induction with
  | empty => simp only [prod_empty, sum_empty, unit_to_U_one]
  | @insert x s hxs IH =>
    simp only [hxs, not_false_eq_true, prod_insert, sum_insert, unit_to_U_mul, IH]

lemma unit_to_U_pow (x) (n : ‚Ñï) : mkG (x ^ n) = n ‚Ä¢ (mkG x) := by
  induction n with
  | zero => simp [unit_to_U_one]
  | succ n IH => simp [unit_to_U_mul, pow_succ, succ_nsmul, IH]

lemma unit_to_U_zpow (x) (n : ‚Ñ§) : mkG (x ^ n) = n ‚Ä¢ (mkG x) := by
  cases n with
  | ofNat n => simp [unit_to_U_pow]
  | negSucc n => simp [unit_to_U_inv, unit_to_U_pow]

lemma unit_to_U_map (x : (ùìû k)À£) : mkG (Units.map (algebraMap (ùìû k) (ùìû K)) x) = 0 := by
  delta unit_to_U
  rw [QuotientAddGroup.eq_zero_iff]
  convert zero_mem (AddCommGroup.torsion (Additive (relativeUnitsWithGenerator p hp hKL œÉ hœÉ)))
  rw [ofMul_eq_zero, QuotientGroup.eq_one_iff]
  exact ‚ü®_, rfl‚ü©

variable [NumberField k]

open multiplicity in
theorem padicValNat_dvd_iff_le' {p : ‚Ñï} (hp : p ‚â† 1) {a n : ‚Ñï} (ha : a ‚â† 0) :
    p ^ n ‚à£ a ‚Üî n ‚â§ padicValNat p a := by
  rw [pow_dvd_iff_le_emultiplicity, padicValNat_def' hp ha.bot_lt]
  exact ‚ü®fun h ‚Ü¶ FiniteMultiplicity.le_multiplicity_of_le_emultiplicity
    (Nat.finiteMultiplicity_iff.2
    ‚ü®hp, Nat.zero_lt_of_ne_zero ha‚ü©) h, fun h ‚Ü¶ le_emultiplicity_of_le_multiplicity h‚ü©

theorem padicValNat_dvd_iff' {p : ‚Ñï} (hp : p ‚â† 1) (n : ‚Ñï) (a : ‚Ñï) :
    p ^ n ‚à£ a ‚Üî a = 0 ‚à® n ‚â§ padicValNat p a := by
  rcases eq_or_ne a 0 with (rfl | ha)
  ¬∑ exact iff_of_true (dvd_zero _) (Or.inl rfl)
  ¬∑ rw [padicValNat_dvd_iff_le' hp ha, or_iff_right ha]

theorem padicValInt_dvd_iff' {p : ‚Ñï} (hp : p ‚â† 1) (n : ‚Ñï) (a : ‚Ñ§) :
    (p : ‚Ñ§) ^ n ‚à£ a ‚Üî a = 0 ‚à® n ‚â§ padicValInt p a := by
  rw [padicValInt, ‚Üê Int.natAbs_eq_zero, ‚Üê padicValNat_dvd_iff' hp, ‚Üê Int.natCast_dvd,
    Int.natCast_pow]

theorem padicValInt_dvd' {p : ‚Ñï} (a : ‚Ñ§) : (p : ‚Ñ§) ^ padicValInt p a ‚à£ a := by
  by_cases hp : p = 1
  ¬∑ rw [hp, Nat.cast_one, one_pow]; exact one_dvd _
  rw [padicValInt_dvd_iff' hp]
  exact Or.inr le_rfl

open Finset in
lemma exists_pow_smul_eq_and_not_dvd
    {Œπ : Type*} [Finite Œπ] (f : Œπ ‚Üí ‚Ñ§) (hf : f ‚â† 0) (p : ‚Ñï) (hp : p ‚â† 1) :
    ‚àÉ (n : ‚Ñï) (f' : Œπ ‚Üí ‚Ñ§), (f = p ^ n ‚Ä¢ f') ‚àß ‚àÉ i, ¬¨ ‚Üëp ‚à£ f' i := by
  cases nonempty_fintype Œπ
  have : (univ.filter (fun i ‚Ü¶ f i ‚â† 0)).Nonempty := by
    by_contra h
    exact hf (funext <| by simpa [filter_eq_empty_iff] using h)
  obtain ‚ü®i, hfi, hi‚ü© := exists_min_image _ (padicValInt p ‚àò f) this
  replace hfi : f i ‚â† 0 := by simpa using hfi
  let n := padicValInt p (f i)
  have : ‚àÄ j, (p : ‚Ñ§) ^ n ‚à£ f j := fun j ‚Ü¶ if h : f j = 0 then h ‚ñ∏ dvd_zero _ else
    (pow_dvd_pow _ (hi _ (mem_filter.mpr ‚ü®mem_univ j, h‚ü©))).trans (padicValInt_dvd' _)
  simp_rw [‚Üê Nat.cast_pow] at this
  choose f' hf' using this
  use n, f', funext hf', i
  intro hi
  have : (p : ‚Ñ§) ^ (n + 1) ‚à£ f i := by
    rw [hf', pow_succ, Nat.cast_pow]
    exact _root_.mul_dvd_mul_left _ hi
  simp only [padicValInt_dvd_iff' hp, hfi, false_or] at this
  omega

include hp in
lemma lh_pow_free_aux {M} [CommGroup M] [Module.Finite ‚Ñ§ (Additive M)] (ŒΩ : M)
    (hk : ‚àÄ (Œµ : M) (n : ‚Ñï), Œµ ^ (p ^ n : ‚Ñï) = 1 ‚Üí ‚àÉ i, ŒΩ ^ i = Œµ)
    (r) (hr : finrank ‚Ñ§ (Additive M) < r) (Œ∑ : Fin r ‚Üí Additive M) :
    ‚àÉ (a : ‚Ñ§) (Œπ : Fin r ‚Üí ‚Ñ§) (i : Fin r),
      ‚àë i, Œπ i ‚Ä¢ Œ∑ i = a ‚Ä¢ (Additive.ofMul ŒΩ) ‚àß ¬¨ ‚Üëp ‚à£ Œπ i := by
  obtain ‚ü®f, hf, hf'‚ü© := Fintype.not_linearIndependent_iff.mp
    (mt (LinearIndependent.fintype_card_le_finrank (R := ‚Ñ§) (b := Œ∑))
      ((hr.trans_eq (Fintype.card_fin r).symm).not_le))
  obtain ‚ü®n, f', hf', i, hi‚ü© := exists_pow_smul_eq_and_not_dvd f
    (Function.ne_iff.mpr hf') p hp.ne_one
  simp_rw [hf', Pi.smul_apply, smul_assoc, ‚Üê smul_sum] at hf
  obtain ‚ü®a, ha‚ü© := hk _ _ hf
  rw [‚Üê zpow_natCast] at ha
  exact ‚ü®a, f', i, ha.symm, hi‚ü©

include hp in
lemma lh_pow_free' {M} [CommGroup M] [Module.Finite ‚Ñ§ (Additive M)] (ŒΩ : M)
    (hk : ‚àÄ (Œµ : M) (n : ‚Ñï), Œµ ^ (p ^ n : ‚Ñï) = 1 ‚Üí ‚àÉ i, ŒΩ ^ i = Œµ)
    (r) (hr : finrank ‚Ñ§ (Additive M) + 1 < r) (Œ∑ : Fin r ‚Üí Additive M) :
    ‚àÉ (a : ‚Ñ§) (Œπ : Fin r ‚Üí ‚Ñ§) (i : Fin r),
      ‚àë i, Œπ i ‚Ä¢ (Œ∑ i) = (a * p) ‚Ä¢ (Additive.ofMul ŒΩ) ‚àß ¬¨ ‚Üëp ‚à£ Œπ i ‚àß (ŒΩ = 1 ‚Üí ‚Üëi ‚â† r - 1) := by
  cases' r with r
  ¬∑ exact (not_lt_zero' hr).elim
  simp only [Nat.succ_eq_add_one, add_lt_add_iff_right] at hr
  obtain ‚ü®a‚ÇÅ, Œπ‚ÇÅ, i‚ÇÅ, e‚ÇÅ, hi‚ÇÅ‚ü© := lh_pow_free_aux p hp ŒΩ hk r hr (Œ∑ ‚àò Fin.castSucc)
  obtain ‚ü®a‚ÇÇ, Œπ‚ÇÇ, i‚ÇÇ, e‚ÇÇ, hi‚ÇÇ‚ü© := lh_pow_free_aux p hp ŒΩ hk r hr (Œ∑ ‚àò Fin.succAbove i‚ÇÅ.castSucc)
  by_cases hŒΩ' : ŒΩ = 1
  ¬∑ refine ‚ü®1, Function.extend Fin.castSucc Œπ‚ÇÅ 0, Fin.castSucc i‚ÇÅ, ?_,
      by rwa [(Fin.castSucc_injective r).extend_apply], ?_‚ü©
    ¬∑ subst hŒΩ'
      simp only [Function.comp_apply, ofMul_one, smul_zero] at e‚ÇÅ ‚ä¢
      rw [‚Üê e‚ÇÅ]
      simp [Fin.sum_univ_castSucc, (Fin.castSucc_injective r).extend_apply,
        (Fin.castSucc_lt_last _).ne]
    ¬∑ rintro -; simp [(Fin.is_lt _).ne]
  by_cases ha‚ÇÅ : ‚Üëp ‚à£ a‚ÇÅ
  ¬∑ obtain ‚ü®b, hb‚ü© := ha‚ÇÅ
    refine ‚ü®b, Function.extend Fin.castSucc Œπ‚ÇÅ 0, Fin.castSucc i‚ÇÅ, ?_,
      by rwa [(Fin.castSucc_injective r).extend_apply], fun H ‚Ü¶ (hŒΩ' H).elim‚ü©
    rw [‚Üê hb.trans (mul_comm _ _), ‚Üê e‚ÇÅ]
    simp [Fin.sum_univ_castSucc, (Fin.castSucc_injective r).extend_apply,
      (Fin.castSucc_lt_last _).ne]
  by_cases ha‚ÇÇ : ‚Üëp ‚à£ a‚ÇÇ
  ¬∑ obtain ‚ü®b, hb‚ü© := ha‚ÇÇ
    refine ‚ü®b, Function.extend (Fin.succAbove i‚ÇÅ.castSucc) Œπ‚ÇÇ 0, Fin.succAbove i‚ÇÅ.castSucc i‚ÇÇ, ?_,
      by rwa [Fin.succAbove_right_injective.extend_apply], fun H ‚Ü¶ (hŒΩ' H).elim‚ü©
    rw [‚Üê hb.trans (mul_comm _ _), ‚Üê e‚ÇÇ]
    simp [Fin.sum_univ_succAbove _ i‚ÇÅ.castSucc, Fin.succAbove_right_injective.extend_apply]
  obtain ‚ü®Œ±‚ÇÅ, Œ≤‚ÇÅ, h‚ÇÅ‚ü© := (Nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd.mpr ha‚ÇÅ
  obtain ‚ü®Œ±‚ÇÇ, Œ≤‚ÇÇ, h‚ÇÇ‚ü© := (Nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd.mpr ha‚ÇÇ
  refine ‚ü®Œ±‚ÇÇ - Œ±‚ÇÅ, Œ≤‚ÇÅ ‚Ä¢ Function.extend Fin.castSucc Œπ‚ÇÅ 0 - Œ≤‚ÇÇ ‚Ä¢ Function.extend
      (Fin.succAbove i‚ÇÅ.castSucc) Œπ‚ÇÇ 0, i‚ÇÅ.castSucc, ?_, ?_, fun H ‚Ü¶ (hŒΩ' H).elim‚ü©
  ¬∑ rw [sub_mul, eq_sub_iff_add_eq.mpr h‚ÇÅ, eq_sub_iff_add_eq.mpr h‚ÇÇ]
    simp only [zsmul_eq_mul, Pi.intCast_def, Int.cast_id, Pi.sub_apply, Pi.mul_apply,
      Fin.succAbove_of_le_castSucc, ne_eq, not_not, not_exists, sub_sub_sub_cancel_left]
    simp only [sub_smul, mul_smul, ‚Üê e‚ÇÅ, ‚Üê e‚ÇÇ, sum_sub_distrib]
    rw [Fin.sum_univ_castSucc, Fin.sum_univ_succAbove _ i‚ÇÅ.castSucc]
    simp [(Fin.castSucc_injective r).extend_apply, Fin.succAbove_right_injective.extend_apply,
      (Fin.castSucc_lt_last _).ne, smul_sum]
  ¬∑ simp only [zsmul_eq_mul, Pi.intCast_def, Int.cast_id, Pi.sub_apply, Pi.mul_apply,
      exists_apply_eq_apply, not_true_eq_false, (Fin.castSucc_injective r).extend_apply,
      Fin.exists_succAbove_eq_iff, ne_eq, not_false_eq_true, Function.extend_apply', Pi.zero_apply,
      mul_zero, sub_zero, (Nat.prime_iff_prime_int.mp hp).dvd_mul, hi‚ÇÅ, not_or, and_true]
    intro H
    exact (Nat.prime_iff_prime_int.mp hp).not_dvd_one
      (h‚ÇÅ ‚ñ∏ dvd_add (dvd_mul_left (p : ‚Ñ§) Œ±‚ÇÅ) (dvd_mul_of_dvd_left H a‚ÇÅ))

lemma NumberField.Units.finrank_eq : finrank ‚Ñ§ (Additive (ùìû k)À£) = NumberField.Units.rank k := by
  rw [‚Üê rank_modTorsion]
  show _ = finrank ‚Ñ§ (Additive (ùìû k)À£ ‚ß∏ (AddCommGroup.torsion <| Additive (ùìû k)À£))
  rw [‚Üê Submodule.torsion_int]
  exact (congr_arg Cardinal.toNat (rank_quotient_eq_of_le_torsion le_rfl)).symm

include hp in
lemma lh_pow_free [FiniteDimensional k K] (ŒΩ: (ùìû k)À£)
    (hk : ‚àÄ (Œµ : (ùìû k)À£) (n : ‚Ñï), Œµ ^ (p ^ n : ‚Ñï) = 1 ‚Üí ‚àÉ i, ŒΩ ^ i = Œµ)
    (Œ∑ : Fin (NumberField.Units.rank k + 2) ‚Üí Additive (ùìû k)À£) :
    ‚àÉ (a : ‚Ñ§) (Œπ : Fin (NumberField.Units.rank k + 2) ‚Üí ‚Ñ§) (i‚ÇÄ : Fin (NumberField.Units.rank k + 2)),
      ‚àë i, Œπ i ‚Ä¢ (Œ∑ i) = (a*p) ‚Ä¢ (Additive.ofMul ŒΩ) ‚àß ¬¨ ((p : ‚Ñ§) ‚à£ Œπ i‚ÇÄ) ‚àß
      (ŒΩ = 1 ‚Üí i‚ÇÄ ‚â† Fin.last _) := by
  convert lh_pow_free' p hp ŒΩ hk _ ?_ Œ∑
  ¬∑ simp only [ge_iff_le, Nat.succ_sub_succ_eq_sub, nonpos_iff_eq_zero, add_eq_zero, one_ne_zero,
      and_false, tsub_zero, Fin.ext_iff, Fin.val_last]
  ¬∑ rw [NumberField.Units.finrank_eq]
    exact Nat.lt.base _

noncomputable
def Algebra.normZeroHom (R S) [CommRing R] [Ring S] [Nontrivial S] [Algebra R S]
    [Module.Free R S] [Module.Finite R S] :
    S ‚Üí*‚ÇÄ R where
  __ := Algebra.norm R
  map_zero' := Algebra.norm_zero

lemma norm_map_zpow {R S} [Field R] [DivisionRing S] [Nontrivial S] [Algebra R S]
    [Module.Free R S] [Module.Finite R S] (s : S) (n : ‚Ñ§) :
    Algebra.norm R (s ^ n) = (Algebra.norm R s) ^ n := map_zpow‚ÇÄ (Algebra.normZeroHom R S) s n

variable [NumberField K]

include hKL in
--some complicated unit called J in the paper, has norm 1
lemma Hilbert92_aux1 (n : ‚Ñï) (H : Fin n ‚Üí Additive (ùìû K)À£) (ŒΩ : (ùìû k)À£)
    (a : ‚Ñ§) (Œπ : Fin n ‚Üí ‚Ñ§) (Œ∑ : Fin n ‚Üí Additive (ùìû k)À£)
    (ha : ‚àë i : Fin n, Œπ i ‚Ä¢ Œ∑ i = (a * ‚Üë‚Üëp) ‚Ä¢ Additive.ofMul ŒΩ)
    (hŒ∑ : ‚àÄ i, Additive.toMul (Œ∑ i) = Algebra.norm k (S := K) ((Additive.toMul (H i) : _) : K)) :
    letI J : (ùìû K)À£ := (Additive.toMul (‚àë i : Fin n, Œπ i ‚Ä¢ H i)) *
      (Units.map (algebraMap (ùìû k) (ùìû K)).toMonoidHom ŒΩ) ^ (-a)
    Algebra.norm k (S := K) ((J : (ùìû K)À£) : K) = 1 := by
  have hcoe : ((algebraMap (ùìû K) K) ((algebraMap (ùìû k) (ùìû K)) ((ŒΩ ^ a)‚Åª¬π).1)) =
    algebraMap (ùìû k) (ùìû K) ((ŒΩ ^ a)‚Åª¬π).1 := rfl
  simp only [toMul_sum, toMul_zsmul, zpow_neg, Units.val_mul, Units.coe_prod, map_mul, map_prod,
    Units.coe_zpow, map_mul, map_prod, norm_map_zpow, Units.coe_map]
  rw [‚Üê map_zpow, Units.coe_map_inv]
  simp only [RingHom.toMonoidHom_eq_coe, MonoidHom.coe_coe]
  have hcoe1 :
      algebraMap (ùìû k) k (((ŒΩ ^ (p : ‚Ñï)) ^ a)‚Åª¬π).1 = ((((ŒΩ : ùìû k) : k) ^ (p : ‚Ñï)) ^ a)‚Åª¬π := by
    convert (Units.coe_map_inv ((algebraMap (ùìû k) k) : (ùìû k) ‚Üí* k) ((ŒΩ ^ (p : ‚Ñï)) ^ a)).symm
    simp
  rw [hcoe, RingOfInteger.coe_algebraMap_apply, Algebra.norm_algebraMap, hKL, ‚Üê map_pow,
    ‚Üê Units.val_pow_eq_pow_val, inv_pow, ‚Üê zpow_natCast, ‚Üê zpow_mul, mul_comm a, zpow_mul,
      zpow_natCast, hcoe1]
  apply_fun Additive.toMul at ha
  apply_fun ((‚Üë) : (ùìû k)À£ ‚Üí k) at ha
  simp only [toMul_sum, toMul_zsmul, Units.coe_prod, map_prod, hŒ∑,
    Units.coe_zpow, toMul_ofMul] at ha
  rwa [‚Üê zpow_natCast, ‚Üê zpow_mul, mul_comm _ a, mul_inv_eq_one‚ÇÄ]
  simp [‚Üê Units.coe_zpow]

variable [IsGalois k K]

include hKL in
noncomputable
instance relativeUnitsModule : Module A G := by
  letI : Module A (Additive (relativeUnitsWithGenerator p hp hKL œÉ hœÉ)) :=
    (isTors' p hp hKL œÉ hœÉ).module
  infer_instance

lemma relativeUnitsModule_zeta_smul (x) :
    (zeta p) ‚Ä¢ mkG x = mkG (Units.map (galRestrictHom (ùìû k) k K (ùìû K) œÉ) x) := by
  let œÜ := (addMonoidEndRingEquivInt _
      (MulEquiv.Monoid.End <| relativeUnitsMap <| ((AlgEquiv.algHomUnitsEquiv _ _).symm œÉ).val))
  show QuotientAddGroup.mk ((Module.AEval'.of œÜ).symm <|
    Polynomial.X (R := ‚Ñ§) ‚Ä¢ Module.AEval'.of œÜ (Additive.ofMul (QuotientGroup.mk x))) = _
  simp only [AlgEquiv.val_algHomUnitsEquiv_symm_apply, MulEquiv.Monoid.End_apply,
    Equiv.toFun_as_coe, addMonoidEndRingEquivInt_apply, AddHom.toFun_eq_coe, LinearMap.coe_toAddHom,
    LinearEquiv.coe_coe, addMonoidHomLequivInt_apply, Module.AEval.of_symm_smul, Polynomial.aeval_X,
    LinearEquiv.symm_apply_apply, LinearMap.smul_def, AddMonoidHom.coe_toIntLinearMap,
    MonoidHom.toAdditive_apply_apply, toMul_ofMul, unit_to_U]
  rfl

local instance {M} [AddCommGroup M] : NoZeroSMulDivisors ‚Ñ§ (M ‚ß∏ AddCommGroup.torsion M) := by
  rw [‚Üê Submodule.torsion_int]
  show NoZeroSMulDivisors ‚Ñ§ (M ‚ß∏ Submodule.torsion ‚Ñ§ M)
  infer_instance

local instance : Module.Finite ‚Ñ§ (Additive <| RelativeUnits k K) :=
  inferInstanceAs
    (Module.Finite ‚Ñ§ (Additive (ùìû K)À£ ‚ß∏ AddSubgroup.toIntSubmodule (Subgroup.toAddSubgroup
    (MonoidHom.range <| Units.map (algebraMap (ùìû k) (ùìû K) : (ùìû k) ‚Üí* (ùìû K))))))

local instance : Module.Finite ‚Ñ§ (Additive <| relativeUnitsWithGenerator p hp hKL œÉ hœÉ) :=
  inferInstanceAs (Module.Finite ‚Ñ§ (Additive (RelativeUnits k K)))

local instance : Module.Finite ‚Ñ§ G := Module.Finite.of_surjective
  (M := Additive (relativeUnitsWithGenerator p hp hKL œÉ hœÉ))
  (QuotientAddGroup.mk' _).toIntLinearMap (QuotientAddGroup.mk'_surjective _)

local instance : Module.Free ‚Ñ§ G := Module.free_of_finite_type_torsion_free'

noncomputable
def unitlifts (S : systemOfUnits p G (NumberField.Units.rank k + 1))  :
    Fin (NumberField.Units.rank k + 1) ‚Üí Additive (ùìû K)À£ :=
  fun i ‚Ü¶ Additive.ofMul (Additive.toMul (S.units i).out).out

lemma unitlifts_spec (S : systemOfUnits p G (NumberField.Units.rank k + 1)) (i) :
    mkG (Additive.toMul <| unitlifts p hp hKL œÉ hœÉ S i) = S.units i := by
  delta unit_to_U unitlifts
  simp only [toMul_ofMul, Quotient.out_eq', ofMul_toMul]

lemma u_lemma2 (u v : (ùìû K)À£) (hu : u = v / (œÉ v : K)) : (mkG u) = (1 - zeta p : A) ‚Ä¢ (mkG v) := by
  rw [sub_smul, one_smul, relativeUnitsModule_zeta_smul, ‚Üê unit_to_U_div]
  congr
  rw [eq_div_iff_mul_eq']
  ext
  simp only [Units.val_mul, Units.coe_map, MonoidHom.coe_coe, map_mul, coe_galRestrictHom_apply, hu]
  exact div_mul_cancel‚ÇÄ _ (by simp)

include hKL hœÉ hp in
/- If ŒΩ = E/œÉ E, then the norm of E is E^p -/
lemma Hilbert92_aux2 (E : (ùìû K)À£) (ŒΩ : k) (hE : algebraMap k K ŒΩ = E / œÉ E)
  (hŒΩ : (ŒΩ : k) ^ (p : ‚Ñï) = 1) (hpodd : (p : ‚Ñï) ‚â† 2) :
    algebraMap k K (Algebra.norm k (S := K) E) = E ^ (p : ‚Ñï) := by
  have h1 : ‚àÄ (i : ‚Ñï), (œÉ ^ i) E = ((algebraMap k K ŒΩ)‚Åª¬π)^i * E := by
    intro i
    induction i with
    | zero =>
      simp only [pow_zero, AlgEquiv.one_apply, one_mul]
    | succ n ih =>
      rw [pow_succ', AlgEquiv.mul_apply, ih, pow_succ']
      simp only [inv_pow, map_mul, map_inv‚ÇÄ, map_pow, AlgEquiv.commutes]
      have h0 : (algebraMap k K) ŒΩ ‚â† 0 := fun h ‚Ü¶ by simp [(map_eq_zero _).1 h] at hŒΩ
      field_simp [h0]
      rw [‚Üê mul_assoc]
      congr
      rw [hE]
      field_simp
  rw [norm_eq_prod_pow_gen œÉ hœÉ, orderOf_eq_card_of_forall_mem_zpowers hœÉ,
    ‚Üê Fintype.card_eq_nat_card, IsGalois.card_aut_eq_finrank, hKL]
  conv =>
    enter [1, 2, i]
    rw [h1 i, mul_comm]
  rw [prod_mul_distrib, prod_const, card_range, prod_pow_eq_pow_sum, inv_pow, mul_eq_left‚ÇÄ,
    inv_eq_one, sum_range_id, Nat.mul_div_assoc, pow_mul, ‚Üê map_pow, hŒΩ, map_one, one_pow]
  ¬∑ exact even_iff_two_dvd.1 (hp.even_sub_one hpodd)
  ¬∑ simp

variable [IsUnramifiedAtInfinitePlaces k K]

lemma NumberField.Units.rank_of_isUnramified :
    NumberField.Units.rank K = (finrank k K) * NumberField.Units.rank k + (finrank k K) - 1 := by
  delta NumberField.Units.rank
  rw [IsUnramifiedAtInfinitePlaces.card_infinitePlace k,
    mul_comm, mul_tsub, mul_one, tsub_add_cancel_of_le]
  refine (mul_one _).symm.trans_le (Nat.mul_le_mul_left _ ?_)
  rw [Nat.one_le_iff_ne_zero, ‚Üê Nat.pos_iff_ne_zero, Fintype.card_pos_iff]
  infer_instance

lemma finrank_G : finrank ‚Ñ§ G = (Units.rank k + 1) * (‚Üëp - 1) := by
  rw [‚Üê Submodule.torsion_int]
  refine (congr_arg Cardinal.toNat (rank_quotient_eq_of_le_torsion le_rfl)).trans ?_
  show finrank ‚Ñ§ (Additive (ùìû K)À£ ‚ß∏ AddSubgroup.toIntSubmodule (Subgroup.toAddSubgroup
    (MonoidHom.range <| Units.map (algebraMap (ùìû k) (ùìû K) : (ùìû k) ‚Üí* (ùìû K))))) = _
  rw [Submodule.finrank_quotient]
  show _ - finrank ‚Ñ§ (LinearMap.range <| AddMonoidHom.toIntLinearMap <|
    MonoidHom.toAdditive <| Units.map (algebraMap (ùìû k) (ùìû K) : (ùìû k) ‚Üí* (ùìû K))) = _
  rw [LinearMap.finrank_range_of_inj, NumberField.Units.finrank_eq, NumberField.Units.finrank_eq,
    NumberField.Units.rank_of_isUnramified (k := k), add_mul, one_mul, mul_tsub, mul_one, mul_comm,
      add_tsub_assoc_of_le, tsub_add_eq_add_tsub, hKL]
  ¬∑ exact (mul_one _).symm.trans_le (Nat.mul_le_mul_left _ hp.one_lt.le)
  ¬∑ exact hKL ‚ñ∏ hp.one_lt.le
  ¬∑ intros i j e
    apply Additive.toMul.injective
    ext
    apply (algebraMap k K).injective
    exact congr_arg (fun i : Additive (ùìû K)À£ ‚Ü¶ (‚Üë(‚Üë(Additive.toMul i) : ùìû K) : K)) e

theorem Hilbert91 :
    ‚àÉ S : systemOfUnits p G (NumberField.Units.rank k + 1), S.IsFundamental :=
  systemOfUnits.IsFundamental.existence p hp G (NumberField.Units.rank k + 1)
    (finrank_G p hp hKL œÉ hœÉ)

lemma IsPrimitiveRoot.coe_coe_iff {ŒΩ : (ùìû k)À£} {n} :
    IsPrimitiveRoot (ŒΩ : k) n ‚Üî IsPrimitiveRoot ŒΩ n :=
  IsPrimitiveRoot.map_iff_of_injective
    (f := (algebraMap (ùìû k) k).toMonoidHom.comp (Units.coeHom (ùìû k)))
    ((IsFractionRing.injective (ùìû k) k).comp Units.ext)

include hp in
lemma h_exists' : ‚àÉ (h : ‚Ñï) (ŒΩ : (ùìû k)À£),
    IsPrimitiveRoot (ŒΩ : k) (p ^ h) ‚àß
    ‚àÄ (Œµ : (ùìû k)À£) (n : ‚Ñï), Œµ ^ (p ^ n : ‚Ñï) = 1 ‚Üí ‚àÉ i, ŒΩ ^ i = Œµ := by
  classical
  let H := Subgroup.toAddSubgroup.symm
    (Submodule.torsion' ‚Ñ§ (Additive (ùìû k)À£) (Submonoid.powers (p : ‚Ñï))).toAddSubgroup
  have : H ‚â§ NumberField.Units.torsion k := by
    rintro x ‚ü®‚ü®_, i, rfl‚ü©, hnx : x ^ (p ^ i : ‚Ñï) = 1‚ü©
    exact isOfFinOrder_iff_pow_eq_one.mpr ‚ü®p ^ i, Fin.pos', hnx‚ü©
  obtain ‚ü®ŒΩ, hŒΩ‚ü© := Subgroup.isCyclic_of_le this
  obtain ‚ü®‚ü®_, i, rfl‚ü©, hiŒΩ : (ŒΩ : (ùìû k)À£) ^ (p ^ i : ‚Ñï) = 1‚ü© := ŒΩ.prop
  obtain ‚ü®j, _, hj'‚ü© := (Nat.dvd_prime_pow hp).mp (orderOf_dvd_of_pow_eq_one hiŒΩ)
  refine ‚ü®j, ŒΩ, IsPrimitiveRoot.coe_coe_iff.mpr (hj' ‚ñ∏ IsPrimitiveRoot.orderOf ŒΩ.1),
    fun Œµ n hn ‚Ü¶ ?_‚ü©
  let _ :   Fintype (Units.torsion k) := inferInstance
  have : Fintype H := Set.fintypeSubset (NumberField.Units.torsion k) (by exact this)
  obtain ‚ü®i, hi‚ü© := mem_powers_iff_mem_zpowers.mpr (hŒΩ ‚ü®Œµ, ‚ü®_, n, rfl‚ü©, hn‚ü©)
  exact ‚ü®i, congr_arg Subtype.val hi‚ü©

local notation "r" => NumberField.Units.rank k

instance : CommGroup ((ùìû k))À£ := inferInstance

lemma IsPrimitiveRoot.one_left_iff {M} [CommMonoid M] {n : ‚Ñï} :
    IsPrimitiveRoot (1 : M) n ‚Üî n = 1 :=
  ‚ü®fun H ‚Ü¶ Nat.dvd_one.mp (H.dvd_of_pow_eq_one 1 (one_pow _)), fun e ‚Ü¶ e ‚ñ∏ IsPrimitiveRoot.one‚ü©

include hp hKL hœÉ in
-- TODO : remove `p ‚â† 2`. The offending case is when `K = k[i]`.
lemma almostHilbert92 (hpodd : (p : ‚Ñï) ‚â† 2) :
    ‚àÉ Œ∑ : (ùìû K)À£, Algebra.norm k (Œ∑ : K) = 1 ‚àß ‚àÄ Œµ : (ùìû K)À£, (Œ∑ : K) ‚â† Œµ / (œÉ Œµ : K) := by
  classical
  obtain ‚ü®h, ŒΩ, hŒΩ, hŒΩ'‚ü© := h_exists' p (k := k) hp
  by_cases H : ‚àÄ Œµ : (ùìû K)À£, algebraMap k K ŒΩ ^ ((p : ‚Ñï)^(h - 1)) ‚â† Œµ / (œÉ Œµ : K)
  /- ŒΩ is Œ∂' in Hilbert, so their Œ∂ is our ŒΩ ^ ((p : ‚Ñï)^(h - 1))  -/
  ¬∑ exact Hilbert92_aux0 p hKL œÉ h ŒΩ hŒΩ H
  simp only [ne_eq, not_forall, not_not] at H
  obtain ‚ü®E, hE‚ü© := H
  let NE := Units.map (RingOfIntegers.norm k) E
  have hNE : (NE : k) = Algebra.norm k (E : K) := rfl
  obtain ‚ü®S, hS‚ü© := Hilbert91 p (K := K) (k := k) hp hKL œÉ hœÉ
  have NE_p_pow : (Units.map (algebraMap (ùìû k) (ùìû K)).toMonoidHom NE) = E ^ (p : ‚Ñï) := by
    ext
    simp only [RingHom.toMonoidHom_eq_coe, Units.coe_map, MonoidHom.coe_coe,
      RingOfInteger.coe_algebraMap_apply, Units.val_pow_eq_pow_val, map_pow]
    rw [‚Üê map_pow] at hE
    refine Hilbert92_aux2 p hp hKL œÉ hœÉ E _ hE ?_ hpodd
    rw [‚Üê pow_mul, ‚Üê pow_succ]
    apply (hŒΩ.pow_eq_one_iff_dvd _).2
    cases h <;> simp only [Nat.zero_eq, pow_zero, zero_le, tsub_eq_zero_of_le,
      zero_add, pow_one, one_dvd, Nat.succ_sub_succ_eq_sub,
      nonpos_iff_eq_zero, tsub_zero, dvd_refl]
  let H := unitlifts p hp hKL œÉ hœÉ S
  -- the list of norms of fundamental units
  let N : Fin (r + 1) ‚Üí Additive (ùìû k)À£ :=
    fun e => Additive.ofMul (Units.map (RingOfIntegers.norm k) (Additive.toMul (H e)))
  --append the norm of E to the end of the list of norms of fundamental units
  let Œ∑ : Fin (r + 2) ‚Üí Additive (ùìû k)À£ := Fin.snoc N (Additive.ofMul NE)
  obtain ‚ü®a, Œπ, i, ha, ha', ha''‚ü© := lh_pow_free p hp ŒΩ (k := k) (K := K) hŒΩ' Œ∑
  --append E to the end of the list of fundamental units
  let H2 : Fin (r + 2) ‚Üí Additive (ùìû K)À£ := Fin.snoc H (Additive.ofMul E)
  --J = (‚àè_i H_i^a_i)*E^{a_{r+2}}*ŒΩ^{-a}
  let J := (Additive.toMul (‚àë i : Fin (r + 2), Œπ i ‚Ä¢ H2 i)) *
                (Units.map (algebraMap (ùìû k) (ùìû K)).toMonoidHom ŒΩ) ^ (-a)
  refine ‚ü®J, ?_‚ü©
  constructor
  ¬∑ apply Hilbert92_aux1 p hKL (r + 2) H2 ŒΩ a Œπ Œ∑ ha
    intro i
    induction i using Fin.lastCases with
    | last =>
      simp only [Fin.snoc_last, toMul_ofMul, Units.coe_map, RingOfIntegers.coe_norm, NE, Œ∑, H2]
    | cast i =>
      simp only [Fin.snoc_castSucc, toMul_ofMul, Units.coe_map, RingOfIntegers.coe_norm, NE,
        Œ∑, H2, J, N, H]
  ¬∑ intro Œµ hŒµ
    --going to show that if not this would contradict our corollary.
    refine hS.corollary p hp _ _ (finrank_G p hp hKL œÉ hœÉ) _ (Œπ ‚àò Fin.castSucc) ?_ (mkG Œµ) ?_
    ¬∑ by_contra hŒµ'
      /-assume for contradiction this is not the case, so all of the first r+1 indecies are
      divisible by p-/
      simp only [Function.comp_apply, not_exists, not_not] at hŒµ'
      --i cant be one of these indecies, since its not divisible by p
      have : i ‚àâ Set.range Fin.castSucc := by rintro ‚ü®i, rfl‚ü©; exact ha' (hŒµ' i)
      rw [‚Üê Fin.succAbove_last, Fin.range_succAbove, Set.mem_compl_iff,
        Set.mem_singleton_iff, not_not] at this
      --this has forced i to be r+2
      rw [this] at ha'
      -- now do the caser h  = 0 or general
      cases' h with h
      ¬∑ -- the h=0 case
        refine ha'' ?_ this -- in this case we have both that i = r+2 and i ‚â† r+2 (since ŒΩ = 1)
        ext
        simpa only [Units.val_one, map_one, pow_zero, IsPrimitiveRoot.one_right_iff] using hŒΩ
      -- general case, h ‚â† 0
      obtain ‚ü®Œµ', hŒµ'‚ü© : ‚àÉ Œµ' : (ùìû k)À£, Œµ' ^ (p : ‚Ñï) = NE := by
        --the norm of E now has to be a p-th power of a unit.
        rw [‚Üê (Nat.prime_iff_prime_int.mp hp).coprime_iff_not_dvd] at ha'
        obtain ‚ü®Œ±, Œ≤, hŒ±Œ≤‚ü© := ha'
        choose Œπ' hŒπ' using hŒµ'
        rw [Fin.sum_univ_castSucc] at ha
        simp (config := { zeta := false, proj := false }) only
          [hŒπ', Fin.snoc_castSucc, Fin.snoc_last, mul_smul, Œ∑] at ha
        rw [‚Üê smul_sum, add_comm, ‚Üê eq_sub_iff_add_eq, smul_comm, ‚Üê smul_sub] at ha
        apply_fun ((p : ‚Ñ§) ‚Ä¢ (Œ± ‚Ä¢ Additive.ofMul NE) + Œ≤ ‚Ä¢ ¬∑) at ha
        conv_rhs at ha => rw [smul_comm Œ≤, ‚Üê smul_add]
        rw [smul_smul, smul_smul, ‚Üê add_smul, mul_comm _ Œ±, hŒ±Œ≤, one_smul] at ha
        exact ‚ü®_, ha.symm‚ü©
      have hŒΩ'' := (hŒΩ.pow (p ^ h.succ).pos (pow_succ _ _)).map_of_injective
        (algebraMap k K).injective
      obtain ‚ü®Œµ'', hŒµ''‚ü© : -- now it means the E must be a unit in k (Not just K).
          ‚àÉ Œµ'' : (ùìû k)À£, E = Units.map (algebraMap (ùìû k) (ùìû K)).toMonoidHom Œµ'' := by
        rw [‚Üê hŒµ', map_pow, eq_comm, ‚Üê mul_inv_eq_one, ‚Üê inv_pow, ‚Üê mul_pow] at NE_p_pow
        apply_fun ((‚Üë) : (ùìû K)À£ ‚Üí K) at NE_p_pow
        simp only [RingHom.toMonoidHom_eq_coe, Units.val_pow_eq_pow_val, Units.val_mul,
          Units.coe_map_inv, MonoidHom.coe_coe, SubmonoidClass.coe_pow, Submonoid.coe_mul,
          Subsemiring.coe_toSubmonoid, Subalgebra.coe_toSubsemiring, Units.val_one,
          OneMemClass.coe_one, RingOfInteger.coe_algebraMap_apply] at NE_p_pow
        have : NeZero p.1 := ‚ü®hp.pos.ne'‚ü©
        obtain ‚ü®i, -, e‚ü© := hŒΩ''.eq_pow_of_pow_eq_one NE_p_pow
        use ((ŒΩ ^ (p : ‚Ñï) ^ h) ^ i * Œµ')
        rw [map_mul, ‚Üê mul_inv_eq_iff_eq_mul]
        ext
        simpa using e.symm
      simp only [Nat.succ_sub_succ_eq_sub, tsub_zero, ‚Üê map_pow, hŒµ'', RingHom.toMonoidHom_eq_coe,
        Units.coe_map, MonoidHom.coe_coe, RingOfInteger.coe_algebraMap_apply,
        AlgEquiv.commutes] at hE
      replace hE : (algebraMap k K) (((ŒΩ : ùìû k) : k) ^ (p : ‚Ñï) ^ h) = 1 := by
       rwa [div_self (by simp)] at hE
      erw [hE] at hŒΩ'' --why?
      rw [IsPrimitiveRoot.one_left_iff] at hŒΩ''
      exact hp.one_lt.ne.symm hŒΩ''
      --proof ends by showing that our root of unity would then be trivial, which cant happen since h ‚â† 0.
    ¬∑ rw [‚Üê u_lemma2 p hp hKL œÉ hœÉ _ _ hŒµ, unit_to_U_mul, toMul_sum, unit_to_U_prod,
        Fin.sum_univ_castSucc]
      -- check this equality in the quotient, removes the ŒΩ, just asks that the reduction of E is zero
      simp only [Fin.snoc_castSucc, toMul_zsmul, unit_to_U_zpow, unitlifts_spec, Fin.snoc_last,
        toMul_ofMul, RingHom.toMonoidHom_eq_coe, zpow_neg, unit_to_U_inv, Function.comp_apply,
        unit_to_U_map, smul_zero, neg_zero, add_zero, add_eq_left, NE, Œ∑, H2, J, N, H]
      apply_fun mkG at NE_p_pow
      simp only [RingHom.toMonoidHom_eq_coe, unit_to_U_map, unit_to_U_pow] at NE_p_pow
      rw [eq_comm, smul_eq_zero] at NE_p_pow
      simp only [Nat.cast_eq_zero, PNat.ne_zero, false_or] at NE_p_pow
      rw [NE_p_pow, smul_zero]

end application

lemma Hilbert92 [Algebra k K] [IsGalois k K] [NumberField k] [NumberField K]
    (hKL : Nat.Prime (finrank k K)) (hpodd : finrank k K ‚â† 2)
    (œÉ : K ‚âÉ‚Çê[k] K) (hœÉ : ‚àÄ x, x ‚àà Subgroup.zpowers œÉ) :
    ‚àÉ Œ∑ : (ùìû K)À£, Algebra.norm k (Œ∑ : K) = 1 ‚àß ‚àÄ Œµ : (ùìû K)À£, (Œ∑ : K) ‚â† Œµ / (œÉ Œµ : K) :=
  haveI := IsUnramifiedAtInfinitePlaces_of_odd_finrank (hKL.odd_of_ne_two hpodd)
  letI : IsCyclic (K ‚âÉ‚Çê[k] K) := ‚ü®œÉ, hœÉ‚ü©
  almostHilbert92 ‚ü®finrank k K, finrank_pos‚ü© hKL rfl œÉ hœÉ hpodd

end thm91
